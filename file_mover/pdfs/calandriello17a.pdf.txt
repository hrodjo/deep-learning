Second-Order Kernel Online Convex Optimization with Adaptive Sketching

Daniele Calandriello 1 Alessandro Lazaric 1 Michal Valko 1

Abstract
Kernel online convex optimization (KOCO) is a
framework combining the expressiveness of nonparametric kernel models with the regret guarantees of online learning. First-order KOCO methods such as functional gradient descent require
only O(t) time and space per iteration, and, when
the only information on the losses is their
√ convexity, achieve a minimax optimal O( T ) regret. Nonetheless, many common losses in kernel problems, such as squared loss, logistic loss,
and squared hinge loss posses stronger curvature
that can be exploited. In this case, second-order
KOCO methods achieve O(log(Det(K))) regret,
which we show scales as O(deff log T ), where
deff is the effective dimension of the
√ problem and
is usually much smaller than O( T ). The main
drawback of second-order methods is their much
higher O(t2 ) space and time complexity. In this
paper, we introduce kernel online Newton step
(KONS), a new second-order KOCO method that
also achieves O(deff log T ) regret. To address the
computational complexity of second-order methods, we introduce a new matrix sketching algorithm for the kernel matrix Kt , and show that for
a chosen parameter γ ≤ 1 our Sketched-KONS
reduces the space and time complexity by a factor of γ 2 to O(t2 γ 2 ) space and time per iteration,
while incurring only 1/γ times more regret.

1. Introduction
Online convex optimization (OCO) (Zinkevich, 2003) models the problem of convex optimization over Rd as a game
over t ∈ {1, . . . , T } time steps between an adversary and
the player. In its linear version, that we refer to as linearOCO (LOCO), the adversary chooses a sequence of arbitrary convex losses `t and points xt , and a player chooses
weights wt and predicts xTt wt . The goal of the player is to
1
SequeL team, INRIA Lille - Nord Europe. Correspondence
to: Daniele Calandriello <daniele.calandriello@inria.fr>.

Proceedings of the 34 th International Conference on Machine
Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017
by the author(s).

minimize the regret, defined as the difference between the
losses of the predictions obtained using the weights played
by the player and the best fixed weight in hindsight given
all points and losses.
Gradient descent. For this setting, Zinkevich (2003)
showed that simple gradient descent (GD), combined with
a smart choice√
for the stepsize ηt of the gradient updates,
achieves a O( dT ) regret with a O(d) space and time
cost per iteration. When the only assumption on the losses
is simple convexity, this upper bound matches the corresponding lower bound (Luo et al., 2016), thus making
first-order methods (e.g., GD) essentially unimprovable in
a minimax sense. Nonetheless, when the losses have additional curvature properties, Hazan et al. (2006) show that
online Newton step (ONS), an adaptive method that exploits second-order (second derivative) information on the
losses, can achieve a logarithmic regret O(d log T ). The
downside of this adaptive method is the larger O(d2 ) space
and per-step time complexity, since second-order updates
require to construct, store, and invert Ht , a preconditioner
matrix related to the Hessian of the losses used to correct
the first-order updates.
Kernel gradient descent. For linear models, such as the
ones considered in LOCO, a simple way to create more expressive models is to map them in some high-dimensional
space, the feature space, and then use the kernel trick
(Schölkopf & Smola, 2001) to avoid explicitly computing their high-dimensional representation. Mapping to a
larger space allows the algorithm to better fit the losses
chosen by the adversary and reduce its cumulative loss.
As a drawback, the Kernel OCO (KOCO) problem1 is
fundamentally harder than LOCO, due to 1) the fact that
an infinite parametrization makes regret bounds scaling
with the dimension d meaningless and 2) the size of the
model, and therefore time and space complexities, scales
with t itself, making these methods even less performant
than LOCO algorithms. Kernel extensions of LOCO algorithms have been proposed for KOCO, such as functional
GD (e.g.,
√ NORMA, Kivinen et al., 2004) which achieves
a O( T ) regret with a O(t) space and time cost per iteration. For second-order methods, the Second-Order Per1
This setting is often referred to as online kernel learning or
kernel-based online learning in the literature.

Second-Order Kernel Online Convex Optimization with Adaptive Sketching

ceptron (Cesa-Bianchi et al., 2005) or NAROW (Orabona
& Crammer, 2010) for generic curved losses and Recursive Kernel Least Squares (Zhdanov & Kalnishkan, 2010)
or Kernel AAR (Gammerman et al., 2004) for the specific
case of `2 losses provide bounds that scale with the logdeterminant of the kernel-matrix. As we show, this quantity is closely related to the effective dimension dTeff of the
of the points xt , and scales as O(dTeff log T ), playing a similar role as the O(d log T ) bound from LOCO.
Approximate GD. To trade off between computational
complexity smaller than O(d2 ) and improved regret
(close to O(d log T )), several methods try approximate
second-order updates, replacing Ht with an approxie t that can be efficiently stored and inverted. Adamate H
Grad (Duchi et al., 2011) and ADAM (Kingma & Ba, 2015)
reweight the gradient updates on a per-coordinate basis use t , but these methods ultimately only iming a diagonal H
√
prove the regret dependency on d and leave the T component unchanged. Sketched-ONS, by Luo et al. (2016),
uses matrix sketching to approximate Ht with a r-rank
e t , that can be efficiently stored and updated in
sketch H
2
O(dr ) time and space, close to the O(d) complexity of diagonal approximations. More importantly, Sketched-ONS
achieves a much smaller regret compared to diagonal approximations: When the true Ht is of low-rank r, it recovers a O(r log T ) regret bound logarithmic in T . Unfortunately, due to the sketch approximation, a new term appears
in the bound that scales with the spectra of Ht , and in some
cases can grow much larger than O(log T ).
Approximate kernel GD. Existing approximate GD methods for KOCO focus only on first-order updates, trying to
reduce the O(t) per-step complexity. Budgeted methods,
such as Budgeted-GD (Wang et al., 2012) and budgeted
variants of the perceptron (Cavallanti et al., 2007; Dekel
et al., 2008; Orabona et al., 2008) explicitly limit the size
of the model, using some destructive budget maintenance
procedure (e.g., removal, projection) to constrain the natural model growth over time. Alternatively, functional approximation methods in the primal (Lu et al., 2016) or dual
(Le et al., 2016) use non-linear embedding techniques, such
as random feature expansion (Le et al., 2013), to reduce
the KOCO problem to a LOCO problem √
and solve it efficiently. Unfortunately, to guarantee O( T ) regret using less than O(t) space and time per round w.h.p., all
of these methods require additional assumptions, such as
points xt coming from a distribution or strong convexity
on the losses. Moreover, as approximate first-order
meth√
ods, they can at most hope to match the O( T ) regret of
exact GD, and among second-order kernel methods, no approximation scheme has been proposed that can provably
maintain the same O(log T ) regret as exact GD. In addition, approximating Ht is harder for KOCO, since we cannot directly access the matrix representation of Ht in the

feature-space, making diagonal approximation impossible,
and low-rank sketching harder.
Contributions In this paper, we introduce Kernel-ONS, an
extension to KOCO of the ONS algorithm. As a secondorder method, KONS achieves a O(dteff log T ) regret on
a variety of curved losses, and runs in O(t2 ) time and
space. To alleviate the computational complexity, we propose S KETCHED -KONS, the first approximate secondorder KOCO methods, that approximates the kernel matrix
with a low-rank sketch. To compute this sketch we propose a new online kernel dictionary learning, kernel online
row sampling, based on ridge leverage scores. By adaptively increasing the size of its sketch, S KETCHED -KONS
provides a favorable regret-performance trade-off, where
for a given factor γ ≤ 1, we can increase the regret by
a linear 1/γ factor to O(dteff log(T )/γ) while obtaining a
quadratic γ 2 improvement in runtime, thereby achieving
O(t2 γ 2 ) space and time cost per iteration.

2. Background
In this section, we introduce linear algebra and RKHS
notation, and formally state the OCO problem in an
RKHS (Schölkopf & Smola, 2001).
Notation. We use upper-case bold letters A for matrices,
lower-case bold letters a for vectors, lower-case letters a
for scalars. We denote by [A]ij and [a]i the (i, j) element
of a matrix and i-th element of a vector respectively. We
denote by IT ∈ RT ×T , the identity matrix of dimension T
and by Diag(a) ∈ RT ×T , the diagonal matrix with the vector a ∈ RT on the diagonal. We use eT,i ∈ RT to denote
the indicator vector of dimension T for element i. When
the dimension of I and ei is clear from the context, we omit
the T . We also indicate with I the identity operator. We use
A  B to indicate that A − B is a positive semi-definite
(PSD) matrix. With k · k we indicate the operator `2 -norm.
Finally, the set of integers between 1 and T is denoted by
[T ] := {1, . . . , T }.
Kernels. Given an arbitrary input space X and a positive
definite kernel function K : X ×X → R, we indicate the reproducing kernel Hilbert space (RKHS) associated with K
as H. We choose to represent our Hilbert space H as a feature space where, given K, we can find an associated feature map ϕ : X → H, such that K(x, x0 ) can be expressed
as an inner product K(x, x0 ) = hϕ(x), ϕ(x0 )iH . With a
slight abuse of notation, we represent our feature space
as an high-dimensional vector space, or in other words
H ⊆ RD , where D is very large or potentially infinite.
With this notation, we can write the inner product simply as
K(x, x0 ) = ϕ(x)T ϕ(x0 ), and for any function fw ∈ H, we
can represent it as a (potentially infinite) set of weights w
such that fw (x) = ϕ(x)T w. Given points {xi }ti=1 , we

Second-Order Kernel Online Convex Optimization with Adaptive Sketching

shorten ϕ(xi ) = φi and define the feature matrix Φt =
[φ1 , . . . , φt ] ∈ RD×t . Finally, to denote the inner product
between two arbitrary subsets a and b of columns of ΦT
we use Ka,b = ΦTa Φb . With this notation, we can write
the empirical kernel matrix as Kt = K[t],[t] = ΦTt Φt , the
vector with all the similarities between a new point and the
old ones as k[t−1],t = ΦTt−1 φt , and the kernel evaluated at
a specific point as kt,t = φTt φt . Throughout the rest of the
paper, we assume that K is normalized and φTt φt = 1.
Kernelized online convex optimization. In the general
OCO framework with linear prediction, the optimization
process is a game where at each time step t ∈ [T ] the player
1 receives an input xt ∈ X from the adversary,
2 predicts ybt = fwt (xt ) = ϕ(xt )T wt = φTt wt ,
3 incurs loss `t (b
yt ), with `t a convex and differentiable
function chosen by the adversary,
yt ).
4 observes the derivative ġt = `0t (b
T

Since the player uses a linear combination φt wt to compute ybt , having observed ġt , we can compute the gradient,

Algorithm 1 One-shot KONS
Input: Feasible parameter C, stepsizes ηt , regulariz. α
1: Initialize w0 = 0, g0 = 0, b0 = 0, A0 = αI
2: for t = {1, . . . , T } do
3:
receive xt
4:
compute bs as in Lem.P2
t−1
5:
compute ut = A−1
t−1 (
s=0 bs gs )
T
6:
compute y t = ϕ(xt ) ut
7:
predict ybt = ϕ(xt )T wt = y t − h(y t )
8:
observe gt , update At = At−1 + ηt gt gtT
9: end for
Assumption 1. The loss function `t satisfies |`0t (y)| ≤ L
whenever y ≤ C.
Note that this is equivalent to assuming Lipschitzness of the
the loss w.r.t. y and it is weaker than assuming something
on the norm of the gradient kgt k, since kgt k = |ġt |kφt k.
Assumption 2. There exists σt ≥ 0 such that for all
u, w ∈ S , lt (w) = `t (φTt w) is lower-bounded by
lt (w) ≥ lt (u) + ∇lt (u)T (w−u) +

T

gt = ∇`t (b
yt ) = ġt ∇(φt wt−1 ) = ġt φt .
After t timesteps, we indicate with Dt = {xi }ti=1 , the
dataset containing the points observed so far. In the
rest of the paper we consider the problem of kernelized
OCO (KOCO) where H is arbitrary and potentially nonparametric. We refer to the special parametric case H =
Rd and φt = xt as linear OCO (LOCO).
In OCO, the goal is to design an algorithm that returns a solution that performs almost as well as the best-in-class, thus
we must first define our comparison class. We define the
feasible set as St = {w : |φTt w| ≤ C} and S = ∩Tt=1 St .
This comparison class contains all functions fw whose output is contained (clipped) in the interval [−C, C] on all
points x1 , . . . , xT . Unlike the often used constraint on
kwkH (Hazan et al., 2006; Zhu & Xu, 2015), comparing
against clipped functions (Luo et al., 2016; Gammerman
et al., 2004; Zhdanov & Kalnishkan, 2010) has a clear interpretation even when passing from Rd to H. Moreover, S is
invariant to linear transformations of H and suitable for
practical problems where it is often easier to choose a reasonable interval for the predictions ybt rather than a bound
on the norm of a (possibly non-interpretable) parametrization w. We can now define the regret as
RT (w) =

XT
t=1

`t (φTt wt ) − `t (φTt w)

and denote with RT = RT (w∗ ), the regret w.r.t. w∗ =
PT
arg minw∈S t=1 `t (φTt w), i.e., the best fixed function
in S. We work with the following assumptions on the
losses.

σt
(∇lt (u)T (w−u))2 .
2

This condition is weaker than strong convexity and it is satisfied by all exp-concave losses (Hazan et al., 2006). For
example, the squared loss lt (w) = (yt − xTt w)2 is not
strongly convex but satisfies Asm. 2 with σt = 1/(8C 2 )
when w ∈ S.

3. Kernelized Online Newton Step
The online Newton step algorithm, originally introduced
by Hazan et al. (2006), is a projected gradient descent that
uses the following update rules
ut = wt−1 − A−1
t−1 gt−1 ,
A

wt = ΠStt−1 (ut ),
A

where ΠStt−1 (ut ) = arg minw∈St kut − wkAt−1 is an
oblique projection on a set St with matrix At−1 . If St is
the set of vectors with bounded prediction in [−C, C] as
by Luo et al. (2016), then the projection reduces to
A

wt = ΠStt−1 (ut ) = ut −

h(φTt ut ) −1
At−1 φt ,
φTt A−1
t−1 φt

(1)

where h(z) = sign(z) max{|z| − C, 0} computes how
much z is above or below the interval [−C, C]. When
At = I/ηt , ONS is equivalent to vanilla projected
gra√
dient descent, which in LOCO achieves O( dT ) regret
(Zinkevich, 2003). In the sameP
setting, Hazan et al. (2006)
t
T
shows that choosing At =
s=1 ηs gs gs + αI makes
ONS an efficient reformulation of follow the approximate

Second-Order Kernel Online Convex Optimization with Adaptive Sketching

leader (FTAL). While traditional follow-the-leader
Pt−1 algorithms play the weight wt = arg minw∈St s=1 lt (w),
FTAL replaces the loss lt with a convex approximation using Asm. 2, and plays the minimizer of the surrogate function. As a result, under Asm. 1-2 and when σt ≥ σ > 0,
FTAL achieves a logarithmic O(d log T ) regret. FTAL’s
solution path can be computed in O(d2 ) time using ONS
updates, and further speedups were proposed by Luo et al.
(2016) using matrix sketching.
Unfortunately, in KOCO, vectors φt and weights wt cannot be explicitly represented, and most of the quantities
used in vanilla ONS (Eq. 1) cannot be directly computed.
Instead, we derive a closed form alternative (Alg. 1) that
can be computed in practice. Using a rescaled variant
√
√
of our feature vectors φt , φt = ġt ηt φt = ηt gt
T
and Φt = [φ1 , . . . , φt ], we can rewrite At = Φt Φt +
T
αI and Φt Φt = Kt , where the empirical kernel matrix Kt is computed using the rescaled kernel K(xi , xj ) =
√
√
ġi ηi ġj ηj K(xi , xj ) instead of the original K, or equiv√
alently Kt = Dt Kt Dt with Dt = Diag({ġi ηi }ti=1 ) the
rescaling diagonal matrix. We begin by noting that
!
h(φTt ut ) −1
T
T
ybt = φt wt = φt ut − T −1
At−1 φt
φt At−1 φt
= φTt ut − h(φTt ut )

φTt A−1
t−1 φt
φTt A−1
t−1 φt

= y t − h(y t ).

As a consequence, if we can find a way to compute y t , then
we can obtain ybt without explicitly computing wt . Before
that, we first derive a non-recursive formulation of ut .
Lemma 1. In Alg. 1 we introduce
√
bi = [bt ]i = ġi ηi

ybi −

h(y i )
T

φi A−1
i−1 φi

!

Then, we can compute
yt =

1 T
Dt−1 (bt−1 − (Kt−1 + αI)−1 Kt−1 bt−1 ).
k
α [t−1],t

Since Alg. 1 is equivalent to ONS (Eq. 1), existing regret
bounds for ONS directly applies to its kernelized version.
Proposition 1 (Luo et al., 2016). For any sequence of
losses `t satisfying Asm. 1-2, the regret RT of Alg. 1 is
bounded by RT ≤ αkw∗ k2 + RG + RD with
RG :=

T
X

gtT A−1
t gt =

t=1

RD :=

T
X

T
X

T

T

φt (Φt Φt + αI)−1 φt /ηt

t=1

(wt − w∗ )T (At − At−1 −σt gt gtT )(wt − w∗ )

t=1

=

T
X
(ηt − σt )ġt2 (φTt (wt − w∗ ))2 .
t=1

In the d-dimensional
LOCO, choosing a decreasing stepp
d/(C 2 L2 t) allows ONS to achieve a
size η√
=
t
O(CL dT ) regret for the cases where σt = 0. When
σt ≥ σ > 0 (e.g., when the functions are exp-concave) we
can set ηt = σt and improve the regret to O(d log(T )). Unfortunately, these quantities hold little meaning
for KOCO
√
with D-dimensional features, since a O( D) regret can be
very large or even infinite. On the other hand, we expect
the regret of KONS to depend on quantities that are more
strictly related to the kernel Kt and its complexity.
Definition 1. Given a kernel function K, a set of points
Dt = {xi }ti=1 and a parameter α > 0, we define the αridge leverage scores (RLS) of point i as
τt,i = eTt,i KTt (Kt +αI)–1 et,i = φTi (Φt ΦTt +αI)–1 φi , (2)

1
−√
ηi

and compute ut as
ut = A−1
t−1 Φt−1 bt−1 .
Then, ut is equal to the same quantity in Eq. 1 and the sequence of predictions ybt is the same in both algorithms.
While the definition of bt and ut still requires performing operations in the (possibly infinitely dimensional) feature space, in the following we show that bt and the prediction y t can be conveniently computed using only inner
products.
Lemma 2. All the components bi = [bt ]i of the vector
introduced in Lem. 1 can be computed as


αh(y i )
1
√
ġi ηi ybi −
−
.
T
ηi
ki,i − k[i−1],i (Ki−1 + αI)−1 k[i−1],i

and the effective dimension of Dt as
dteff (α) =

t
X


τt,i = Tr Kt (Kt + αIt )−1 .

(3)

i=1

In general, leverage scores have been used to measure
the correlation between a point i w.r.t. the other t − 1
points, and therefore how essential it is in characterizing the dataset (Alaoui & Mahoney, 2015). As an example, if φi is completely orthogonal to the other points,
τt,i = φTi (φi φTi + αI)−1 φi ≤ 1/(1 + α) and its RLS is
maximized, while in the case where all the points xi are
identical, τt,i = φTi (tφi φTi + αI)−1 φi ≤ 1/(t + α) and its
RLS is minimal. While the previous definition is provided
for a generic kernel function K, we can easily instantiate it
on K and obtain the definition of τ t,i . By recalling the first
regret term in the decomposition of Prop. 1, we notice that
RG =

T
X
t=1

T

T

φt (Φt Φt + αI)−1 φt /ηt =

T
X
t=1

τ t,t /ηt ,

Second-Order Kernel Online Convex Optimization with Adaptive Sketching

which reveals a deep connection between the regret of
KONS and the cumulative sum of the RLS. In other words,
the RLS capture how much the adversary can increase
the regret by picking orthogonal directions that have not
been seen before. While in LOCO, this can happen at
most d times (hence the dependency on d in the final regret,
which is mitigated by a suitable choice of ηt ), in KOCO,
RG can grow linearly with time, since large H can have
infinite near-orthogonal directions. Nonetheless, the actual
growth rate is now directly related to the complexity of the
sequence of points chosen by the adversary and the kernel
function K. While the effective dimension dteff (α) is related to the capacity of the RKHS H on the points in Dt
and it has been shown to characterize the generalization error in batch linear regression (Rudi et al., 2015), we see
that RG is rather related to the online effective dimension
P
t
donl (α) =
i τ i,i . Nonetheless, we show that the two
quantities are also strictly related to each other.
Lemma 3. For any dataset DT , any α > 0 we have
T

donl (α) :=

T
X
t=1

T

≤ deff (α)(1 + log(kKT k/α + 1)).
T

We first notice that in the first inequality we relate donl (α)
to the log-determinant of the kernel matrix KT . This quantity appears in a large number of works on online linear
prediction (Cesa-Bianchi et al., 2005; Srinivas et al., 2010)
where they were connected to the maximal mutual information gain in Gaussian processes. Finally, the second
inequality shows that in general the complexity of online
learning is only a factor log T (in the worst case) away
from the complexity of batch learning. At this point, we
can generalize the regret bounds of LOCO to KOCO.
Theorem 1. For any sequence of losses `t satisfying
Asm.√
1-2, let σ = mint σt . If ηt ≥ σ ≥ 0 for all t and
α ≤ T , the regret of Alg. 1 is upper-bounded as
T
X

for KT and that it is smaller than the rank r for any α.2 For
exp-concave functions (i.e., σ > 0), we slightly improve
over the bound of Luo et al. (2016) from O(d log T ) down
to O(dTeff (α) log T ) ≤ O(r log T ), where r is the (unknown) rank
p of the dataset. Furthermore, when
√ σ = 0, setting√ηt = 1/(L2 C 2 t) gives us a regret O( T dTeff (α))
√ ≤
O( T r), which is potentially much smaller than O( T d).
Furthermore, if an oracle
q provided us in advance with

dTeff (α), setting ηt =
dTeff (α)/(L2 C 2 t) gives a regret
q
√
O( dTeff (α)T ) ≤ O( rT ).

τ t,t ≤ log(Det(KT /α + I))

RT ≤ αkw∗ k2 + dTonl (α)/ηT + 4C 2 L2

Algorithm 2 Kernel Online Row Sampling (KORS)
Input: Regularization α, accuracy ε, budget β
1: Initialize I0 = ∅
2: for t = {0, . . . , T − 1} do
3:
receive φt
4:
construct temporary dictionary I t := It−1 ∪ (t, 1)
5:
compute pet = min{βe
τt,t , 1} using I t and Eq. 4
6:
draw zt ∼ B(e
pt ) and if zt = 1, add (t, 1/e
pt ) to It
7: end for

(ηt − σ).

t=1

In particular, if for all t we have σt ≥ σ > 0, setting
ηt = σ we obtain
 log(2σL2 T )
,
RT ≤ αkw∗ k2 + 2dTeff α/(σL2 )
σ
√
otherwise, σ = 0 and setting ηt = 1/(LC t) we obtain
√
RT ≤ αkw∗ k2 + 4LC T dTeff (α/L2 ) log(2L2 T ).
Comparison to LOCO algorithms. We first notice that
the effective dimension dTeff (α) can be seen as a soft rank

Comparison to KOCO algorithms. Simple functional
gradient descent
√ (e.g., NORMA, Kivinen et al., 2004)
achieves a O( T ) regret when properly tuned (Zhu &
Xu, 2015), regardless of the loss function. For the special case of squared loss, Zhdanov & Kalnishkan (2010)
show that Kernel Ridge Regression achieves the same
O(log(Det(KT /α + I))) regret as achieved by KONS for
general exp-concave losses.

4. Kernel Online Row Sampling
Although KONS achieves a low regret, storing and inverting the K matrix requires O(t2 ) space and O(t3 ) time,
which becomes quickly unfeasible as t grows. To improve
space and time efficiency, we replace Kt with an accurate
e t , constructed using a carefully
low-rank approximation K
chosen dictionary It of points from Dt . We extend the online row sampling (ORS) algorithm of Cohen et al. (2016)
to the kernel setting and obtain Kernel-ORS (Alg. 2). There
are two main obstacles to overcome in the adaptation of
ORS: From an algorithmic perspective we need to find a
computable estimator for the RLS, since φt cannot be accessed directly, while from an analysis perspective we must
prove that our space and time complexity does not scale
with the dimension of φt (as Cohen et al. 2016), as it can
potentially be infinite.
We define a dictionary It as a collection of (index, weight)
tuples (i, 1/e
pi ) and the associated selection matrix St ∈
This can be easily seen as dTeff (α) =
λt are the eigenvalues of KT .
2

P

t

λt /(λt + α), where

Second-Order Kernel Online Convex Optimization with Adaptive Sketching

p
Rt×t as a diagonal matrix with 1/ pei for all i ∈ It and 0
T
elsewhere. We also introduce AIt t = Φt St STt Φt +αI as an
approximation of At constructed using the dictionary It .
At each time step, KORS temporarily adds t with weight 1
to the dictionary It−1 and constructs the temporary dictionary It,∗ and the corresponding selection matrix St,∗ and
I
approximation At t,∗ . This augmented dictionary can be
effectively used to compute the RLS estimator,
I

τet,i = (1 + ε)φt At t,∗
=

1+ε
α

T

−1

φt

T

k t,t − k[t],t St,∗ (St,∗ Kt St,∗ +

αI)−1 STt,∗ k[t],t

(4)

.

While we introduced a similar estimator before (Calandriello et al., 2017), here we modified it so that τet,i is
an overestimate of the actual τ t,i . Note that all rows and
columns for which St,∗ is zero (all points outside the temporary dictionary It,∗ ) do not influence the estimator, so
they can be excluded from the computation. As a consequence, denoting by |It,∗ | the size of the dictionary, τet,i can
be efficiently computed in O(|It,∗ |2 ) space and O(|It,∗ |2 )
time (using an incremental update of Eq. 4). After computing the RLS, KORS randomly chooses whether to include
a point in the dictionary using a coin-flip with probability
pet = min{βe
τt,t , 1} and weight 1/e
pt , where β is a parameter. The following theorem gives us at each step guarantees
on the accuracy of the approximate matrices AIt t and of
estimates τet,t , as well as on the size |It | of the dictionary.
Theorem 2. Given parameters 0 < ε ≤ 1, 0 < α,
1+ε
and run Algorithm 2 with
0 < δ < 1, let ρ = 1−ε
2
β ≥ 3 log(T /δ)/ε . Then w.p. 1 − δ, for all steps t ∈ [T ],
(1) (1 − ε)At  AIt t  (1 + ε)At .
Pt
(2) The dictionary’s size |It | = s=1 zs is bounded by
t
X
s=1

zs ≤ 3

t
X

2

pes ≤ dtonl (α)

s=1

6ρ log
3ρβ
≤ dteff (α)
2
ε
ε2

2T
δ

Moreover, the algorithm runs in
e t (α)2 ) time per iteration.
space, and O(d
eff

performance and regret. Alg. 3 runs KORS as a black-box
estimating RLS τet , that are then used
to sketch the original
e t = Pt ηt zt gt gT , where at
matrix At with a matrix A
t
s=1
each step we add the current gradient gt gtT only if the coin
et
flip zt succeeded. Unlike KORS, the elements added to A
are not weighted, and the probabilities pet used for the coins
zt are chosen as the maximum between τet,t , and a parameter 0 ≤ γ ≤ 1. Let Rt be the unweighted counterpart of
St , that is [Rt ]i,j = 0 if [St ]i,j = 0 and [Rt ]i,j = 1 if
[St ]i,j 6= 0. Then we can efficiently compute the coefficients ebt and predictions yet as follows.
Lemma 4. Let Et = RTt Kt Rt +αI be an auxiliary matrix,
e t ]i used in Alg. 3 can be
then all the components ebi = [b
computed as


1
αh(y̆i )
√
ġi ηi yei −
−
.
T
ηi
ki,i − k[i−1],i Ri−1 E−1
i−1 Ri−1 k[i−1],i
Then we can compute


.

(3) Satisfies τt,t ≤ τet,t ≤ ρτt,t .
O(dteff (α)2

Algorithm 3 S KETCHED -KONS
Input: Feasible parameter C, stepsizes ηt , regulariz. α
e 0 = αI
1: Initialize w0 = 0, g0 = 0, b0 = 0, A
2: Initialize independent run of KORS
3: for t = {1, . . . , T } do
4:
receive xt
e −1 (Pt−1 ebs gs )
et = A
5:
compute u
t−1
s=0
et
6:
compute y̆t = ϕ(xt )T u
e t = y̆t − h(y̆t ), observe gt
7:
predict yet = ϕ(xt )T w
8:
compute τet,t using KORS (Eq. 4)
9:
compute pet = max{min{βe
τt,t , 1}, γ}
10:
draw zt ∼ B(e
pt )
et = A
e t−1 + ηt zt gt gT
11:
update A
t
12: end for

4

log (T ))

The most interesting aspect of this result is that the dictionary It generated by KORS allows to accurately approxT
imate the At = Φt Φt + αI matrix up to a small (1 ± ε)
multiplicative factor with a small time and space complexity, which makes it a natural candidate to sketch KONS.

5. Sketched ONS
Building on KORS, we now introduce a sketched variant of
KONS that can efficiently trade off between computational

y̆t =

1 T
k
Dt−1 bt−1
α [t−1],t

− kT[t−1],t Dt−1 Rt−1 E−1
t−1 Rt−1 Kt−1 bt−1 .

Note that since the columns in Rt are selected without
weights, (RTt Kt Rt + αI)−1 can be updated efficiently
e t changes.
using block inverse updates, and only when A
While the specific reason for choosing the unweighted
e t instead of the weighted version AIt used in
sketch A
t
KORS is discussed further in Sect. 6, the following corole t is as accurate as AIt in approximating
lary shows that A
t
At up to the smallest sampling probability peγt .
Corollary 1. Let peγmin = minTt=1 peγt . Then w.h.p., we have
e t.
(1 − ε)e
pmin At  pemin AIt t  A
We can now state the main result of this section. Since
for S KETCHED -KONS we are interested not only in regret

Second-Order Kernel Online Convex Optimization with Adaptive Sketching

minimization, but also in space and time complexity, we
do not consider the case σ = 0, because when the function
does not have any curvature,
√ standard GD already achieves
the optimal regret of O( T ) (Zhu & Xu, 2015) while requiring only O(t) space and time per iteration.
Theorem 3. For any sequence of losses `t satisfying
T
Asm. 1-2, let σ = mint σt and
√ τ min = mint=1 τ t,t 2. When
ηt ≥ σ > 0 for all t, α ≤ T , β ≥ 3 log(T /δ)/ε , if we
set ηt = σ then w.p. 1 − δ the regret of Alg. 3 satisfies

dTeff α/(σL2 ) log(2σL2 T )
∗ 2
e
, (5)
RT ≤ αkw k + 2
σ max{γ, βτ min }
and the algorithm runs in O(dteff (α)2 + t2 γ 2 ) time and
O(dteff (α)2 + t2 γ 2 ) space complexity for each iteration t.
Proof sketch: Given these guarantees, we need to bound
RG and RD . Bounding RD is straightforward, since
by construction S KETCHED -KONS adds at most ηt gt gtT
e t at each step. To bound RG instead, we must take
to A
e t = Φt Rt RT ΦT + αI
into account that an unweighted A
t t
T
can be up to pemin distant from the weighted Φt St STt Φt
for which we have guarantees. Hence the max{γ, βτ min }
term appearing at the denominator.

6. Discussion
Regret guarantees. From Eq. 5 we can see that when τ min
is not too small, setting γ = 0 we recover the guarantees of
exact KONS. Since usually we do not know τ min , we can
choose to set γ > 0, and as long as γ ≥ 1/ polylog T , we
preserve a (poly)-logarithmic regret.
Computational speedup. The time required to compute
k[t−1],t , kt,t , and kT[t−1],t Dt−1 bt−1 gives a minimum O(t)
per-step complexity. Note that Kt−1 bt−1 can also be computed incrementally in O(t) time. Denoting the size of the
e eff (α)t + tγ), computing
dictionary at time t as Bt = O(d
−1
e t ]i and kT
[b
D
R
E
[t−1],t t−1 t−1 t−1 Rt−1 Kt−1 bt−1 requires
an additional O(Bt2 ) time. When γ ≤ dteff (α)/t, each iteration takes O(dteff (α)2 ) to compute τet,t incrementally using
e −1 and O(dt (α)2 )
KORS, O(dteff (α)2 ) time to update A
t
eff
time to compute [bt ]t . When γ > dteff (α)/t, each iteration still takes O(dteff (α)2 ) to compute τet,t using KORS
and O(t2 γ 2 ) time to update the inverse and compute [bt ]t .
Therefore, in the case when τ min is not too small, our runtime is of the order O(dteff (α)2 + t), which is almost as
small as the O(t) runtime of GD but with the advantage
of a second-order method logarithmic regret. Moreover,
when τ min is small and we set a large γ, we can trade off a
1/γ increase in regret for a γ 2 decrease in space and time
complexity when compared to exact KONS (e.g., setting
γ = 1/10 would correspond to a tenfold increase in regret,
but a hundred-fold reduction in computational complexity).

Asymptotic behavior. Notice however, that space and time
complexity, grow roughly with a term Ω(t mints=1 pes ) ∼
Ω(t max{γ, βτ min }), so if this quantity does not decrease
over time, the computational cost of S KETCHED -KONS
will remain large and close to exact KONS. This is to be
expected, since S KETCHED -KONS must always keep an
accurate sketch in order to guarantee a logarithmic regret
bound. Note that Luo et al. (2016) took an opposite approach for LOCO, where they keep a fixed-size sketch but
possibly pay in regret, if this fixed size happens to be too
small. Since a non-logarithmic regret is achievable simply
running vanilla GD, we rather opted for an adaptive sketch
at the cost of space and time complexity. In batch optimization, where `t does not change over time, another possibility is to stop updating the solution once τ min becomes
too small. When Hs is the Hessian of ` in ws , then the
quantity gtT H−1
t gt , in the context of Newton’s method, is
called Newton decrement and it corresponds up to constant
factors to τ min . Since a stopping condition based on Newton’s decrement is directly related to the near-optimality of
the current wt (Nesterov & Nemirovskii, 1994), stopping
when τ min is small also provides guarantees about the quality of the solution.
Sampling distribution. Note that although γ > 0 means
that all columns have a small uniform chance of being see t , this is not equivalent to unilected for inclusion in A
formly sampling columns. It is rather a combination of a
RLS-based sampling to ensure that columns important to
reconstruct At are selected and a threshold on the probabilities to avoid too much variance in the estimator.
Biased estimator and results in expectation. The rane t is biased, since E[Φt Rt RT ΦT ] =
dom approximation A
t t
T
T
Φt Diag({τ t,t })Φt 6= Φt Φt . Another option would be
e0
to
Ptuse a weightedT and unbiased approximation At =
ps gs gs used in KORS and a common choice
s=1 ηs zs /e
in matrix approximation methods, see e.g., Alaoui & Mahoney, 2015. Due to its unbiasedness, this variant would
automatically achieve the same logarithmic regret as exact KONS in expectation (similar to the result obtained
by Luo et al., 2016, using Gaussian random projection in
LOCO). While any unbiased estimator, e.g., uniform sampling of gt , would achieve this result, RLS-based sampling
already provides strong reconstruction guarantees sufficient to bound RG . Nonetheless, the weights 1/e
ps may
e
cause large variations in At over consecutive steps, thus
leading to a large regret RD in high probability.
Limitations of dictionary learning approaches and open
problems. From the discussion above, it appears that
a weighted, unbiased dictionary may not achieve highprobability logarithmic guarantee because of the high variance coming from sampling. On the other hand, if we want
to recover the regret guarantee, we may have to pay for it

Second-Order Kernel Online Convex Optimization with Adaptive Sketching

with a large dictionary. This may actually be due to the
analysis, the algorithm, or the setting. An important property of the dictionary learning approach used in KORS is
that it can only add but not remove columns and potentially
re-weight them. Notice that in the batch setting (Alaoui &
Mahoney, 2015; Calandriello et al., 2017), the sampling of
columns does not cause any issue and we can have strong
learning guarantees in high probability with a small dictionary. Alternative sketching methods such as Frequent Directions (FD, Ghashami et al., 2016a) do create new atoms
as learning progresses. By restricting to composing dictionaries from existing columns, we only have the degree
of freedom of the weights of the columns. If we set the
weights to have an unbiased estimate, we achieve an accurate RG but suffer a huge regret in RD . On the other hand,
we can store the columns unweighted to have small RD but
large RG . This could be potentially fixed if we knew how
to remove less important columns from dictionary to gain
some slack in RD .
We illustrate this problem with following simple scenario.
The adversary always presents to the learner the same
point x (with associated φ), but for the loss it alternates
between `2t (wt ) = (C − φT wt )2 on even steps and
`2t+1 (wt ) = (−C − φT wt )2 on odd steps. Then, σt =
σ = 1/(8C 2 ), and we have a gradient that always points in
the same φ direction, but switches sign at each step. The
optimal solution in hindsight is asymptotically w = 0 and
let this be also our starting point w0 . We also set ηt = σ,
since this is what ONS would do, and α = 1 for simplicity.
For this scenario, we can compute several useful quantities
in closed form, in particular, RG and RD ,
RG ≤

T
X

T

X
ġt2
C2
≤ O(log T ),
≤
2
2
C σt + α
s=1 ġs σ + α
t=1

Pt
t=1

RD =

Xt
s=1

(ηt − σ)(wtT gt )2 = 0.

Note that although the matrix At is rank 1 at each time step,
vanilla ONS does not take advantage of this easy data, and
would store it all with a O(t2 ) space in KOCO.
As for the sketched versions of ONS, sketching using
FD (Luo et al., 2016) would adapt to this situation, and
only store a single copy of gt = g, achieving the desired regret with a much smaller space. Notice that in
this example, the losses `t are effectively strongly convex,
and even basic gradient descent with a stepsize ηt = 1/t
would achieve logarithmic regret (Zhu & Xu, 2015) with
even smaller space. On the other hand, we show how the
dictionary-based sketching has difficulties in minimizing
the regret bound from Prop. 1 in our simple scenario. In
particular, consider an arbitrary (possibly randomized) algorithm that is allowed only to reweight atoms in the dictionary and not to create new ones (as FD). In our example, this translates to choosing a schedule of weights ws

e t = Pt ws φ φ = Wt φφ with total weight
and set A
s s
PTs=1
W = WT = s=1 ws and space complexity equal to the
number of non-zero weights B = |{ws 6= 0}|. We can
show that there is no schedule for this specific class of algorithms with good performance due to the following three
conflicting goals.
Pt
(1) To mantain RG small, s=1 ws should be as large as
possible, as early as possible.
(2) To mantain RD small, we should choose weights
wt > 1 as few times as possible, since we accumulate max{wt − 1, 0} regret every time.
(3) To mantain the space complexity small, we should
choose only a few wt 6= 0.
To enforce goal (3), we must choose a schedule with no
more than B non-zero entries. Given the budget B, to satisfy goal (2) we should use all the B budget in order to
exploit as much as possible the max{wt − 1, 0} in RD , or
in other words we should use exactly B non-zero weights,
and none of these should be smaller P
than 1. Finally, to mint
imize RG we should raise the sum s=1 ws as quickly as
possible, settling on a schedule where w1 = W − B and
ws = 1 for all the other B weights. It easy to see that if we
want logarithmic RG , W needs to grow as T , but doing so
with a logarithmic B would make RD = T − B = Ω(T ).
Similarly, keeping W = B in order to reduce RD would
increase RG . In particular notice, that the issue does not
go away even if we know the RLS perfectly, because the
same reasoning applies. This simple example suggests that
dictionary-based sketching methods, which are very successful in batch scenarios, may actually fail in achieving
logarithmic regret in online optimization.
This argument raises the question on how to design alternative sketching methods for the second-order KOCO. A first
approach, discussed above, is to reduce the dictionary size
dropping columns that become less important later in the
process, without allowing the adversary to take advantage
of this forgetting factor. Another possibility is to deviate
from the ONS approach and RD + RG regret decomposition. Finally, as our counterexample in the simple scenario hints, creating new atoms (either through projection
or merging) allows for better adaptivity, as shown by FD
(Ghashami et al., 2016a) based methods in LOCO. However, the kernelization of FD does not appear to be straighforward. The most recent step in this direction (in particular, for kernel PCA) is only able to deal with finite feature
expansions (Ghashami et al., 2016b) and therefore its application to kernels is limited.
Acknowledgements The research presented was supported by
French Ministry of Higher Education and Research, NordPas-de-Calais Regional Council and French National Research
Agency projects ExTra-Learn (n.ANR-14-CE24-0010-01) and
BoB (n.ANR-16-CE23-0003)

Second-Order Kernel Online Convex Optimization with Adaptive Sketching

References
Alaoui, Ahmed El and Mahoney, Michael W. Fast randomized kernel methods with statistical guarantees. In
Neural Information Processing Systems, 2015.
Calandriello, Daniele, Lazaric, Alessandro, and Valko,
Michal. Distributed sequential sampling for kernel matrix approximation. In International Conference on Artificial Intelligence and Statistics, 2017.
Cavallanti, Giovanni, Cesa-Bianchi, Nicolo, and Gentile,
Claudio. Tracking the best hyperplane with a simple
budget perceptron. Machine Learning, 69(2-3):143–167,
2007.
Cesa-Bianchi, Nicolo, Conconi, Alex, and Gentile, Claudio. A second-order perceptron algorithm. SIAM Journal on Computing, 34(3):640–668, 2005.
Cohen, Michael B, Musco, Cameron, and Pachocki, Jakub.
Online row sampling. International Workshop on Approximation, Randomization, and Combinatorial Optimization, 2016.
Dekel, Ofer, Shalev-Shwartz, Shai, and Singer, Yoram. The
forgetron: A kernel-based perceptron on a budget. SIAM
Journal on Computing, 37(5):1342–1372, 2008.
Duchi, John, Hazan, Elad, and Singer, Yoram. Adaptive
subgradient methods for online learning and stochastic
optimization. Journal of Machine Learning Research,
12:2121–2159, 2011.
Gammerman, Alex, Kalnishkan, Yuri, and Vovk, Vladimir.
On-line prediction with kernels and the complexity approximation principle. In Uncertainty in Artificial Intelligence, 2004.
Ghashami, Mina, Liberty, Edo, Phillips, Jeff M, and
Woodruff, David P. Frequent directions: Simple and deterministic matrix sketching. SIAM Journal on Computing, 45(5):1762–1792, 2016a.
Ghashami, Mina, Perry, Daniel J, and Phillips, Jeff.
Streaming kernel principal component analysis. In International Conference on Artificial Intelligence and Statistics, 2016b.
Hazan, Elad, Kalai, Adam, Kale, Satyen, and Agarwal,
Amit. Logarithmic regret algorithms for online convex
optimization. In Conference on Learning Theory, 2006.

Le, Quoc, Sarlós, Tamás, and Smola, Alex J. Fastfood Approximating kernel expansions in loglinear time. In
International Conference on Machine Learning, 2013.
Le, Trung, Nguyen, Tu, Nguyen, Vu, and Phung, Dinh.
Dual Space Gradient Descent for Online Learning. In
Neural Information Processing Systems, 2016.
Lu, Jing, Hoi, Steven C.H., Wang, Jialei, Zhao, Peilin, and
Liu, Zhi-Yong. Large scale online kernel learning. Journal of Machine Learning Research, 17(47):1–43, 2016.
Luo, Haipeng, Agarwal, Alekh, Cesa-Bianchi, Nicolo, and
Langford, John. Efficient second-order online learning
via sketching. Neural Information Processing Systems,
2016.
Nesterov, Yurii and Nemirovskii, Arkadii. Interior-point
polynomial algorithms in convex programming. Society
for Industrial and Applied Mathematics, 1994.
Orabona, Francesco and Crammer, Koby. New adaptive algorithms for online classification. In Neural Information
Processing Systems, 2010.
Orabona, Francesco, Keshet, Joseph, and Caputo, Barbara.
The projectron: a bounded kernel-based perceptron. In
International Conference on Machine learning, 2008.
Rudi, Alessandro, Camoriano, Raffaello, and Rosasco,
Lorenzo. Less is more: Nyström computational regularization. In Neural Information Processing Systems,
2015.
Schölkopf, Bernhard and Smola, Alexander J. Learning
with kernels: Support vector machines, regularization,
optimization, and beyond. MIT Press, 2001.
Srinivas, Niranjan, Krause, Andreas, Seeger, Matthias, and
Kakade, Sham M. Gaussian process optimization in the
bandit setting: No regret and experimental design. In
International Conference on Machine Learning, 2010.
Tropp, Joel Aaron. Freedman’s inequality for matrix martingales. Electronic Communications in Probability, 16:
262–270, 2011.
Wang, Zhuang, Crammer, Koby, and Vucetic, Slobodan.
Breaking the curse of kernelization: Budgeted stochastic
gradient descent for large-scale svm training. Journal of
Machine Learning Research, 13(Oct):3103–3131, 2012.
Zhdanov, Fedor and Kalnishkan, Yuri. An identity for kernel ridge regression. In Algorithmic Learning Theory,
2010.

Kingma, Diederik and Ba, Jimmy. Adam: A method for
stochastic optimization. In International Conference on
Learning Representations, 2015.

Zhu, C. and Xu, H. Online gradient descent in function
space. ArXiv:1512.02394, 2015.

Kivinen, J., Smola, A.J., and Williamson, R.C. Online
Learning with Kernels. IEEE Transactions on Signal
Processing, 52(8), 2004.

Zinkevich, Martin. Online convex programming and generalized infinitesimal gradient ascent. In International
Conference on Machine Learning, 2003.

