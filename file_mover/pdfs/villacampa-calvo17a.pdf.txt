Scalable Multi-Class Gaussian Process Classification
using Expectation Propagation

Carlos Villacampa-Calvo * 1 Daniel HernaÌndez-Lobato * 1

Abstract
This paper describes an expectation propagation
(EP) method for multi-class classification with
Gaussian processes that scales well to very large
datasets. In such a method the estimate of the
log-marginal-likelihood involves a sum across
the data instances. This enables efficient training using stochastic gradients and mini-batches.
When this type of training is used, the computational cost does not depend on the number of
data instances N . Furthermore, extra assumptions in the approximate inference process make
the memory cost independent of N . The consequence is that the proposed EP method can be
used on datasets with millions of instances. We
compare empirically this method with alternative
approaches that approximate the required computations using variational inference. The results
show that it performs similar or even better than
these techniques, which sometimes give significantly worse predictive distributions in terms of
the test log-likelihood. Besides this, the training
process of the proposed approach also seems to
converge in a smaller number of iterations.

1. Introduction
Gaussian processes (GPs) are non-parametric models that
can be used to address multi-class classification problems
(Rasmussen & Williams, 2006). These models become
more expressive as the number of data instances N grows.
They are also very useful to introduce prior knowledge in
the learning problem, as many properties of the model are
specified by a covariance function. Moreover, GPs provide an estimate of the uncertainty in the predictions made
which may be critical in some applications. Neverthe*

Equal contribution 1 Universidad AutoÌnoma de Madrid,
Madrid, Spain. Correspondence to: Carlos Villacampa-Calvo
<carlos.villacampa@uam.es>.
Proceedings of the 34 th International Conference on Machine
Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017
by the author(s).

less, in spite of these advantages, GPs scale poorly to large
datasets because their training cost is O(N 3 ), where N is
the number of instances. An additional challenge is that
exact inference in these models is generally intractable and
one has to resort to approximate methods in practice.
Traditionally, GP classification has received more attention
in the binary case than in the multi-class setting (Kuss &
Rasmussen, 2005; Nickisch & Rasmussen, 2008). The reason is that approximate inference is more challenging in
the multi-class case where there is one latent function per
class. To this one has to add more complicated likelihood
factors, which often have the form of softmax functions or
intractable Gaussian integrals. In spite of these difficulties,
there have been several works addressing multi-class GP
classification (Williams & Barber, 1998; Kim & Ghahramani, 2006; Girolami & Rogers, 2006; Chai, 2012; RiihimaÌˆki et al., 2013). Nevertheless, most of the proposed
methods do not scale well with the size of the training set.
In the literature there have been some efforts to scale up
GPs. These techniques often introduce a set of M  N
inducing points whose location is learnt alongside with the
other model hyper-parameters. The use of inducing points
in the model can be understood as an approximate GP prior
with a low-rank covariance structure (QuinÌƒonero-Candela
& Rasmussen, 2005). When inducing points are considered, the training cost can be reduced to O(N M 2 ). This
allows to address datasets with several thousands of instances, but not millions. The reason is the difficulty of estimating the model hyper-parameters, which is often done
by maximizing an estimate of the log-marginal-likelihood.
Because such an estimate does not involve a sum across the
data instances, one cannot rely on efficient methods for optimization based on stochastic gradients and mini-batches.
A notable exception is the work of (Hensman et al., 2015a)
which uses variational inference to approximate the calculations. Such a method allows for stochastic optimization and can address datasets with millions of instances. In
this work we propose an alternative based on expectation
propagation (EP) (Minka, 2001) and recent advances on
binary GP classification (HernaÌndez-Lobato & HernaÌndezLobato, 2016). The proposed approach also allows for efficient training using mini-batches. This leads to a training

Scalable Multi-Class Gaussian Process Classification using Expectation Propagation

cost that is O(CM 3 ), where C is the number of classes.
An experimental comparison with the variational approach
and related methods from the literature shows that the proposed approach has benefits both in terms of the training
speed and the accuracy of the predictive distribution.

2. Scalable Multi-class Classification
Here we describe multi-class Gaussian process classification and the proposed method. Such a method uses the expectation propagation algorithm whose original description
is modified to be more efficient both in terms of memory
and computational costs. For this, we consider stochastic
gradients to update the hyper-parameters and an approximate likelihood that avoids one-dimensional quadratures.

and p(f |y) is intractable. Thus, these computations must
be approximated. Often, one computes a Gaussian approximation to p(f |y) (Kim & Ghahramani, 2006). This results
in a non-parametric classifier with training cost O(N 3 ),
where N is the number of data instances.
To reduce the computational cost of the method described
a typical approach is to consider a sparse representation
for each GP. With this goal, one can introduce C datasets
k
of M  N inducting points X = (x1 , . . . , xkM )T ,
k
with associated values f = (f k (xk1 ), . . . , f k (xkM ))T for
k = 1, . . . , C (Snelson & Ghahramani, 2006; Naishk
Guzman & Holden, 2008). Given each X the prior for
R
k
k
k
k
f k is approximated as p(f k ) = p(f k |f )p(f |X )df â‰ˆ
R QN
k
k
k
k
k
[ i=1 p(fik (xi )|f )]p(f |X )df = pFITC (f k |X ), in
k

2.1. Multi-class Gaussian Process Classification
We consider a dataset of N instances in the form of a matrix of attributes X = (x1 , . . . , xN )T with labels y =
(y1 , . . . , yN )T , where yi âˆˆ {1, . . . , C} and C > 2 is the
total number of different classes. The task of interest is to
predict the class label of a new data instance x? .
A typical approach in multi-class Gaussian process
(GP) classification is to assume the following labeling rule for yi given xi : yi = arg maxk f k (xi ),
for k = 1, . . . , C, where each f k (Â·) is a non-linear
latent function (Kim & Ghahramani, 2006). Define
f k = (f k (x1 ), . . . , f k (xN ))T âˆˆ RN and fi =
(f 1 (xi ), . . . , f C (xi ))T âˆˆ RC . The likelihood of f =
QN
(f 1 , . . . , f C )T âˆˆ RN Ã—C , p(y|f ) = i=1 p(yi |fi ), is then a
product of N factors of the form:
Y

p(yi |fi ) =
Î˜ f yi (xi ) âˆ’ f k (xi ) ,
(1)
k6=yi

where Î˜(Â·) is the Heaviside step function. This likelihood
takes value one if f can explain the observed data and zero
otherwise. Potential classification errors can be easily introduced in (1) by considering that each f k has been contaminated with Gaussian noise with variance Ïƒk2 . That is,
f k (xi ) = fË†k (xi ) + ki , where ki âˆ¼ N (0, Ïƒk2 ).
In multi-class GP classification a GP prior is assumed
for each function f k (Â·) (Rasmussen & Williams, 2006).
Namely, f k âˆ¼ GP(0, c(Â·, Â·; Î¾)), where c(Â·, Â·; Î¾ k ) is some
covariance function with hyper-parameters Î¾ k . Often these
priors are assumed to be independent. That is, p(f ) =
QC
k
k
k=1 p(f ), where each p(f ) is a multivariate Gaussian distribution. The task of interest is to make inference about f and for that Bayesâ€™ rule is used: p(f |y) =
p(y|f )p(f )/p(y), where p(y) is a normalization constant
(the marginal likelihood) which can be maximized to find
good hyper-parameters Î¾ k , for k = 1, . . . , C. However, because the likelihood in (1) is non-Gaussian, evaluating p(y)

which the conditional Gaussian distribution p(f k |f )
has been approximated by the factorizing distribution
QN
k
k
i=1 p(fi (xi )|f ). This approximation is known as the
full independent training conditional (FITC) (QuinÌƒoneroCandela & Rasmussen, 2005), and it leads to a Gausk
sian prior pFITC (f k |X ) with a low-rank covariance matrix.
This allows for approximate inference with cost O(N M 2 ).
k
The inducing points {X }C
k=1 can be regarded as hyperparameters and can be learnt by maximizing the estimate
of the marginal likelihood p(y).
2.2. Method Specification and Expectation Propagation
The formulation of the previous section is limited because
the estimate of the log-marginal-likelihood log p(y) cannot
be expressed as a sum across the data instances. This makes
infeasible the use of efficient methods based on stochastic
optimization for finding the model hyper-parameters.
A recent work focusing on the binary case has shown that it
is possible to obtain an estimate of log p(y) that involves a
k
sum across the data instances if the values f associated
to the inducing points are not marginalized (HernaÌndezLobato & HernaÌndez-Lobato, 2016). We follow that
work and consider the posterior approximation p(f |y) â‰ˆ
R
1
C
p(f |f )q(f )df , where f = (f , . . . , f )T , p(f |f ) =
QC
QC
k
k
k k
k=1 p(f |f ), we have defined p(f ) =
k=1 p(f |X ),
and q is a Gaussian approximation to p(f |y). This distribution q is obtained in three steps. First, we use on the exact
posterior the FITC approximation:
R
p(y|f )p(f |f )df p(f )
p(f |y) =
p(y)
R
p(y|f )pFITC (f |f )df p(f )
â‰ˆ
p(y)
QN
[ i=1 Ï†i (f )]p(f )
=
,
(2)
p(y)

Scalable Multi-Class Gaussian Process Classification using Expectation Propagation

QN QC
where we have defined pFITC (f |f ) = i=1 k=1 p(f k (xi )
QC
k
k
|f ) â‰ˆ p(f |f ) = k=1 p(f k |f ) and

R Q
Ï†i (f ) = [ k6=yi Î˜ f yi (xi ) âˆ’ f k (xi ) ]
QC
k
(3)
Ã— [ k=1 p(f k (xi )|f )]dfi ,
k

with p(f k (xi )|f ) = N (f k (xi )|mki , vik ), where
mki = (kk
ski =

k

âˆ’1 k
f ,
k)
X X
(kk k )T (Kk k k )âˆ’1 kk k
xi X
X X
xi X

)T (Kk k

xi X
k
Îºxi xi âˆ’

(4)
.

(5)

In the previous expressions N (Â·|Âµ, Ïƒ 2 ) is the p.d.f. of a
Gaussian with mean Âµ and variance Ïƒ 2 . Furthermore, kkx Xk
i

k

is a vector with the covariances between f k (xi ) and f ;
Kk k k is a M Ã— M matrix with the cross covariances beX X
k
tween f ; and, finally, Îºkxi xi is the prior variance of f k (xi ).
A practical difficulty is that the integral in (3) is intractable.
Although it can be evaluated using one-dimensional
quadrature techniques (HernaÌndez-Lobato et al., 2011), in
this paper we follow a different approach. For that, we note
that (3) is simply the probability that f yi (xi ) > f k (xi ) for
k 6= yi , given f . Let fiyi = f yi (xi ) and fik = f k (xi ). The
second step consists in approximating (3) as follows:
p(

T

k6=yi

f yi > f k ) =p(f yi > f 1 |S1 ) Ã— p(f yi > f 2 |S2 )Ã—

Â· Â· Â· Ã— p(f yi > f yi âˆ’1 |Syi âˆ’1 ) Ã— p(f yi > f yi +1 |Syi +1 )Ã—
Q
Q
Â· Â· Â· â‰ˆ k6=yi p(f yi > f k ) = k6=yi Î¦(Î±ik ) ,
(6)

where Sj =

T

kâˆˆ{1,...,j}âˆª{y
/
i}

f yi > f k , Î¦(Â·) is the c.d.f.
q

k
k
of a standard Gaussian and Î±ik = (myi
syi
i âˆ’ mi )/
i + si ,

myi
i ,

mki , syi i

with
and ski defined in (5). We have omitted in (6) the dependence on f to improve the readability.
The quality of this approximation is supported by the good
experimental results obtained in Section 4. When (6) is replaced in (2) we get an approximate posterior distribution
in which we can evaluate all the likelihood factors:
QN Q
[ i=1 k6=yk Ï†ki (f )]p(f )
p(f |y) â‰ˆ
,
(7)
p(y)
where we have defined Ï†ki (f ) = Î¦(Î±ik ).
The r.h.s. of (7) is intractable due to the non-Gaussian form
of the likelihood factors. The third and last step uses expectation propagation (EP) (Minka, 2001) to get a Gaussian
approximation q to (7). This approximation is obtained by
replacing each Ï†ki with an approximate Gaussian factor Ï†Ìƒki :
n
o
yi
yi
yi yi
i
Ï†Ìƒki (f ) = sÌƒi,k exp âˆ’ 12 (f )T VÌƒi,k
f + (f )T mÌƒyi,k
Ã—
n
o
k
k
k
exp âˆ’ 12 (f )T VÌƒi,k f + (f )T mÌƒi,k ,
(8)

2,yi yi
yi
1,yi yi
i
= Ci,k
Ï…i , VÌƒi,k =
where VÌƒi,k
= Ci,k
Ï…i (Ï…iyi )T , mÌƒyi,k
1
k
k T
2
k
Ci,k Ï…i (Ï…i ) , mÌƒi,k = Ci,k Ï…i , and we have defined Ï…ik =
1,yi
2,yi
k
âˆ’1
1
2
(kkx Xk )T (KX
. In (8) Ci,k
, Ci,k
, Ci,k
, Ci,k
and
k k)
X
i
sÌƒi,k are free parameters adjusted by EP. Because the precision matrices in (8) are one-rank (see the supplementary material for details), we only have to store in memory O(M ) parameters for each Ï†Ìƒki . The posterior approximation q is obtained by replacing in (7) each exact factor
Ï†i,k by the corresponding approximate factor Ï†Ìƒi,k . That is,
QN Q
q(f ) = i=1 k6=yi Ï†Ìƒki (f )p(f )/Zq , where Zq is a normalization constant that approximates the marginal likelihood
p(y). Because all the factors involved in the computation
of q are Gaussian, and we assume independence among the
latent functions of different classes in (8), q is a product of
C multivariate Gaussians (on per class) on M dimensions.

In EP each Ï†Ìƒki is updated until convergence as follows:
First, Ï†ki is removed from q by computing q \i,k âˆ q/Ï†Ìƒki .
Because the Gaussian family is closed under the product
and division operations, q \i,k is also Gaussian with parameters given by the equations in (Roweis, 1999). Then,
âˆ’1 k \i,k
the Kullback-Leibler divergence between Zi,k
Ï†i q
and
âˆ’1 k \i,k
q, i.e, KL[Zi,k Ï†i q |q], is minimized with respect to q,
where Zi,k is the normalization constant of Ï†ki q \i,k . This
âˆ’1 k \i,k
is done by matching the moments of Zi,k
Ï†i q . These
moments can be obtained from the derivatives of Zi,k with
respect to the parameters of q \i,k (Seeger, 2006). After updating q, the new approximate factor is Ï†Ìƒi,k = Zi,k q/q \i,k .
We update all the approximate factors at the same time, and
reconstruct q afterwards by computing the product of all the
Ï†Ìƒki and the prior, as in (HernaÌndez-Lobato et al., 2011).
The EP approximation to the marginal likelihood is the normalization constant of q, Zq . The log of its value is:
log Zq = g(Î¸) âˆ’ g(Î¸prior ) +

PN P
i=1

k6=yk

log sÌƒi,k , (9)

where log sÌƒi,k = log Zi,k + g(Î¸ \i,k ) âˆ’ g(Î¸); Î¸, Î¸ \i,k , and
Î¸prior are the natural parameters of q, q \i,k and the prior, respectively; and g(Î¸) is the log-normalizer of a multi-variate
Gaussian distribution with natural parameters Î¸.
It is possible to show that if EP converges, the gradient of
log Zq w.r.t the parameters of each Ï†Ìƒi,k is zero. Thus, the
gradient of log Zq w.r.t. a hyper-parameter Î¾jk of the k-th
covariance function (including the inducing points) is:
N
âˆ‚Î¸prior X X log Zi,k
âˆ‚ log Zq
T
= (Î· T âˆ’ Î·prior
)
+
,
k
k
âˆ‚Î¾j
âˆ‚Î¾j
âˆ‚Î¾jk
i=1 k6=y

(10)

i

where Î· and Î·prior are the expected sufficient statistics under q and the prior, respectively. Importantly, only the direct dependency of log Zi,k on Î¾jk has to be taken into account. See (Seeger, 2006). The dependency through Î¸ \i,k ,
i.e., the natural parameters of q \i,k can be ignored.

Scalable Multi-Class Gaussian Process Classification using Expectation Propagation

After obtaining q and finding the model hyper-parameters
by maximizing log Zq , one can get an approximate predictive distribution for the label y? of a new instance x? :
R
(11)
p(y? |x? , y) = p(y? |f? , f )q(f )df df? ,
where
we have defined f? = (f 1 (x? ), . . . , f C (x? ))T , and
R
p(y? |f? , f )df? has the same form as the likelihood factor
in (3). The resulting integral in (11) is again intractable.
However, it can be approximated using a one-dimensional
quadrature. See the supplementary material.
Because some simplifications occur when computing the
derivatives of log Zq w.r.t the inducing points, the total
training time of EP is O(N M 2 ) while the total memory
cost is O(N M C) (Snelson, 2007).
2.3. Scalable Expectation Propagation
Traditionally, for finding the model hyper-parameters with
EP one re-runs EP until convergence (using the previous
solution as the starting point), after each gradient ascent
update of the hyper-parameters. The reason for this is that
(10) is only true if EP has converged (i.e., the approximate
factors do not change any more). This approach is particularly inefficient initially, when there are strong changes to
the model hyper-parameters, and EP may require several
iterations to converge. Recently, a more efficient method
has been proposed in (HernaÌndez-Lobato & HernaÌndezLobato, 2016). In that work the authors suggest to update both the approximate factors and the model hyperparameters at the same time. Because we do not wait for
EP to converge, one should ideally add to (10) extra terms
to get the gradient. These terms account for the mismatch
âˆ’1 k \i,k
between the moments of Zi,k
Ï†i q
and q. However, according to (HernaÌndez-Lobato & HernaÌndez-Lobato, 2016)
these extra terms can be ignored and one can simply use
(10) for an inner update of the hyper-parameters.
-300

methods: (i) re-running EP until convergence each time and
using (10) to update the hyper-parameters (EP-outer); (ii)
updating at the same time the approximate factors Ï†Ìƒki and
the hyper-parameters with (10) (EP-inner-approx); and (iii)
the same approach as the previous one, but using the exact
gradient for the update instead of (10) (EP-inner-exact). All
approaches successfully maximize log Zq . However, the
inner updates are more efficient as they do not wait until
EP converges. Moreover, using the approximate gradient
is faster (it is cheaper to compute), and it gives almost the
same results as the exact gradient.
2.3.1. S TOCHASTIC E XPECTATION P ROPAGATION
The memory cost of EP can be significantly reduced by a
technique called stochastic EP (SEP) (Li et al., 2015). In
SEP all the approximate factors Ï†Ìƒki are tied. This means
that instead of storing their individual
what is
QN parameters,
Q
stored is their product, i.e., Ï†Ìƒ = i=1 k6=yk Ï†Ìƒki . A consequence of this is that we no longer have direct access to
their individual parameters. This only affects the computation of the cavity distribution q \i,k which now is obtained
1
in an approximate way q \i,k âˆ q/Ï†Ìƒ n , where n is the to1
tal number of factors and Ï†Ìƒ n approximates each individual
factor. Thus, SEP reduces the memory costs of EP by a factor of n. All the other steps are carried out as in the original
EP algorithm, including the computation of log Zq and its
gradients. Figure 2 shows the differences between EP and
SEP on a toy example. When SEP is used in the proposed
method, the memory cost is reduced to O(CM 2 ).
EP

SEP

Figure 2. (top) EP approximation of a distribution over the variable Î¸ with complicated likelihood factors, but tractable prior.
(bottom) SEP approximation of the same distribution.

2.3.2. T RAINING U SING M INI - BATCHES

-500

Both the estimate of the log-marginal-likelihood in (9)
and its gradient in (10) contain a sum across the data instances. This allows to write an EP algorithm that processes mini-batches of data, as in (HernaÌndez-Lobato &
HernaÌndez-Lobato, 2016). For this, the data are split in
mini-batches Mj of size S  N , where N is the number
of instances. Given a mini-batch Mj , we process all the
approximate factors corresponding to that mini-batch, i.e.,
{{Ï†Ìƒki }k6=yi : (xi , yi ) âˆˆ Mj }. Then, we update the model
hyper-parameters using a stochastic approximation of (10):

log Zq

-400

-600

-700

EP - Inner - Approx. Gradient
EP - Inner - Exact Gradient
EP - Outer Update

-800
0

500

1000

Training Time in Seconds

1500

2000

Figure 1. Estimate of p(y) on the Vehicle dataset as a function of
the training time for the proposed EP method when considering
three different schemes to update the model hyper-parameters.

Figure 1 shows, for the Vehicle dataset from UCI repository
(Lichman, 2013), the estimate of the marginal likelihood
log Zq with respect to the training time, for 250 updates of
the hyper-parameters, and M = N/5. We compare three

X X log Zi,k
âˆ‚Î¸prior
âˆ‚ log Zq
T
â‰ˆ (Î· T âˆ’ Î·prior
)
+Ï
, (12)
k
k
âˆ‚Î¾j
âˆ‚Î¾j
âˆ‚Î¾jk
iâˆˆM k6=y
j

i

where Ï = N/|Mj |. We reconstruct q after each update
of the approximate factors and each update of the hyper-

Scalable Multi-Class Gaussian Process Classification using Expectation Propagation

parameters. When using mini-batches of data, we update
more frequently q and the hyper-parameters. The consequence is that the training cost is O(CM 3 ), assuming a
constant number of updates until convergence. This training scheme can handle datasets with millions of instances.

3. Related Work
The likelihood used in (1) was first considered for multiclass Gaussian process classification in (Kim & Ghahramani, 2006). That work considers full non-parametric GP
priors, which lead to a training cost that is O(CN 3 ). The
consequence is that it can only address small classification problems. It is, however, straight forward to replace
the non-parametric GP priors with the FITC approximate
k
priors pFITC (f k |X ) (QuinÌƒonero-Candela & Rasmussen,
2005). These priors are obtained by marginalizing the lak
k
tent variables f associated to the inducing points X , as
indicated in Section 2.1. This allows to address datasets
with a few thousand instances. This is precisely the approach followed in (Naish-Guzman & Holden, 2008) to
address binary GP classification problems. We refer to
such an approach as the generalized FITC approximation (GFITC). Nevertheless, such an approach cannot use
stochastic optimization. The reason is that the estimate
of the log-marginal-likelihood (needed for hyper-parameter
estimation) does not contain a sum across the instances.
Thus, GFITC cannot scale well to very large datasets. Nevertheless, unlike the proposed approach, it can run expectation propagation over the exact likelihood factors in (1). In
GFITC we follow the traditional approach and run EP until
convergence before updating the hyper-parameters.
Multi-class GP classification for potentially huge datasets
has also been considered in (Hensman et al., 2015b) using
variational inference (VI). However, such an approach cannot use the likelihood in (1) since its logarithm is not well
defined (note that it takes value zero for some values of fi ).
As an alternative, Hensman et al. (2015b) have considered
the robust likelihood of (HernaÌndez-Lobato et al., 2011):
p(yi |fi ) = (1 âˆ’ )

Q

k6=yi


Î˜ f yi (xi ) âˆ’ f k (xi ) +


C

, (13)

where  is the probability of a labeling error (in that case,
yi is chosen at random from the potential class labels). In
(Hensman et al., 2015b) it is suggested to set  = 10âˆ’3 .
We now describe the VI approach in detail. Using (13)
Rand the definitions of Section 2, we know that p(y|f ) =
p(y|f )p(f |f )df . If we take the log and use Jensenâ€™s inequality we get the bound log p(y|f ) â‰¥ Ep(f |f ) [log p(y|f )].
Consider now a Gaussian approximation q to p(f |y). Then,
R
log p(y) = q(f )p(y|f )p(f )/q(f )df
â‰¥ Eq(f ) [log p(y|f )] âˆ’ KL[q(f )||p(f )] , (14)
where we have used Jensenâ€™s inequality and KL is the Kull-

back Leibler divergence. If we use the first bound we get
log p(y) â‰¥ Eq(f ) [Ep(f |f ) [log p(y|f )]]KL[q(f )||p(f )]
â‰¥ Eq(f ) [log p(y|f )] âˆ’ KL[q(f )||p(f )]
P
â‰¥ N
i=1 Eq(fi ) [log p(yi |fi )] âˆ’ KL[q(f )||p(f )] , (15)

R
where q(f ) =
p(f |f )q(f )df and the corresponding
marginal over fi = (f 1 (xi ), . . . , f C (xi ))T is q(fi ) =
QC
k
k k
k=1 N (f (xi )|mÌ‚i , sÌ‚i ). Note that q(fi ) is Gaussian because q(f ) involves a Gaussian convolution. As in the proposed approach, q(f ) is assumed to be a Gaussian factoriz1
C
ing over the latent functions f , . . . , f . However, its mean
k C
and covariance parameters, i.e., {mk }C
k=1 and {S }k=1 are
found by maximizing (15). The parameters of q(fi ) are:
mÌ‚ki = (kkx

k
iX

)T (KkXk Xk )âˆ’1 mk ,

sÌ‚ki = Îºkxi xi âˆ’ (kkx
+

k
iX

(16)

k
âˆ’1 k
)T (KX
kx
k k)
X

k
iX

(kkx Xk )T (KkXk Xk )âˆ’1 Sk (KkXk Xk )âˆ’1 kkx Xk
i
i

.

(17)

Hensman et al. (2015b) consider Markov chain Monte
Carlo (MCMC) to sample the hyper-parameters. Here we
simply maximize (15) to find the hyper-parameters and the
inducing points. The reason for this is that in very large
datasets MCMC is not expected to give much better results.
We refer to the described approach as VI. The objective in
(15) contains a sum across the data instances. Thus, VI
also allows for stochastic optimization and it results in the
same cost as the proposed approach. However, the expectations in (15) must be approximated using one-dimensional
quadratures. This is a drawback with respect to the proposed method which is free of any quadrature. Finally,
there are some methods related to the VI approach just described. Dezfouli & Bonilla (2015) assume that q can be
a mixture of Gaussians, and Chai (2012) uses a soft-max
likelihood (but does not consider stochastic optimization).
Both works need to introduce extra approximations.
In the literature there are other research works addressing multi-class Gaussian process classification. Some examples include (Williams & Barber, 1998; Girolami &
Rogers, 2006; HernaÌndez-Lobato et al., 2011; Henao &
Winther, 2012; RiihimaÌˆki et al., 2013). These works
employ expectation propagation, variational inference or
the Laplace approximation to approximate the computations. Nevertheless, the corresponding estimate of the logmarginal-likelihood cannot be expressed as a sum across
the data instances. This avoids using efficient techniques
for optimization based on stochastic gradients. Thus, one
cannot address very large datasets with these methods.

4. Experiments
We evaluate the performance of the method proposed in
Section 2.2. We consider two versions of it. A first

Scalable Multi-Class Gaussian Process Classification using Expectation Propagation

one, using expectation propagation (EP). A second, using the memory efficient stochastic EP (SEP). EP and SEP
are compared with the methods described in Section 3.
Namely, GFITC and VI. All methods are codified in the
R language (the source code is in the supplementary material), and they consider the same initial values for the model
hyper-parameters (including the inducing points, that are
chosen at random from the training instances). The hyperparameters are optimized by maximizing the estimate of
the marginal likelihood. A Gaussian covariance function
with automatic relevance determination, an amplitude parameter and an additive noise parameter is employed.

fastest method (between 2 and 3 times faster than GFITC).
VI is slower as a consequence of the quadratures required
by this method. VI also gives much worse results in some
datasets, e.g., Glass, Svmguide2 and Waveform. This is related to the optimization of Eq(fi ) [log p(yi |fi )] in (15), instead of log Eq(fi ) [p(yi |fi )], which is closer
P to the data loglikelihood. In the EP objective in (9), k6=yi log Zi,k is
probably more similar to log Eq(fi ) [p(yi |fi )]. This explains
the much better results obtained by EP and SEP.
Table 2. Average negative test log likelihood for each method and
average training time in seconds on UCI repository datasets.

Table 1. Characteristics of the datasets from the UCI Repository.
Dataset
#Instances #Attributes #Classes
Glass
214
9
6
New-thyroid
215
5
3
Satellite
6435
36
6
Svmguide2
391
20
3
Vehicle
846
18
4
Vowel
540
10
6
Waveform
1000
21
3
Wine
178
13
3

Table 2 shows, for each value of M , the average negative
test log-likelihood of each method with the corresponding error bars (test errors are shown in the supplementary material). The average training time of each method
is also displayed. The best method (the lower the better) for each dataset is highlighted in bold face. We observe that the proposed approach, EP, obtains very similar results to those of GFITC, and sometimes it obtains
the best results. The memory efficient version of EP, SEP,
seems to provide similar results without reducing the performance. Regarding the computational cost, SEP is the

M = 10%
M = 20%

We evaluate the performance of each method on 8 datasets
from the UCI repository (Lichman, 2013). The characteristics of the datasets are displayed in Table 4.1. We use batch
training in each method (i.e., we go through all the data to
compute the gradients). Batch training does not scale to
large datasets. However, it is preferred on small datasets
like the ones considered here. We use 90% of the data for
training and 10% for testing, expect for Satellite which is
fairly big, where we use 20% for training and 80% for testing. In Waveform, which is synthetic, we generate 1000
instances and split them in 30% for training and 70% for
testing. Finally, in Vowel we consider only the points that
belong to the 6 first classes. All methods are trained for
250 iterations using gradient ascent (GFITC and VI use lBFGS, EP and SEP use an adaptive learning rate described
in the supplementary material). We consider three values
for M , the number of inducing points. Namely 5%, 10%
and 20% of the number of training instances. We report
averages over 20 repetitions of the experiments.

M = 5%

4.1. Performance on Datasets from the UCI Repository

Problem
Glass
New-thyroid
Satellite
Svmguide2
Vehicle
Vowel
Waveform
Wine
Avg. Time
Glass
New-thyroid
Satellite
Svmguide2
Vehicle
Vowel
Waveform
Wine
Avg. Time
Glass
New-thyroid
Satellite
Svmguide2
Vehicle
Vowel
Waveform
Wine
Avg. Time

GFITC

0.61 Â± 0.05
0.06 Â± 0.01
0.33 Â± 0.00
0.63 Â± 0.06
0.32 Â± 0.01
0.16 Â± 0.01
0.42 Â± 0.01
0.08 Â± 0.02
131 Â± 3.11
0.58 Â± 0.05
0.07 Â± 0.01
0.34 Â± 0.00
0.67 Â± 0.05
0.33 Â± 0.01
0.14 Â± 0.01
0.42 Â± 0.01
0.07 Â± 0.01
264 Â± 6.91
0.6 Â± 0.07
0.07 Â± 0.01
0.34 Â± 0.01
0.67 Â± 0.05
0.33 Â± 0.01
0.12 Â± 0.01
0.43 Â± 0.01
0.07 Â± 0.01
683 Â± 17.3

EP
0.78 Â± 0.06
0.11 Â± 0.03
0.31 Â± 0.00
0.63 Â± 0.06
0.34 Â± 0.02
0.25 Â± 0.01
0.36 Â± 0.00
0.07 Â± 0.01
53.8 Â± 0.19
0.74 Â± 0.06
0.06 Â± 0.01
0.30 Â± 0.00
0.67 Â± 0.05
0.33 Â± 0.02
0.19 Â± 0.01
0.36 Â± 0.01
0.06 Â± 0.01
102 Â± 0.64
0.75 Â± 0.06
0.06 Â± 0.01
0.30 Â± 0.00
0.65 Â± 0.06
0.33 Â± 0.02
0.16 Â± 0.01
0.37 Â± 0.01
0.05 Â± 0.01
228 Â± 0.78

SEP
0.77 Â± 0.07
0.06 Â± 0.01
0.33 Â± 0.00
0.67 Â± 0.06
0.34 Â± 0.02
0.25 Â± 0.01
0.39 Â± 0.01
0.08 Â± 0.01
48.5 Â± 0.97
0.79 Â± 0.07
0.06 Â± 0.01
0.34 Â± 0.00
0.74 Â± 0.07
0.34 Â± 0.02
0.19 Â± 0.01
0.41 Â± 0.01
0.07 Â± 0.01
96.6 Â± 1.99
0.81 Â± 0.07
0.05 Â± 0.01
0.36 Â± 0.00
0.74 Â± 0.07
0.34 Â± 0.02
0.18 Â± 0.01
0.45 Â± 0.01
0.06 Â± 0.01
216 Â± 2.88

VI
2.45 Â± 0.14
0.09 Â± 0.02
0.61 Â± 0.01
1.03 Â± 0.08
0.76 Â± 0.05
0.41 Â± 0.05
0.89 Â± 0.02
0.08 Â± 0.02
157 Â± 0.59
2.18 Â± 0.14
0.05 Â± 0.01
0.58 Â± 0.01
0.90 Â± 0.10
0.72 Â± 0.04
0.30 Â± 0.04
0.85 Â± 0.01
0.07 Â± 0.01
179 Â± 0.78
2.30 Â± 0.15
0.05 Â± 0.01
0.53 Â± 0.01
0.94 Â± 0.08
0.63 Â± 0.04
0.15 Â± 0.03
0.80 Â± 0.01
0.06 Â± 0.02
248 Â± 0.66

4.2. Analysis of Inducing Point Learning
We generate a synthetic two dimensional problem with
three classes by sampling the latent functions from the
GP prior and applying the rule yi = arg maxk f k (xi ).
The distribution of xi is uniform in the box [âˆ’2.5, 2.5] Ã—
[âˆ’2.5, 2.5]. We consider 1000 training instances and a
growing number of inducing points, i.e., M = 1 to M =
256. The initial location of the inducing points is chosen at
random and it is the same for all the methods. We are interested in the location of the inducing points after training.
Thus, we set the other hyper-parameters to their true values
(specified before generating the data) and we keep them
fixed. All methods but VI are trained using batch methods
during 2000 iterations. VI is trained using stochastic gradients for 2000 epochs (the batch version often gets stuck
in local optima). We use ADAM with the default settings
(Kingma & Ba, 2015), and 100 as the mini-batch size.

Scalable Multi-Class Gaussian Process Classification using Expectation Propagation
M =1

M =2

M =4

M =8

â—
â—

â—

â—

â—

â—

â—

â—

GFITC

M = 16

â—
â—

â—

â—

â—
â—
â—

â—

â—
â—

â—

â—

â—

â—

â—

â—

â—

â—

â—

â—

â—

â—

â—

EP

â—

â—
â—

â—

â—

â—

â—
â—

â—

â—

â—

â—

â—

â—

â—

â—

â—

â—

â—

â—

â—
â—
â—

â—

â—

â—

â—

â—

SEP

â—

â—

â—

â—

â—
â—

â—

â—

â—

â—

â—
â—

â—

â—
â—

â—

â—

â—

â—â—

â—
â—

â—

â—â—

â—

VI

â—
â—

â—

â—

â—
â—
â—
â—
â—

â—

â—

â—â—
â—

â—
â—
â—

â—
â—â—
â—

â—

â—
â— â—

â—
â—

â—

â—

â—

â— â—
â—
â—

â—
â—

â— â—
â—

â—
â—

â—

â— â—
â—â—
â—
â—

â—

â—

â—

â— â—
â—

â—
â—

â—

â—
â—

â—

â—
â—
â—

â—
â—

â—
â—

â—

â—

â—
â—
â—
â—â— â— â—
â—â—â— â—
â—
â—
â—â—
â—
â—â—
â—â—

â—
â—â—

â—
â—

â—

â—

â—â—

â—
â—

â—

â—
â—

â—

â—â—
â—

â—

â—

â—
â—

â—

â—
â—

â—

â—
â—

â—
â—
â—
â—â—
â—
â—
â—â—
â—

â—

â—

â—

â—

â—

â—

â—
â—

â—â—
â—

â—
â—
â—

â—
â—

â—
â—
â—
â—â— â—â— â—
â—
â—
â—
â—
â—
â—
â—
â—
â— â—
â—
â—
â—
â—â—
â—

â—

â—

â—

â—
â—
â—
â— â—

â—
â—
â—

â—

â—
â—

â—
â—

â—
â—

â—

â—
â—

â—
â—
â—
â—
â—â—
â—
â—
â—
â—
â—
â—
â—
â—
â—
â—

â—

â—
â—

â—
â—

â—

â—

â—

â—

â—

â—
â—

â—â—
â—

â—

â—
â—
â—
â—
â—
â—â—
â—
â—
â—
â—
â—
â— â—â—â—â— â—
â—
â—
â—
â—â—
â—â— â—
â—â—â—
â—
â—
â—â—â—â—â—â—
â—
â—â—
â—
â—
â—â—
â—â—
â—
â—â— â—â—
â—
â—
â—â—
â—
â—
â—
â—
â—â—â— â—â—
â—
â—
â—
â—
â—
â—
â—
â—
â—â—
â— â—â—
â—
â—
â—â—
â—â—
â— â—
â—â— â—
â— â—
â—
â—â—
â—
â—â—
â—â—
â—
â—
â—
â—
â—
â—
â—
â—
â—
â—
â—
â—
â— â—â—
â—
â—â—
â—
â—
â—
â—
â—
â—
â—
â—
â—
â—
â—
â—
â—
â—
â—
â—
â—
â—
â—

â—â—
â—

â—
â—
â—â— â—
â—
â—
â— â—
â— â—
â—
â—
â—
â—
â—
â—
â—
â—â—â—
â—
â—â—
â—
â—
â—
â—
â—
â—
â—
â—â—
â—
â—
â—
â—
â— â—
â—â—
â—
â—â—â—
â— â—
â—
â—
â—
â—
â— â—â—
â—â— â—
â—
â—
â—â—

â—â—
â—â—
â—
â—

â—
â—
â—â—
â— â—
â—
â—
â— â—
â—â—â— â—â—â—
â—
â—
â—â—
â—â— â—
â—
â— â— â—
â—
â—
â—
â—
â—â—
â—
â—
â—
â—
â— â—â—
â—
â— â— â— â—
â— â— â—â—
â—â— â— â—
â—
â— â—
â—
â—
â—
â—
â— â—â—
â—â— â— â—
â— â—â— â— â— â— â—
â—
â—
â— â—â—
â—
â—
â—
â—
â—
â—
â—
â—
â—
â— â—
â—
â—â—â—
â—
â— â—
â— â—â—
â—â—
â—â—
â— â— â—
â—
â— â—
â—
â—â— â—
â—â—
â—â— â—
â—
â—
â— â—â—
â—â—
â—â— â—
â—
â—
â—â—
â—â—
â—
â—
â—â—
â— â—â—
â—
â—
â—â—
â—
â—â—
â—â— â—
â—
â— â—â—
â—
â—
â—
â—
â—
â—
â—
â—
â—
â—â— â—â—â—
â—
â—â—
â—
â—
â—
â—
â—

â—

â—â—

â—

â—

â— â—
â—

â—
â—

â—
â—
â—
â—
â—
â—
â—â—â— â—
â—
â—â—â—
â—â—
â—
â—
â—
â—
â—â—
â—
â—
â—
â—
â—
â—
â—â— â—
â—â—â—â—
â—â—
â—
â—
â—â— â—â—â—
â— â—
â—
â—
â—
â—
â— â—â—
â—
â—
â—
â—â—
â—
â—
â— â—
â—
â—
â—
â—
â—
â—
â—
â—
â—â—
â—
â—
â—
â—â—
â—
â—
â—â—
â—
â—â—â— â—
â—
â—â—
â—

â—

â—
â—
â—
â—

â—

â—
â—

â—
â—
â—
â—

â—

â— â—

â—
â—â—â—
â—
â—
â—â—â—
â—â—
â—
â— â—â—
â—â—â—â—â—
â—
â—
â—
â—

â—

â—
â—

â—

â—

â—
â—
â—
â— â—
â—
â—â—â—
â—
â— â— â—
â— â—â—â—â—â—
â—
â—â—
â—â—â—
â—

â—â—
â—

â—

â—

â—

â—

â—

â—

â—
â—â—
â—
â—
â—
â—â— â—
â—
â—
â—
â—
â—
â—â—
â— â—
â—
â—
â— â—
â—â—
â—
â—
â—
â—
â—
â—
â—

â—
â—
â—
â—â—
â—

â—
â—

â—

â—â—
â—
â—
â—
â—

â—

â—

â—â—

â— â—
â—

â—
â—

â—

â—

â—â—

â—

â—
â—
â—
â—
â—
â—

â—

â—

â—

â—

â—

â—
â—
â—

â—
â—â—
â—

â—

â—
â—
â—

â— â—
â—
â—â—â— â—
â—
â— â—
â—
â—
â— â—â—
â— â—
â—
â—â—
â— â—â—
â—
â—
â—
â— â—â— â— â— â—
â—
â—
â— â—
â— â—

â—
â—

â—

â—
â—

â—

â—

â—

â—

â—
â—â—

â—

â—

â—

â—

â—
â—
â—
â—

â—

â—â—â—
â—

â—
â—
â— â—

â—
â—
â—

â—

â—
â—

â—

â—
â—â— â—
â—â—
â—
â—

â—

â—

â—

â—â—

â—

â—
â— â— â—

â—

â—

â—â—

â—

â—

â—

â—
â—
â—

â—

â—

â—

â—

â— â—
â—
â—â—
â—
â—â—
â—

â—
â—

â—

â—

â—

â—

â—
â—

â—

â—â—
â—

â— â—
â—
â—
â—

â—

â—

â—

â—

â—â—

â—

â—

â—

â—
â—

â—

â—

â—

â—

â—â—â—

â—

â—
â—

â—
â—

â—

â—

â—

â—â—

â—

â—

â—

â—
â—

â—

â—

â—
â—â—
â—

â—
â—

â—

â—

â—
â—
â—

â—
â—
â—â—
â—
â—
â—

â—

â—

â—

â—
â—
â—
â—
â—

â—

â—
â—

â—

â—
â—

â—
â—

â—

â—

â—

â—

â—

â—

â—

â—

â—

â—
â—

â—

â—

â— â—

â—
â—

â—
â—

â—
â—
â—
â— â—

â—
â—

â—
â—

â—

â—â—

â—
â—

â—

â— â—

â—
â—
â—

â—
â—

â—
â—

â—â—

â—
â—

â— â—

â—

â—

â— â—

â—

â—
â—

â—

â—â—
â—

â—

â—
â—

â—

â—
â—

â—
â—

â—
â—

â—

â—

â—
â—

â—

â—

â—

â—
â—
â—

â—
â—â—

â—

â—

â—

â—

â—
â—
â—
â—

â—
â—

â—
â—
â—

â—

â—

â—

â—

â—

â—

â—

â— â—
â—

â—

â—

â—

â—

â—â—
â—

â—

â—
â—
â—

â—
â—

â—

â—

â—

â—
â—

â—â—

â—
â—

â—

â—

â—

â—

â—

â—
â—

â—
â—

â—

â—â—

â—
â—

â—

â—

â—â—

â—

â—
â—

â—
â—

â—
â—

â—
â—â—

M = 256
â—

â—
â—

â—

â—

â—
â—

â—
â—

â—

â—

â—

â—

â—
â—

â—
â—

â—
â— â—

â—
â—

â—

â—

M = 128
â—

â—
â—

â—
â—

â—

â—

â—
â—

â—
â—â—

â—

â—â—
â—

â—
â—
â—

â—
â—
â—

â—

â— â— â—

â—

â—

â—
â—

â—

â—

â—

â—

â—
â—
â—

â—
â—

â—

â—
â—

â—â—

â—
â—

â—

â—

â—
â—
â—

â—

â—

â— â—

â— â—

â—

â—

â—

â—

â—

â—

â—

â—
â—
â—

â—
â—

â—

M = 64

â— â—

â—

â—

â—

â—â—

â—
â—

â—

â—

â—
â—

â—

â—â—
â—

â—

â—
â—

â—

â—

â—
â—
â—

M = 32

â— â—
â—

â—

â—

â—

â—â— â—
â—
â—â—
â—
â—
â—â—
â—
â—
â—
â—

â—
â— â—
â— â—
â—
â— â—
â—
â—
â—
â— â—
â—â—
â—â—â—
â—

â—

â—
â—

â— â—
â—
â—
â—â—
â—
â—
â—
â—â—
â—â—
â—
â—
â—
â—
â—
â—â— â—â— â—
â—
â—
â—

â—

â—

â—
â—
â— â—
â—â—
â—
â—
â—â—
â—
â—
â—â—â— â— â— â— â— â— â—â—
â—
â—â— â—
â— â—â—
â—â— â—â—â—
â—
â—
â—
â—
â—
â—
â—
â—
â—â—
â—
â—
â— â— â— â— â—â—â—
â—
â—
â—
â—
â—
â—
â— â—
â—
â— â—â—â—
â—
â—
â—â—â—
â—â—â—â—
â—â— â— â— â— â— â— â—
â—
â—
â—
â—
â—â—â—
â—
â—
â—â—â—
â— â—
â—â— â—
â— â—â—
â—â— â—
â— â—â—â—
â—
â—
â—â—â—
â—â—
â—â—
â—
â—
â—
â— â—â— â—
â— â—â—
â— â—â—
â—
â—
â—
â—â—
â—
â—
â—
â—
â—
â—
â—
â—
â—â—â—â—
â—
â— â—
â—
â—
â—â—â—
â—â—
â—
â—
â—â—â—â—
â— â—
â—
â—â—â—
â—â—â— â—â—â—
â— â— â—â—
â—
â—â—
â—
â—
â—
â—
â— â—â—â—â—
â—â—
â—
â—
â—â—
â—
â— â—
â—
â—
â—â— â—
â—
â— â—â—â—â—â—â— â—â—
â—â—
â—
â—â—
â—
â— â— â—â—
â—
â—
â—â—
â—â— â—â—
â—
â—
â—â—â—
â— â—â—
â— â—â—
â—
â—
â—â—
â—
â—
â—
â—
â—
â—
â—â—â—
â—
â—
â— â—â—
â—
â—â— â—
â—
â—â—
â—
â— â—
â—â—â—â—
â— â— â— â—â—
â—
â—â—â—
â— â—
â—â—
â—
â—
â— â—
â—
â—
â—
â—
â— â— â—â—
â— â—
â—â—
â— â—â—
â—
â—
â—

â—

â—
â—

â—

â—
â—

â—

â—
â—
â—â— â— â—
â—
â—â—
â—
â— â—â—
â—
â—â— â—â—â—â—
â—
â—â— â—
â—â—
â—
â—â—
â—â—â—â—
â—â—â—
â—
â—â—
â— â—
â—â—
â—
â—
â—
â—
â—
â—
â—â—â—
â—
â—
â—
â—
â—
â—
â—
â—
â—â— â—
â—
â—â—
â—â—
â—
â—
â—â— â—
â—
â— â—â— â— â—
â—
â—
â—â—
â—
â—â—
â—
â—
â—
â—â—â—
â—â—
â— â—â—
â—â—
â—
â—â—â— â—
â—
â—
â—â—
â—
â—
â—
â—
â—â—
â— â—â—
â—
â—
â—
â—â—
â—â—
â—â—
â—â—
â—â—
â—â—â—
â—
â—
â—â— â—
â—â—
â—
â—
â—
â—
â—
â—
â—
â—â— â—
â—
â—â—â—
â—
â—
â—
â—
â—
â—
â—
â—â—â—
â—
â—
â—â—
â—
â—â—
â—â—
â—
â—
â—
â— â—
â—
â—
â—â—
â— â—â—
â—
â— â—â—â—
â—â—
â—
â—
â—â—
â—â— â—â—
â— â—
â—
â—
â—
â—
â—â—â—
â—â—â—
â—
â—
â—
â—â—
â—
â—
â—
â—
â—â—
â—
â—
â—
â—
â—
â—
â—â—
â—
â—â—â—
â—â— â—
â—â—â—
â—â—
â—â—
â—â— â—â—
â—
â—
â—â—
â—â—
â—
â—
â—
â—
â—â—â—
â—
â—
â—â—
â—
â—
â—
â— â— â—â—
â—â—â—
â— â—â—
â—
â—
â—
â—
â— â— â—â—â—
â—
â—
â—
â— â— â—â—
â—â—
â—
â—â— â—
â—â—â—
â—
â—â—
â—
â—
â—
â—
â—
â—
â—
â—â—
â—
â—â—
â—
â—
â—
â—
â—
â—
â—â—
â—
â—
â—
â—
â—â—
â—
â—â—â—â—â—â—â— â—
â—â—
â—
â—
â—
â—â— â—â—
â—
â—
â—
â—â—â—
â—
â—â— â—
â— â—
â—â—
â—
â—â—
â—
â—â—
â— â—â—
â—
â—
â—
â—
â—â—
â—
â—
â—â—
â—
â—â— â—â—
â—
â—
â— â— â—â—
â—
â—
â—
â—
â—
â—
â—
â—â—
â—
â—
â—â—â—â—
â—
â—
â—
â—â—â— â—
â—
â—
â—
â—â—
â—
â—
â—â— â—
â—â—
â—
â—â—
â—
â—
â—
â—
â—
â—â—â—â—â—
â—â—
â— â—â—
â—
â—â— â—â—
â—
â—
â—
â—
â—
â—
â—
â—
â—
â—
â—
â—â—
â—
â—â—
â— â—
â—
â— â—
â—
â—
â—
â—â—
â—â—
â— â—â—
â—â—â—
â—
â—
â—
â—
â—â—â—â—
â—
â—
â—
â—â— â—
â—
â—
â—â—
â—â—
â—
â—â—â—
â—â—
â—
â—
â—
â—â—
â—â—
â—
â—â—
â—
â—â—
â— â—
â—â— â—â—
â—â— â—
â—â—
â—â—â—
â—
â— â—
â—
â—
â—
â—â—â—
â—
â—
â—â—
â—â—
â—
â—
â— â—
â—
â—
â—
â—â— â—
â—â—
â—
â—â— â— â— â—
â—
â—
â—â—
â—
â—â—
â—
â—
â—
â—
â—
â—â—

â—
â—
â—

Figure 3. Decision boundaries and location of the inducing points after training for each method. GFITC, EP and SEP seem to place
the inducing points one on top of each other. By contrast, VI prefers to place them near the decision boundaries. Best seen in color.

4.3. Performance as a Function of the Training Time
Figure 4 shows the negative test log-likelihood of each
method as a function of the training time on the Satellite
dataset (EP results are not shown since it performs equal
to SEP). Training is done as in Section 4.1. We consider
a growing number of inducing points M = 4, 20, 100 and
report averages over 100 repetitions of the experiments. In
all methods we use batch training. We observe that SEP
is the method with the best performance at the lowest cost.
Again, it is faster than GFITC because it optimizes q and
the hyper-parameters at the same time, while GFITC waits
until EP has converged to update the hyper-parameters.
VI is not very efficient for small values of M , due to the
quadratures. It also takes more time to get a good estimate
of q, which is updated by gradient descent and is less ef-

ficient than the EP updates. Similar results are obtained
in terms of the test error. See the supplementary material.
However, in that case VI does not overfit the training data.
Satellite Dataset

1.0

1.5

GFITC M = 4
GFITC M = 20
GFITC M = 100
SEP M = 4
SEP M = 20
SEP M = 100
VI M = 4
VI M = 20
VI M = 100

0.5

Avg. Negative Test Log Likelihood

Figure 3 shows the location learnt by each method for the
inducing points. Blue, red and green points represent the
training data, black lines are decision boundaries and black
border points are the inducing points. As we increase the
number of inducing points the methods become more accurate. However, GFITC, EP and SEP identify decision
boundaries that are better with a smaller number of inducing points. VI fails in this task. This is probably because VI
updates the inducing-points with a bad estimate of q during the initial iterations. VI uses gradient steps to update
q, which is less efficient than the EP updates (free of any
learning rate). GFITC, EP and SEP overlap the inducing
points, which can be seen as a pruning mechanism (if two
inducing points are equal, it is like having only one). This
has already been observed in regression problems (Bauer
et al., 2016). By contrast, VI places the inducing points
near the decision boundaries. This agrees with previous
results on binary classification (Hensman et al., 2015a).

âˆ’1

0

1
2
Avg. Time in seconds in log10

3

4

Figure 4. Negative test log-likelihood for GFITC, SEP and VI on
Satellite as a function of the training time. Best seen in color.

4.4. Performance When Using Stochastic Gradients
In very large datasets batch training is infeasible, and one
must use mini-batches to update q and to approximate the
required gradients. We evaluate the performance of each
method on the MNIST dataset (LeCun et al., 1998) with
M = 200 inducing points and mini-batches with 200 instances. This dataset has 60, 000 instances for training and
10, 000 for testing. The learning rate of each method is
set using ADAM with the default parameters (Kingma &
Ba, 2015). GFITC does not allow for stochastic optimization. Thus, it is ignored in the comparison. The test error
and the negative test log-likelihood of each method is displayed in Figure 5 (top) as a function of the training time.
In this larger dataset all methods perform similarly. However, EP and SEP take less time to converge than VI. SEP
obtains a test error that is 2.08% and average negative test
log-likelihood that is 0.0725. The results of VI are 2.02%
and 0.0686, respectively. These results are similar to the

MNIST

0.60

Methods

EP
SEP
VI

Test Error

0.48

MNIST

2.30

Methods

EP
SEP
VI

1.86
1.42

0.36

0.98

0.24

0.54

0.12

0.10

100
10000
Training Time in Seconds in a Log10 Scale

100
10000
Training Time in Seconds in a Log10 Scale

Airline Delays

Airline Delays

Methods

EP
Linear
SEP
VI

0.60
Test Error

0.58

Neg. Test Logâˆ’Likelihood

0.00

Neg. Test Logâˆ’Likelihood

Scalable Multi-Class Gaussian Process Classification using Expectation Propagation

1.15

Methods

EP
Linear
SEP
VI

1.10

0.56
0.54

1.05

0.52

1.00

0.50
1e+01
1e+03
1e+05
Training Time in Seconds in a Log10 Scale

0.95

1e+01
1e+03
1e+05
Training Time in Seconds in a Log10 Scale

Figure 5. Average test error and average negative test log-likelihood for each method on the MNIST (top) and the Airline (bottom)
dataset. In the Airline dataset a linear model based on logistic regression is included in the comparison. Best seen in color.

ones reported in (Hensman et al., 2015a) using M = 500.
A last experiment considers all flights within the USA between 01/2008 and 04/2008 (http://stat-computing.
org/dataexpo/2009). The task is to classify the flights
according to their delay using three classes: On time, more
than 5 minutes of delay, or more than 5 minutes before
time. We consider 8 attributes: age of the aircraft, distance covered, airtime, departure time, arrival time, day
of the week, day of the month and month. After removing all instances with missing data 2, 127, 068 instances remain, from which 10, 000 are used for testing and the rest
for training. We use the same settings as on the MNIST
dataset and evaluate each method. The results obtained
are shown in Figure 5 (bottom). We also report the performance of a logistic regression classifier. Again, all methods perform similarly in terms of test error. However, EP
and SEP converge faster and quickly outperform the linear
model. Importantly, the negative test log-likelihood of VI
starts increasing at some point, which is again probably due
to the optimization of Eq(fi ) [log p(yi |fi )] in (15). The supplementary material has further evidence supporting this.

5. Conclusions
We have proposed the first method for multi-class classification with Gaussian processes, based on expectation propagation (EP), that scales well to very large datasets. Such
a method uses the FITC approximation to reduce the number of latent variables in the model from O(N ) to O(M ),
where M  N , and N is the number of data instances. For
this, M inducing points are introduced for each latent function in the model. Importantly, the proposed method allows for stochastic optimization as the estimate of the log-

marginal-likelihood involves a sum across the data. Moreover, we have also considered a stochastic version of EP
(SEP) to reduce the memory usage. When mini-batches
and stochastic gradients are used for training, the computational cost of the proposed approach is O(CM 3 ), with C
the number of classes. The memory cost is O(CM 2 ).
We have compared the proposed method with other approaches from the literature based on variational inference
(VI) (Hensman et al., 2015b), and with the model considered by Kim & Ghahramani (2006), which has been combined with FITC approximate priors (GFITC) (QuinÌƒoneroCandela & Rasmussen, 2005). The proposed approach
outperforms GFITC in large datasets as this method does
not allow for stochastic optimization, and in small datasets
it produces similar results. The proposed method, SEP,
is slightly faster than VI which also allows for stochastic
optimization. In particular, VI requires one-dimensional
quadratures which in small datasets are expensive. We have
also observed that SEP converges faster than VI. This is
probably because the EP updates, free of any learning rate,
are more efficient for finding a good posterior approximation than the gradient ascent updates employed by VI.
An important conclusion of this work is that VI sometimes
gives bad predictive distributions in terms of the test loglikelihood. The EP and SEP methods do not seem to have
this problem. Thus, if one cares about accurate predictive
distributions, VI should be avoided in favor of the proposed
methods. In our experiments we have also observed that
the proposed approaches tend to place the inducing points
one on top of each other, which can be seen as an inducing
point pruning technique (Bauer et al., 2016). By contrast,
VI tends to place them near the decision boundaries.

Scalable Multi-Class Gaussian Process Classification using Expectation Propagation

Acknowledgements
The authors gratefully acknowledge the use of the facilities of Centro de ComputacioÌn CientÄ±Ìfica (CCC) at
Universidad AutoÌnoma de Madrid. The authors also
acknowledge financial support from Spanish Plan Nacional I+D+i, Grants TIN2013-42351-P, TIN2016-76406P, TIN2015-70308-REDT and TEC2016-81900-REDT
(MINECO/FEDER EU), and from Comunidad de Madrid,
Grant S2013/ICE-2845.

References
Bauer, M., van der Wilk, M., and Rasmussen, C. E. Understanding probabilistic sparse Gaussian process approximations. In Advances in Neural Information Processing
Systems 29, pp. 1533â€“1541. 2016.
Chai, K. M. A. Variational multinomial logit Gaussian process. Journal of Machine Learning Research, 13:1745â€“
1808, 2012.
Dezfouli, A. and Bonilla, E. V. Scalable inference for
Gaussian process models with black-box likelihoods. In
Advances in Neural Information Processing Systems 28,
pp. 1414â€“1422. 2015.
Girolami, M. and Rogers, S. Variational Bayesian multinomial probit regression with Gaussian process priors.
Neural Computation, 18:1790â€“1817, 2006.
Henao, R. and Winther, O. Predictive active set selection
methods for Gaussian processes. Neurocomputing, 80:
10â€“18, 2012.
Hensman, J., Matthews, A., and Ghahramani, Z. Scalable
variational Gaussian process classification. In Proceedings of the Eighteenth International Conference on Artificial Intelligence and Statistics, pp. 351â€“360, 2015a.
Hensman, J., Matthews, A. G., Filippone, M., and Ghahramani, Z. MCMC for variationally sparse Gaussian processes. In Advances in Neural Information Processing
Systems 28, pp. 1648â€“1656. 2015b.
HernaÌndez-Lobato, D. and HernaÌndez-Lobato, J. M. Scalable Gaussian process classification via expectation
propagation. In Proceedings of the 19th International
Conference on Artificial Intelligence and Statistics, pp.
168â€“176, 2016.
HernaÌndez-Lobato, D., aÌndez Lobato, J.M., and Dupont,
P. Robust multi-class Gaussian process classification. In
Advances in Neural Information Processing Systems 24,
pp. 280â€“288, 2011.

Kim, H.-C. and Ghahramani, Z. Bayesian Gaussian process
classification with the EM-EP algorithm. IEEE Transactions on Pattern Analysis and Machine Intelligence, 28:
1948â€“1959, 2006.
Kingma, D. P. and Ba, J. ADAM: a method for stochastic
optimization. In Inrernational Conference on Learning
Representations, pp. 1â€“15, 2015.
Kuss, M. and Rasmussen, C. E. Assessing approximate inference for binary Gaussian process classification. Journal of Machine Learning Research, 6:1679â€“1704, 2005.
LeCun, Yann, Bottou, LeÌon, Bengio, Yoshua, and Haffner,
Patrick. Gradient-based learning applied to document
recognition. Proceedings of the IEEE, 86:2278â€“2324,
1998.
Li, Y., HernaÌndez-Lobato, J. M., and Turner, R. E. Stochastic expectation propagation. In Advances in Neural Information Processing Systems 28, pp. 2323â€“2331. 2015.
Lichman, M. UCI machine learning repository, 2013. URL
http://archive.ics.uci.edu/ml.
Minka, T.
Expectation propagation for approximate
Bayesian inference. In Proceedings of the 17th Annual
Conference on Uncertainty in Artificial Intelligence, pp.
362â€“36, 2001.
Naish-Guzman, A. and Holden, S. The generalized FITC
approximation. In Advances in Neural Information Processing Systems 20, pp. 1057â€“1064. 2008.
Nickisch, H. and Rasmussen, C. E. Approximations for binary Gaussian process classification. Journal of Machine
Learning Research, 9:2035â€“2078, 2008.
QuinÌƒonero-Candela, J. and Rasmussen, C. E. A unifying
view of sparse approximate Gaussian process regression.
Journal of Machine Learning Research, 6:1939â€“1959,
2005.
Rasmussen, C. E. and Williams, C. K. I. Gaussian Processes for Machine Learning (Adaptive Computation
and Machine Learning). The MIT Press, 2006.
RiihimaÌˆki, J., JylaÌˆnki, P., and Vehtari, A. Nested expectation propagation for Gaussian process classification with
a multinomial probit likelihood. Journal of Machine
Learning Research, 14:75â€“109, 2013.
Roweis, S. Gaussian identities. Technical report, New York
University, 1999.
Seeger, M. Expectation propagation for exponential families. Technical report, Department of EECS, University
of California, Berkeley, 2006.

Scalable Multi-Class Gaussian Process Classification using Expectation Propagation

Snelson, E. Flexible and efficient Gaussian process models
for machine learning. PhD thesis, 2007.
Snelson, E. and Ghahramani, Z. Sparse Gaussian processes
using pseudo-inputs. In Advances in Neural Information
Processing Systems 18, pp. 1257â€“1264, 2006.
Williams, C. K. I. and Barber, D. Bayesian classification
with Gaussian processes. IEEE Transactions on Pattern Analysis and Machine Intelligence, 20:1342â€“1351,
1998.

