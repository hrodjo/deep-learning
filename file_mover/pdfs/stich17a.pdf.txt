Approximate Steepest Coordinate Descent

Sebastian U. Stich 1 Anant Raj 2 Martin Jaggi 1

Abstract
We propose a new selection rule for the coordinate selection in coordinate descent methods
for huge-scale optimization. The efficiency of
this novel scheme is provably better than the efficiency of uniformly random selection, and can
reach the efficiency of steepest coordinate descent (SCD), enabling an acceleration of a factor
of up to n, the number of coordinates. In many
practical applications, our scheme can be implemented at no extra cost and computational efficiency very close to the faster uniform selection.
Numerical experiments with Lasso and Ridge regression show promising improvements, in line
with our theoretical guarantees.

1. Introduction
Coordinate descent (CD) methods have attracted a substantial interest the optimization community in the last few
years (Nesterov, 2012; RichtaÃÅrik & TakaÃÅcÃå, 2016). Due to
their computational efficiency, scalability, as well as their
ease of implementation, these methods are the state-of-theart for a wide selection of machine learning and signal processing applications (Fu, 1998; Hsieh et al., 2008; Wright,
2015). This is also theoretically well justified: The complexity estimates for CD methods are in general better than
the estimates for methods that compute the full gradient in
one batch pass (Nesterov, 2012; Nesterov & Stich, 2017).
In many CD methods, the active coordinate is picked
at random, according to a probability distribution. For
smooth functions it is theoretically well understood how
the sampling procedure is related to the efficiency of the
scheme and which distributions give the best complexity
estimates (Nesterov, 2012; Zhao & Zhang, 2015; AllenZhu et al., 2016; Qu & RichtaÃÅrik, 2016; Nesterov & Stich,
2017). For nonsmooth and composite functions ‚Äî that
appear in many machine learning applications ‚Äî the pic1
EPFL 2 Max Planck Institute for Intelligent Systems. Correspondence to: Sebastian U. Stich <sebastian.stich@epfl.ch>.

Proceedings of the 34 th International Conference on Machine
Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017
by the author(s).

ture is less clear. For instance in (Shalev-Shwartz &
Zhang, 2013; Friedman et al., 2007; 2010; Shalev-Shwartz
& Tewari, 2011) uniform sampling (UCD) is used, whereas
other papers propose adaptive sampling strategies that
change over time (Papa et al., 2015; Csiba et al., 2015; Osokin et al., 2016; Perekrestenko et al., 2017).
A very simple deterministic strategy is to move along the
direction corresponding to the component of the gradient
with the maximal absolute value (steepest coordinate descent, SCD) (Boyd & Vandenberghe, 2004; Tseng & Yun,
2009). For smooth functions this strategy yields always
better progress than UCD, and the speedup can reach a factor of the dimension (Nutini et al., 2015). However, SCD
requires the computation of the whole gradient vector in
each iteration which is prohibitive (except for special applications, cf. Dhillon et al. (2011); Shrivastava & Li (2014)).
In this paper we propose approximate steepest coordinate
descent (ASCD), a novel scheme which combines the best
parts of the aforementioned strategies: (i) ASCD maintains
an approximation of the full gradient in each iteration and
selects the active coordinate among the components of this
vector that have large absolute values ‚Äî similar to SCD;
and (ii) in many situations the gradient approximation can
be updated cheaply at no extra cost ‚Äî similar to UCD. We
show that regardless of the errors in the gradient approximation (even if they are infinite), ASCD performs always
better than UCD.
Similar to the methods proposed in (Tseng & Yun, 2009)
we also present variants of ASCD for composite problems.
We confirm our theoretical findings by numerical experiments for Lasso and Ridge regression on a synthetic dataset
as well as on the RCV1 (binary) dataset.
Structure of the Paper and Contributions. In Sec. 2 we
review the existing theory for SCD and (i) extend it to the
setting of smooth functions. We present (ii) a novel lower
bound, showing that the complexity estimates for SCD and
UCD can be equal in general. We (iii) introduce ASCD
and the save selection rules for both smooth (Sec. 3) and
to composite functions (Sec. 5). We prove that (iv) ASCD
performs always better than UCD (Sec. 3) and (v) it can
reach the performance of SCD (Sec. 6). In Sec. 4 we discuss important applications where the gradient estimate can
efficiently be maintained. Our theory is supported by nu-

Approximate Steepest Coordinate Descent (ASCD)

merical evidence in Sec. 7, which reveals that (vi) ASCD
performs extremely well on real data.
Notation. Define [x]i := hx, ei i with ei the standard
unit vectors in Rn . We abbreviate ‚àái f := [‚àáf ]i . A
convex function f : Rn ‚Üí R with coordinate-wise Li Lipschitz continuous gradients1 for constants Li > 0,
i ‚àà [n] := {1, . . . , n}, satisfies by the standard reasoning
f (x + Œ∑ei ) ‚â§ f (x) + Œ∑‚àái f (x) +

Li 2
2 Œ∑

(1)

for all x ‚àà Rn and Œ∑ ‚àà R. A function is coordinate-wise
L-smooth if Li ‚â§ L for i = 1, . . . , n. For an optimization
problem minx‚ààRn f (x) define X ? := arg minx‚ààRn f (x)
and denote by x? ‚àà Rn an arbitrary element x? ‚àà X ? .

2. Steepest Coordinate Descent
In this section we present SCD and discuss its theoretical
properties. The functions of interest are composite convex
functions F : Rn ‚Üí R of the form
F (x) := f (x) + Œ®(x)

Coordinate descent methods with constant step size generate a sequence {xt }t‚â•0 of iterates that satisfy the relation
1
L ‚àáit f (x)eit

.

it = arg max ‚àái |f (xt )| .

(4)

i‚àà[n]

2.1. Convergence analysis
With the quadratic upper bound (1) one can easily get a
lower bound on the one step progress
i
h
2
1
|‚àáit f (xt )| . (5)
E [f (xt ) ‚àí f (xt+1 ) | xt ] ‚â• Eit 2L
For UCD and SCD the expression on the right hand side
evaluates to

œÑSCD (xt ) :=

œÑSCD (xt ) ‚â•

1

(f (xt ) ‚àí f (x? )) ,

(8)

Smooth Objectives. When the objective function f is
just smooth (but not necessarily strongly convex), then the
analysis mentioned above is not applicable. We here extend
the analysis from (Nutini et al., 2015) to smooth functions.
Theorem 2.1. Let f : Rn ‚Üí R be convex and coordinatewise L-smooth. Then for the sequence {xt }t‚â•0 generated
by SCD it holds:

2
1
2nL k‚àáf (xt )k2
2
1
2L k‚àáf (xt )k‚àû

(6)

f (xt ) ‚àí f (x? ) ‚â§

for R1 := max
?
?
x ‚ààX

2LR12
,
t

(9)


maxn [kx ‚àí x k1 | f (x) ‚â§ f (x0 )] .
?

x‚ààR

Proof. In the proof we first derive a lower bound on the one
step progress (Lemma A.1), similar to the analysis in (Nesterov, 2012). The lower bound for the one step progress of
SCD can in each iteration differ up to a factor of n from the
analogous bound derived for UCD (similar as in (7)). All
details are given in Section A.1 in the appendix.
Note that the R1 is essentially the diameter of the level set
at f (x0 ) measured in the 1-norm. In the complexity estimate of UCD, R12 in (9) is replaced by nR22 , where R2 is
the diameter of the level at f (x0 ) measured in the 2-norm
(cf. Nesterov (2012); Wright (2015)). As in (7) we observe
with Cauchy-Schwarz
1 2
n R1

With Cauchy-Schwarz we find
1
n œÑSCD (xt )

¬µ1
L

where ¬µ1 denotes the strong convexity parameter. By this,
they get a uniform upper bound on the convergence that
does not directly depend on local properties of the function,
like for instance œÑSCD (xt ), but just on ¬µ1 . It always holds
¬µ1 ‚â§ ¬µ2 , and for functions where both quantities are equal,
SCD enjoys a linear speedup over UCD.

(3)

In UCD the active coordinate it is chosen uniformly at random from the set [n], it ‚ààu.a.r. [n]. SCD chooses the coordinate according to the Gauss-Southwell (GS) rule:

œÑUCD (xt ) :=

Strongly Convex Objectives. Nutini et al. (2015)
present an elegant solution of this problem for ¬µ2 -strongly
convex functions2 . They propose to measure the strong
convexity of the objective function in the 1-norm instead
of the 2-norm. This gives rise to the lower bound

(2)

where f is coordinate-wise L-smooth
Pn and Œ® convex and
separable, that is that is Œ®(x) =
i=1 Œ®i ([x]i ). In the
first part of this section we focus on smooth problems, i.e.
we assume that Œ® ‚â° 0.

xt+1 = xt ‚àí

Hence, the lower bound on the one step progress of SCD is
always at least as large as the lower bound on the one step
progress of UCD. Moreover, the one step progress could
be even lager by a factor of n. However, it is very difficult
to formally prove that this linear speed-up holds for more
than one iteration, as the expressions in (7) depend on the
(a priori unknown) sequence of iterates {xt }t‚â•0 .

‚â§ R22 ‚â§ R12 ,

(10)

i.e. SCD can accelerate up to a factor of n over to UCD.
‚â§ œÑUCD (xt ) ‚â§ œÑSCD (xt ) .

|‚àái f (x + Œ∑ei ) ‚àí ‚àái f (x)| ‚â§ Li |Œ∑| ,

n

(7)

‚àÄx ‚àà R , Œ∑ ‚àà R.

2

A function is ¬µp -strongly convex in the p-norm, p ‚â• 1, if
¬µ
f (y) ‚â• f (x) + h‚àáf (x), y ‚àí xi + 2p ky ‚àí xk2p , ‚àÄx, y ‚àà Rn .

Approximate Steepest Coordinate Descent (ASCD)

2.2. Lower bounds
In the previous section we provided complexity estimates
for the methods SCD and UCD and showed that SCD can
converge up to a factor of the dimension n faster than UCD.
In this section we show that this analysis is tight. In Theorem 2.2 below we give a function q : Rn ‚Üí R, for which
the one step progress œÑSCD (xt ) ‚âà œÑUCD (xt ) up to a constant factor, for all iterates {xt }t‚â•0 generated by SCD.
By a simple technique we can also construct functions for
which the speedup is exactly equal to an arbitrary factor
Œª ‚àà [1, n]. For instance we can consider functions with
a (separable) low dimensional structure. Fix integers s, n
such that ns ‚âà Œª, define the function f : Rn ‚Üí R as
f (x) := q(œÄs (x))

(11)

where œÄs denotes the projection to Rs (being the first s
out of n coordinates) and q : Rs ‚Üí R is the function from
Theorem 2.2. Then
œÑSCD (xt ) ‚âà Œª ¬∑ œÑUCD (xt ) ,

(12)

for all iterates {xt }t‚â•0 generated by SCD.
Theorem 2.2. Consider the function q(x) = 12 hQx, xi for
99
Q := In ‚àí 100n
Jn , where Jn = 1n 1Tn , n > 2. Then
there exists x0 ‚àà Rn such that for the sequence {xt }t‚â•0
generated by SCD it holds
2

k‚àáq(xt )k‚àû ‚â§

4
n

mod n)

2

k‚àáq(xt )k2 .

= cnŒ± ¬∑ [xt‚àí1 ]1+(t‚àí1

Vi (x, y, s) := sy +

L 2
2y

(13)

mod n)

. (14)

We verify that for this sequence property (13) holds.
2.3. Composite Functions
The generalization of the GS rule (4) to composite problems (2) with nontrival Œ® is not straight forward. The
‚Äòsteepest‚Äô direction is not always meaningful in this setting;
consider for instance a constrained problem where this rule
could yield no progress at all when stuck at the boundary.
Nutini et al. (2015) discuss several generalizations of the
Gauss-Southwell rule for composite functions. The GSs rule is defined to choose the coordinate with the most
negative directional derivative (Wu & Lange, 2008). This
rule is identical to (4) but requires the calculation of subgradients of Œ®i . However, the length of a step could be

+ Œ®i ([x]i + y) ,

(15)

for i ‚àà [n]. The GS-q rule is formally defined as
iGS‚àíq = arg min min Vi (x, y, ‚àái f (x)) .
i‚àà[n]

y‚ààR

(16)

2.4. The Complexity of the GS rule
So far we only studied the iteration complexity of SCD,
but we have disregarded the fact that the computation of
the GS rule (4) can be as expensive as the computation
of the whole gradient. The application of coordinate descent methods is only justified if the complexity to compute
one directional derivative is approximately n times cheaper
than the computation of the full gradient vector (cf. Nesterov (2012)). By Theorem 2.2 this reasoning also applies
to SCD. A class of function with this property is given by
functions F : Rn ‚Üí R
F (x) := f (Ax) +

Proof. In the appendix we discuss a family of functions
defined by matrices Q := (Œ± ‚àí 1) n1 Jn + In and define
corresponding parameters 0 < cŒ± < 1 such that for x0 defor i = 1, . . . , n, SCD cycles through
fined as [x0 ]i = ci‚àí1
Œ±
the coordinates, that is, the sequence {xt }t‚â•0 generated by
SCD satisfies
[xt ]1+(t‚àí1

arbitrarily small. In contrast, the GS-r rule was defined to
pick the coordinate direction that yields the longest step
(Tseng & Yun, 2009). The rule that enjoys the best theoretical properties (cf. Nutini et al. (2015)) is the GS-q rule,
which is defined as to maximize the progress assuming a
quadratic upper bound on f (Tseng & Yun, 2009). Consider the coordinate-wise models

n
X

Œ®i ([x]i )

(17)

i=1

where A is a d √ó n matrix, and where f : Rd ‚Üí R,
and Œ®i : Rn ‚Üí R are convex and simple, that is the
time complexity T for computing their gradients is linear:
T (‚àáy f (y), ‚àáx Œ®(x) = O(d + n). This class of functions includes least squares, logistic regression, Lasso, and
SVMs (when solved in dual form).
Assuming the matrix is dense, the complexity to compute
the full gradient of F is T (‚àáx F (x)) = O(dn). If the value
w = Ax is already computed, one directional derivative
can be computed in time T (‚àái F (x)) = O(d). The recursive update of w after one step needs the addition of one
column of matrix A with some factors and can be done in
time O(d). However, we note that recursively updating the
full gradient vector takes time O(dn) and consequently the
computation of the GS rule cannot be done efficiently.
Nutini et al. (2015) consider sparse matrices, for which the
computation of the Gauss-Southwell rule becomes traceable. In this paper, we propose an alternative approach. Instead of updating the exact gradient vector, we keep track
of an approximation of the gradient vector and recursively
update this approximation in time O(n log n). With these
updates, the use of coordinate descent is still justified in
case d = ‚Ñ¶(n).

Approximate Steepest Coordinate Descent (ASCD)

Algorithm 1 Approximate SCD (ASCD)
Input: f , x0 , T , Œ¥-gradient oracle g, method M
Initialize [gÃÉ0 ]i = 0, [r0 ]i = ‚àû for i ‚àà [n].
for t = 0 to T do
For i ‚àà [n] define
compute u.-and l.-bounds
[ut ]i := max{|[gÃÉt ]i ‚àí [rt ]i | , |[gÃÉt ]i + [rt ]i |}
[`t ]i := miny‚ààR {|y| | [gÃÉt ]i ‚àí[rt ]i ‚â§ y ‚â§ [gÃÉt ]i +[rt ]i }
P
1
[` ]2
compute active set
av(I) := |I|
i‚ààI
 t i
	
It := arg minI  I ‚äÜ [n] | [ut ]2 < av(I), ‚àÄi ‚àà
/I 
i

active coordinate
Pick it ‚ààu.a.r. arg maxi‚ààIt {[`]i }
(xt+1 , [gÃÉt+1 ]it , [rt+1 ]it ) := M(xt , ‚àáit f (xt ))

Œ≥t := [xt+1 ]it ‚àí [xt ]it
update ‚àáf (xt+1 ) estimate
Update [gÃÉt+1 ]j := [gÃÉt ]j + Œ≥t git j (xt ), j 6= it
Update [rt+1 ]j := [rt ]j + Œ≥t Œ¥it j , j 6= it
end for

3. Algorithm
Is it possible to get the significantly improved convergence
speed from SCD, when one is only willing to pay the computational cost of only the much simpler UCD? In this section, we give a formal definition of our proposed approximate SCD method which we denote ASCD.
The core idea of the algorithm is the following: While performing coordinate updates, ideally we would like to efficiently track the evolution of all elements of the gradient,
not only the one coordinate which is updated in the current step. The formal definition of the method is given in
Algorithm 1 for smooth objective functions. In each iteration, only one coordinate is modified according to some
arbitrary update rule M. The coordinate update rule M
provides two things: First the new iterate xt+1 , and secondly also an estimate gÃÉ of the it -th entry of the gradient at
the new iterate3 . Formally,
(xt+1 , gÃÉ, r) := M(xt , ‚àáit f (xt ))

(18)

such that the quality of the new gradient estimate gÃÉ satisfies
|‚àáit f (xt+1 ) ‚àí gÃÉ| ‚â§ r .

(19)

The non-active coordinates are updated with the help of
gradient oracles with accuracy Œ¥ ‚â• 0 (see next subsection
for details). The scenario of exact updates of all gradient
entries is obtained for accuracy parameters Œ¥ = r = 0 and
in this case ASCD is identical to SCD.
3.1. Safe bounds for gradient evolution
ASCD maintains lower and upper bounds for the absolute values of each component of the gradient ([`]i ‚â§
3
For instance, for updates by exact coordinate optimization
(line-search), we have gÃÉ = r = 0.

|‚àái f (x)| ‚â§ [u]i ). These bounds allow to identify the coordinates on which the absolute values of the gradient are
small (and hence cannot be the steepest one). More precisely, the algorithm maintains a set It of active coordinates
(similar in spirit as in active set methods, see e.g. Kim &
Park (2008); Wen et al. (2012)). A coordinate j is excluded
from It if the estimated progress in this direction (cf. (5))
is lower than the average of the estimated
Pprogress along
coordinate directions in It , [ut ]2j < |I1t | i‚ààIt [`t ]2i . The
active set It can be computed in O(n log n) time by sorting. All other operations take linear O(n) time.
Gradient Oracle. The selection mechanism in ASCD
crucially relies on the following definition of a Œ¥-gradient
oracle. While the update M delivers the estimated active
entry of the new gradient, the additional gradient oracle is
used to update all other coordinates j 6= it of the gradient;
as in the last two lines of Algorithm 1.
Definition 3.1 (Œ¥-gradient oracle). For a function
f : Rn ‚Üí R and indices i, j ‚àà [n], a (i, j)-gradient oracle
with error Œ¥ij ‚â• 0 is a function gij : Rn ‚Üí R satisfying
‚àÄx ‚àà Rn , ‚àÄŒ≥ ‚àà R:
|‚àáj f (x + Œ≥ei ) ‚àí Œ≥gij (x)| ‚â§ |Œ≥| Œ¥ij .

(20)

We denote by a Œ¥-gradient oracle a family {gij }i,j‚àà[n] of
Œ¥ij -gradient oracles.
We discuss the availability of good gradient oracles for
many problem classes in more detail in Section 4. For example for least squares problems and general linear models,
a Œ¥-gradient oracle is for instance given by a scalar product
estimator as in (24) below. Note that ASCD can also handle
very bad estimates, as long as the property (20) is satisfied
(possibly even with accuracy Œ¥ij = ‚àû).
Initialization. In ASCD the initial estimate gÃÉ0 of the gradient is just arbitrarily set to 0, with uncertainty r0 = ‚àû.
Hence in the worst case it takes Œò(n log n) iterations until each coordinate gets picked at least once (cf. Dawkins
(1991)) and until corresponding gradient estimates are set
to a realistic value. If better estimates of the initial gradient
are known, they can be used for the initialization as long
as a strong error bound as in (19) is known as well. For
instance the initialization can be done with ‚àáf (x0 ) if one
is willing to compute this vector in one batch pass.
Convergence Rate Guarantee. We present our first
main result showing that the performance of ASCD is provably between UCD and SCD. First observe that if in Algorithm 1 the gradient oracle is always exact, i.e. Œ¥ij ‚â° 0,
and if gÃÉ0 is initialized with ‚àáf (x0 ), then in each iteration
|‚àáit f (xt )| = k‚àáf (xt )k‚àû and ASCD identical to SCD.
Lemma 3.1. Let imax := arg maxi‚àà[n] |‚àái f (xt )|. Then
imax ‚àà It , for It as in Algorithm 1.

Approximate Steepest Coordinate Descent (ASCD)

Proof. This is immediate from the definitions of It and the
upper and lower bounds. Suppose imax ‚àà
/ It , then there exists j 6= imax such that [`t ]j > [ut ]imax , and consequently
|‚àáj f (xt )| > |‚àáimax f (xt )|.
Theorem 3.2. Let f : Rn ‚Üí R be convex and coordinatewise L-smooth, let œÑUCD , œÑSCD , œÑASCD denote the expected
one step progress (6) of UCD, SCD and ASCD, respectively, and suppose all methods use the same step-size
rule M. Then
œÑUCD (x) ‚â§ œÑASCD (x) ‚â§ œÑSCD (x) ‚àÄx ‚àà Rn .

(21)

P
2
1
Proof. By (5) we get œÑASCD (x) = 2L|I|
i‚ààI |‚àái f (x)| ,
where I denotes the corresponding index set of ASCD
when at iterate x. Note P
that for j ‚àà
/ I it
Pmust hold that2
2
1
1
2
[`]
‚â§
|‚àáj f (x)| ‚â§ [u]2j < |I|
i
i‚ààI
i‚ààI |‚àái f (x)|
|I|
by definition of I.
Observe that the above theorem holds for all gradient oracles and coordinate update variants, as long as they are
used with corresponding quality parameters r (as in (19))
and Œ¥ij (as in (20)) as part of the algorithm.
Heuristic variants. Below also propose three heuristic
variants of ASCD. For all these variants the active set It
can be computed O(n), but the statement of Theorem 3.2
does not apply. These variants only differ from ASCD in
the choice of the active set in Algorithm 1:
u-ASCD: It := arg maxi‚àà[n] [ut ]i
`-ASCD: It := arg maxi‚àà[n] [`t ]i

	
a-ASCD: It := i ‚àà [n] | [ut ]i ‚â• maxi‚àà[n] [`t ]i

4. Approximate Gradient Update
In this section we argue that for a large class of objective
functions of interest in machine learning, the change in the
gradient along every coordinate direction can be estimated
efficiently.
Lemma 4.1. Consider F : Rn ‚Üí R as in (17) with
twice-differentiable f : Rd ‚Üí R. Then for two iterates
xt , xt+1 ‚àà Rn of a coordinate descent algorithm, i.e.
xt+1 = xt + Œ≥t eit , there exists a xÃÉ ‚àà Rn on the line
segment between xt and xt+1 , xÃÉ ‚àà [xt , xt+1 ] with
‚àái F (xt+1 ) ‚àí ‚àái F (xt ) = Œ≥t hai , ‚àá2 f (AxÃÉ)ait i
where ai denotes the i-th column of the matrix A.

‚àÄi 6= it
(22)

Proof. For coordinates i 6= it the gradient (or subgradient
set) of Œ®i ([xt ]i ) does not change. Hence it suffices to calculate the change ‚àáf (xt+1 ) ‚àí ‚àáf (xt ). This is detailed in
the appendix.

Least-Squares with Arbitrary Regularizers. The least
squares problem is defined as problem (17) with f (Ax) =
2
1
d
2 kAx ‚àí bk2 for a b ‚àà R . This function is twice differ2
entiable with ‚àá f (Ax) = In . Hence (22) reduces to
‚àái F (xt+1 ) ‚àí ‚àái F (xt ) = Œ≥t hai , ait i

‚àÄi 6= it .

(23)

This formulation gives rise to various gradient oracles (20)
for the least square problems. For for i 6= it we easily
verify that the condition (20) is satisfied:
1
1. gij
:= hai , ait i; Œ¥ij = 0,
2
2. gij := max {‚àí kai k kaj k , min {S(i, j), kai k kaj k}};
Œ¥ij =  kai k kaj k, where S : [n]√ó[n] denotes a function
with the property
|S(i, j) ‚àí hai , aj i| ‚â§  kai k kaj k , ‚àÄi, j ‚àà [n] (24)
3
3. gij
:= 0; Œ¥ij = kai k kaj k,
4
4. gij
‚ààu.a.r. [‚àí kai k kaj k , kai k kaj k]; Œ¥ij = kai k kaj k.

Oracle g 1 can be used in the rare cases where the dot product matrix is accessible to the optimization algorithm without any extra cost. In this case the updates will all be exact.
If this matrix is not available, then the computation of each
scalar product takes time O(d). Hence, they cannot be recomputed on the fly, as argued in Section 2.4. In contrast,
the oracles g 3 and g 4 are extremely cheap to compute, but
the error bounds are worse. In the numerical experiments
in Section 7 we demonstrate that these oracles perform surprisingly well.
The oracle g 2 can for instance be realized by lowdimensional embeddings, such as given by the JohnsonLindenstrauss lemma (cf. Achlioptas (2003); MatousÃåek
(2008)). By embedding each vector
 in a lower-dimensional
space of dimension O ‚àí2 log n and computing the scalar
products of the embedding in time O(log n), relation (24)
is satisfied.
Updating the gradient of the active coordinate. So far
we only discussed the update of the passive coordinates.
For the active coordinate the best strategy depends on the
update rule M from (18). If exact line search is used, then
0 ‚àà ‚àáit f (xt+1 ). For other update rules we can update the
gradient ‚àáit f (xt+1 ) with the same gradient oracles as for
the other coordinates, however we need also to take into
account the change of the gradient of Œ®i ([xt ]i ). If Œ®i is
simple, like for instance in ridge or lasso, the subgradients
at the new point can be computed efficiently.
Bounded variation. In many applications the Hessian
‚àá2 f (AxÃÉ) is not so simple as in the case of square loss.
If we assume that the Hessian of f is bounded, i.e.
‚àá2 f (Ax)  M ¬∑ In for a constant M ‚â• 0, ‚àÄx ‚àà Rn ,
then it is easy to see that the following holds :
‚àíM kai kkaj k ‚â§ hai , ‚àá2 f (AxÃÉ)ait i ‚â§ M kai kkaj k .

Approximate Steepest Coordinate Descent (ASCD)

Using this relation, we can define gradient oracles for more
general functions, by taking the additional approximation
factor M into account. The quality can be improved, if we
have access to local bounds on ‚àá2 f (Ax).
Heuristic variants. By design, ASCD is robust to high
errors in the gradient estimations ‚Äì the steepest descent direction is always contained in the active set. However, instead of using only the very crude oracle g 4 to approximate
all scalar products, it might be advantageous to compute
some scalar products with higher precision. We propose to
use a caching technique to compute the scalar products with
high precision for all vectors in the active set (and storing a
matrix of size O(It √ó n)). This presumably works well if
the active set does not change much over time.

5. Extension to Composite Functions
The key ingredients of ASCD are the coordinate-wise upper and lower bounds on the gradient and the definition of
the active set It which ensures that the steepest descent direction is always kept and that only provably bad directions
are removed from the active set. These ideas can also be
generalized to the setting of composite functions (2). We
already discussed some popular GS-‚àó update rules in the
introduction in Section 2.3.
Implementing ASCD for the GS-s rule is straight forward,
and we comment on the GS-r in the appendix in Sec. D.2.
Here we exemplary detail the modification for the GS-q
rule (16), which turns out to be the most evolved (the same
reasoning also applies to the GSL-q rule from (Nutini et al.,
2015)). In Algo. 2 we show the construction ‚Äî based just
on approximations of the gradient of the smooth part f ‚Äî
of the active set I. For this we compute upper and lower
bounds v, w on miny‚ààR V (x, y, ‚àái f (x)), such that
[v]i ‚â§ min V (x, y, ‚àái f (x) ‚â§ [w]i
y‚ààR

‚àÄi ‚àà [n] .

(25)

The selection of the active coordinate is then based on these
bounds. Similar as in Lemma 3.1 and Theorem 3.2 this set
has the property iGS‚àíq ‚àà I, and directions are only discarded in such a way that the efficiency of ASCD-q cannot
drop below the efficiency of UCD. The proof can be found
in the appendix in Section D.1.

6. Analysis of Competitive Ratio
In Section 3 we derived in Thm. 3.2 that the one step
progress of ASCD is between the bounds on the onestep
progress of UCD and SCD. However, we know that the efficiency of the latter two methods can differ much, up to
a factor of n. In this section we will argue that in certain
cases where SCD performs much better than UCD, ASCD
will accelerate as well. To measure this effect, we could for

Algorithm 2 Adaptation of ASCD for GS-q rule
Input: Gradient estimate gÃÉ, error bounds r.
For i ‚àà [n] define:
compute u.-and l.-bounds
[u]i := [gÃÉ]i + [r]i , [`]i := [gÃÉ]i ‚àí [r]i
[u? ]i := arg miny‚ààR V (x, y, [u]i )
[`? ]i := arg miny‚ààR V (x, y, [`]i )

minimize the model

compute u.-and l. bounds on miny‚ààR V (x, y, ‚àái f (x))

[œâu ]i := V (x, [u? ]i , [u]i )+max{0, [u? ]i ([`]i ‚àí [u]i )}
[œâ` ]i := V (x, [`? ]i , [`]i ) + max{0, [`? ]i ([u]i ‚àí [`]i )}
[v]i := min {V (x, [u? ]i , [u]i ), V (x, [`? ]i , [`]i )}
[w]i := min {[œâu ]i , [œâ` ]i , Œ®i ([x]i )}
P
1
compute active set
av(I) := |I|
i‚ààI [w]i
It := arg minI |{I ‚äÜ [n] | [v]i > av(I), ‚àÄi ‚àà
/ I}|
instance consider the ratio:

 i ‚àà It | |‚àái f (xt )| ‚â•
%t :=
|It |

1
2

	
k‚àáf (xt )k‚àû 

,

(26)

For general functions this expression is a bit cumbersome
to study, therefore we restrict our discussion to the class
of objective functions (11) as introduced in Sec. 2.2. Of
course not all real-world objective functions will fall into
this class, however this problem class is still very interesting in our study, as we will see in the following, because it
will highlight the ability (or disability) of the algorithms to
eventually identify the right set of ‚Äòactive‚Äô coordinates.
For the functions with the structure (11) (and q as in
Thm. 2.2), the active set falls into the first s coordinates.
Hence it is reasonable to approximate %t by the competitive ratio
|It ‚à© [s]|
œÅt :=
.
(27)
|It |
It is also reasonable to assume that in the limit, (t ‚Üí ‚àû),
a constant fraction of the [s] will be contained in the active
set It (it might not hold [s] ‚äÜ It ‚àÄt, as for instance with
exact line search the directional derivative vanishes just after the update). In the following theorem we calculate œÅt
for (t ‚Üí ‚àû), the proof is given in the appendix.
Theorem 6.1. Let f : Rn ‚Üí R be of the form (11).
For indices i ‚àà
/ [s] define Ki := {t | i ‚àà
/ It , i ‚àà It‚àí1 }.
For j ‚àà Ki define Tji := min {t ‚àí j | i ‚àà Ij+t }, i.e.
i
the number of iterations outside
the active set, T‚àû
:=

i
limt‚Üí‚àû Ej‚ààKi Tj | j > k , and the average T‚àû :=
 i 
Ei‚àà[s]
T‚àû . If there exists a constant c > 0 such that
/
limt‚Üí‚àû |[s] ‚à© It | = cs, then (with the notation œÅ‚àû :=
limt‚Üí‚àû E [œÅt ]),
2cs
‚àö ,
(28)
œÅ‚àû ‚â•
cs + n ‚àí s ‚àí T‚àû + Œ∏
where Œ∏ ‚â° Œ∏ := n2 + (c ‚àí 1)2 s2 + 2n((c ‚àí 1)s ‚àí T‚àû ) +
2
2(1 + c)sT‚àû + T‚àû
. Especially, œÅ‚àû ‚â• 1 ‚àí n‚àís
T‚àû .

Approximate Steepest Coordinate Descent (ASCD)
T

= n/2

T

1
measured
exact
lower bound

0.8

=n

T

1

1

0.8

0.8

0.6

0.6

0.6

0.4

0.4

0.4

0.2

0.2

0.2

0

0
0

50

100

= 4n

0
0

epochs

50

100

epochs

0

50

100

epochs

Figure 1. Competitive ratio œÅt (blue) in comparison with œÅ‚àû (28)
(red) and the lower bound œÅ‚àû ‚â• 1 ‚àí n‚àís
(black). Simulation for
T‚àû
parameters n = 100, s = 10, c = 1 and T‚àû ‚àà {50, 100, 400}.

In Figure 1 we compare the lower bound (28) of the competitive ratio in the limit (t ‚Üí ‚àû) with actual measurements of œÅt for simulated example with parameters n =
100, s = 10, c = 1 and various T‚àû ‚àà {50, 100, 400}.
We initialized the active set I0 = [s], but we see that the
equilibrium is reached quickly.

Based on this Thm. 6.1, we can now estimate the competitive ratio in various scenarios. On the class (11) it holds
c ‚âà 1 as we argued before. Hence the competitive ratio (28) just depends on T‚àû . This quantity measures how
many iterations a coordinate j ‚àà
/ [s] is in average outside
of the active set It . From the lower bound we see that the
competitive ratio œÅt approaches a constant for (t ‚Üí ‚àû) if
T‚àû = Œò (n), for instance œÅ‚àû ‚â• 0.8 if T‚àû ‚â• 5n.
As an approximation to T‚àû , we estimate the quantities Ttj0
defined in Thm. 6.1. Ttj0 denotes the number of iterations
it takes until coordinate j enters the active set again, assuming it left the active set at iteration t0 ‚àí 1. We estimate
Ttj0 ‚â• TÃÇ , where TÃÇ denotes maximum number of iterations
such that

t=t0

s

Œ≥ t Œ¥ ii j



1 X 

‚â§
‚àák f xt0 +TÃÇ 
s

7. Empirical Observations
In this section we evaluate the empirical performance of
ASCD on synthetic and real datasets. We consider the following regularized general linear models:
min 1 kAx ‚àí bk22 + Œª2 kxk22
x‚ààRn 2
min 1 kAx ‚àí bk22 + Œªkxk1
x‚ààRn 2

,

(30)

,

(31)

that is, l2 -regularized least squares (30) as well as l1 regularized linear regression (Lasso) in (31), respectively.

6.1. Estimates of the competitive ratio

tX
0 +TÃÇ

justified if s is large, for instance s ‚â• 14 n. Otherwise the
convergence on q is too fast, and the gradient approximations are too weak. However, notice that we assumed Œ¥ to
be an uniform bound on all errors. If the errors have large
discrepancy the estimates become much better (this holds
for instance on datasets where the norm data vectors differs
much, or when caching techniques as mentioned in Sec. 4
are employed).

‚àÄj ‚àà
/ [s].

(29)

k=1

For smooth functions, the steps Œ≥t = Œò (|‚àáit f (xt )|) and if
we additionally assume that the errors of the gradient oracle
are uniformly bounded Œ¥ij ‚â§ Œ¥, the sum in (29) simplifies
Pt0 +TÃÇ
to Œ¥ t=t
|‚àáit f (xt )|.
0
For smooth, but not strongly convex function q, the norms
of the gradient changes very slowly,
 with a rate independent
of s or n, and we get TÃÇ = Œò  1Œ¥ . Hence, the competitive
ratio is constant for Œ¥ = Œò n1 .
For strongly convex function q, the norm of the gradient
2
decreases linearly, say k‚àáf (xt )k2 ‚àù eŒ∫t for Œ∫ ‚âà 1s . I.e.
it decreases by half after each Œò (s) iterations. Therefore
n
to guarantee TÃÇ = Œò (n) it needs to hold Œ¥ = e‚àíŒò( s ) .
This result seems to indicate that the use of ACDM is only

Datasets. The datasets A ‚àà Rd√ón in problems (30)
and (31) were chosen as follows for our experiments. For
the synthetic data, we follow the same generation procedure as described in (Nutini et al., 2015), which generates very sparse data matrices. For completeness, full details of the data generation process are also provided in
the appendix in Sec. E. For the synthetic data we choose
n = 5000 for problem (31) and n = 1000 for problem (30).
Dimension d = 1000 is fixed for both cases.
For real datasets, we perform the experimental evaluation
on RCV1 (binary,training), which consists of 20, 242 samples, each of dimension 47, 236 (Lewis et al., 2004). We
use the un-normalized version with all non-zeros values set
to 1 (bag-of-words features).
Gradient oracles and implementation details. On the
RCV1 dataset, we approximate the scalar products with
the oracle g 4 that was introduced in Sec. 4. This oracle
is extremely cheap to compute, as the norms kai k of the
columns of A only need to be computed once.
On the synthetic data, we simulate the oracle g 2 for various
precisions values . For this, we sample a value uniformly
at random from the allowed error interval (24). Figs. 2d
and 3d show the convergence for different accuracies.
For the l1 -regularized problems, we used ASCD with the
GS-s rule (the experiments in (Nutini et al., 2015) revealed
almost identical performance of the different GS-‚àó rules).
We compare the performance of UCD, SCD and ASCD.
We also implement the heuristic version a-ASCD that was
introduced in Sec. 3. All algorithm variants use the same
step size rule (i.e. the method M in Algorithm 1). We use
exact line search for the experiment in Fig. 3c, for all others we used a fixed step size rule (the convergence is slower

Approximate Steepest Coordinate Descent (ASCD)

(a) Convergence for l2

(b) Convergence for l1

(c) True vs No Initialization for l2

(d) Error Variation (ASCD)

Figure 2. Experimental results on synthetically generated datasets

(a) Convergence for l2

(b) Convergence for l1

(c) Line search for l1

(d) Error Variation (ASCD)

Figure 3. Experimental results on the RCV1-binary dataset

for all algorithms, but the different effects of the selection
of the active coordinate is more distinctly visible).
ASCD is either initialized with the true gradient (Figs. 2a,
2b, 2d, 3c, 3d) or arbitrarely (with error bounds Œ¥ = ‚àû) in
Figs. 3a and 3b (Fig. 2c compares both initializations).
Fig. 2 shows results on the synthetic data, Fig. 3 on the
RCV1 dataset. All plots show also the size of the active
set It . The plots 3c and 3d are generated on a subspace
of RCV1, with 10000 and 5000 randomly chosen columns,
respectively.
Here are the highlights of our experimental study:
1. No initialization needed.
We observe (see e.g.
Figs. 2c,3a, 3b) that initialization with the true gradient
values is not needed at beginning of the optimization
process (the cost of the initialization being as expensive
as one epoch of ASCD). Instead, the algorithm performs
strong in terms of learning the active set on its own, and
the set converges very fast after just one epoch.
2. High errors toleration. The gradient oracle g 4 gives
very crude approximations, however the convergence of
ASCD is excellent on RCV1 (Fig. 3). Here the size of
the true active set is very small (in the order of 0.1% on
RCV1) and ASCD is able to identify this set. Fig. 3d
shows that almost nothing can be gained from more precise (and more expensive) oracles.
3. Heuristic a-ASCD performs well. The convergence
behavior of ASCD follows theory. For the heuristic version a-ASCD (which computes the active set slightly

faster, but Thm. 3.2 does not hold) performs identical
to ASCD in practice (cf. Figs. 2, 3), and sometimes
slightly better. This is explained by the active set used
in ASCD typically being larger than the active set of aASCD (Figs. 2a,2b, 3a, 3b).

8. Concluding Remarks
We proposed ASCD, a novel selection mechanism for the
active coordinate in CD methods. Our scheme enjoys
three favorable properties: (i) its performance can reach
the performance steepest CD ‚Äî both in theory and practice, (ii) the performance is never worse than uniform CD,
(iii) in many important applications, the scheme it can be
implemented at no extra cost per iteration.
ASCD calculates the active set in a safe manner, and picks
the active coordinate uniformly at random from this smaller
set. It seems possible that an adaptive sampling strategy
on the active set could boost the performance even further.
Here we only study CD methods where a single coordinate
gets updated in each iteration. ASCD can immediately also
be generalized to block-coordinate descent methods. However, the exact implementation in a distributed setting can
be challenging.
Finally, it is an interesting direction to extend ASCD also
to the stochastic gradient descent setting (not only heuristically, but with the same strong guarantees as derived in this
paper).

Approximate Steepest Coordinate Descent (ASCD)

References
Achlioptas, Dimitris. Database-friendly random projections:
Johnson-lindenstrauss with binary coins. Journal of Computer
and System Sciences, 66(4):671 ‚Äì 687, 2003.
Allen-Zhu, Z, Qu, Z, Richtarik, P, and Yuan, Y. Even faster accelerated coordinate descent using non-uniform sampling. 2016.
Boyd, Stephen P and Vandenberghe, Lieven. Convex optimization. Cambridge University Press, 2004.
Csiba, Dominik, Qu, Zheng, and RichtaÃÅrik, Peter. Stochastic Dual
Coordinate Ascent with Adaptive Probabilities. In ICML 2015
- Proceedings of the 32th International Conference on Machine
Learning, 2015.
Dawkins, Brian. Siobhan‚Äôs problem: The coupon collector revisited. The American Statistician, 45(1):76‚Äì82, 1991.

Nutini, Julie, Schmidt, Mark W, Laradji, Issam H, Friedlander,
Michael P, and Koepke, Hoyt A. Coordinate Descent Converges Faster with the Gauss-Southwell Rule Than Random
Selection. In ICML, pp. 1632‚Äì1641, 2015.
Osokin, Anton, Alayrac, Jean-Baptiste, Lukasewitz, Isabella,
Dokania, Puneet K., and Lacoste-Julien, Simon. Minding the
gaps for block frank-wolfe optimization of structured svms.
In Proceedings of the 33rd International Conference on International Conference on Machine Learning - Volume 48,
ICML‚Äô16, pp. 593‚Äì602. PMLR, 2016.
Papa, Guillaume, Bianchi, Pascal, and CleÃÅmencÃßon, SteÃÅphan.
Adaptive Sampling for Incremental Optimization Using
Stochastic Gradient Descent. ALT 2015 - 26th International
Conference on Algorithmic Learning Theory, pp. 317‚Äì331,
2015.

Dhillon, Inderjit S, Ravikumar, Pradeep, and Tewari, Ambuj.
Nearest Neighbor based Greedy Coordinate Descent. In NIPS
2014 - Advances in Neural Information Processing Systems 27,
2011.

Perekrestenko, Dmytro, Cevher, Volkan, and Jaggi, Martin. Faster
Coordinate Descent via Adaptive Importance Sampling. In
Proceedings of the 20th International Conference on Artificial
Intelligence and Statistics, volume 54 of Proceedings of Machine Learning Research, pp. 869‚Äì877, Fort Lauderdale, FL,
USA, 20‚Äì22 Apr 2017. PMLR.

Friedman, Jerome, Hastie, Trevor, HoÃàfling, Holger, and Tibshirani, Robert. Pathwise coordinate optimization. The Annals of
Applied Statistics, 1(2):302‚Äì332, 2007.

Qu, Zheng and RichtaÃÅrik, Peter. Coordinate descent with arbitrary
sampling i: algorithms and complexity. Optimization Methods
and Software, 31(5):829‚Äì857, 2016.

Friedman, Jerome, Hastie, Trevor, and Tibshirani, Robert. Regularization Paths for Generalized Linear Models via Coordinate
Descent. Journal of Statistical Software, 33(1):1‚Äì22, 2010.

RichtaÃÅrik, Peter and TakaÃÅcÃå, Martin. Parallel coordinate descent
methods for big data optimization. Mathematical Programming, 156(1):433‚Äì484, 2016.

Fu, Wenjiang J. Penalized regressions: The bridge versus the
lasso. Journal of Computational and Graphical Statistics, 7
(3):397‚Äì416, 1998.

Shalev-Shwartz, Shai and Tewari, Ambuj. Stochastic Methods
for l1 -regularized Loss Minimization. JMLR, 12:1865‚Äì1892,
2011.

Hsieh, Cho-Jui, Chang, Kai-Wei, Lin, Chih-Jen, Keerthi,
S Sathiya, and Sundararajan, S. A Dual Coordinate Descent
Method for Large-scale Linear SVM. In the 25th International
Conference on Machine Learning, pp. 408‚Äì415, New York,
USA, 2008.

Shalev-Shwartz, Shai and Zhang, Tong. Stochastic Dual Coordinate Ascent Methods for Regularized Loss Minimization.
JMLR, 14:567‚Äì599, 2013.

Kim, Hyunsoo and Park, Haesun. Nonnegative matrix factorization based on alternating nonnegativity constrained least
squares and active set method. SIAM Journal on Matrix Analysis and Applications, 30(2):713‚Äì730, 2008.
Lee, Daniel D and Seung, H Sebastian. Learning the parts of objects by non-negative matrix factorization. Nature, 401(6755):
788‚Äì791, 1999.
Lewis, David D., Yang, Yiming, Rose, Tony G., and Li, Fan.
Rcv1: A new benchmark collection for text categorization research. J. Mach. Learn. Res., 5:361‚Äì397, 2004.
MatousÃåek, JirÃåƒ±ÃÅ. On variants of the johnsonlindenstrauss lemma.
Random Structures & Algorithms, 33(2):142‚Äì156, 2008.
Nesterov, Yu. Efficiency of coordinate descent methods on hugescale optimization problems. SIAM Journal on Optimization,
22(2):341‚Äì362, 2012.
Nesterov, Yurii and Stich, Sebastian U. Efficiency of the accelerated coordinate descent method on structured optimization problems. SIAM Journal on Optimization, 27(1):110‚Äì123,
2017.

Shrivastava, Anshumali and Li, Ping. Asymmetric LSH (ALSH)
for sublinear time maximum inner product search (MIPS). In
NIPS 2014 - Advances in Neural Information Processing Systems 27, pp. 2321‚Äì2329, 2014.
Tseng, Paul and Yun, Sangwoon. A coordinate gradient descent
method for nonsmooth separable minimization. Mathematical
Programming, 117(1):387‚Äì423, 2009.
Wen, Zaiwen, Yin, Wotao, Zhang, Hongchao, and Goldfarb, Donald. On the convergence of an active-set method for 1 minimization. Optimization Methods and Software, 27(6):1127‚Äì
1146, 2012.
Wright, Stephen J. Coordinate descent algorithms. Mathematical
Programming, 151(1):3‚Äì34, 2015.
Wu, Tong Tong and Lange, Kenneth. Coordinate descent algorithms for lasso penalized regression. Ann. Appl. Stat., 2(1):
224‚Äì244, 2008.
Zhao, Peilin and Zhang, Tong. Stochastic optimization with importance sampling for regularized loss minimization. In Proceedings of the 32nd International Conference on Machine
Learning, volume 37 of PMLR, pp. 1‚Äì9, Lille, France, 2015.
PMLR.

