Fast k-Nearest Neighbour Search via Prioritized DCI
Ke Li 1 Jitendra Malik 1

Abstract
Most exact methods for k-nearest neighbour
search suffer from the curse of dimensionality;
that is, their query times exhibit exponential dependence on either the ambient or the intrinsic
dimensionality. Dynamic Continuous Indexing
(DCI) (Li & Malik, 2016) offers a promising way
of circumventing the curse and successfully reduces the dependence of query time on intrinsic
dimensionality from exponential to sublinear. In
this paper, we propose a variant of DCI, which
we call Prioritized DCI, and show a remarkable
improvement in the dependence of query time on
intrinsic dimensionality. In particular, a linear
increase in intrinsic dimensionality, or equivalently, an exponential increase in the number of
points near a query, can be mostly counteracted
with just a linear increase in space. We also
demonstrate empirically that Prioritized DCI significantly outperforms prior methods. In particular, relative to Locality-Sensitive Hashing (LSH),
Prioritized DCI reduces the number of distance
evaluations by a factor of 14 to 116 and the memory consumption by a factor of 21.

1. Introduction
The method of k-nearest neighbours is a fundamental
building block of many machine learning algorithms and
also has broad applications beyond artificial intelligence,
including in statistics, bioinformatics and database systems, e.g. (Biau et al., 2011; Behnam et al., 2013; Eldawy & Mokbel, 2015). Consequently, since the problem
of nearest neighbour search was first posed by Minsky &
Papert (1969), it has for decades intrigued the artificial intelligence and theoretical computer science communities
alike. Unfortunately, the myriad efforts at devising efficient algorithms have encountered a recurring obstacle: the
1
University of California, Berkeley, CA 94720, United States.
Correspondence to: Ke Li <ke.li@eecs.berkeley.edu>.

Proceedings of the 34 th International Conference on Machine
Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017
by the author(s).

curse of dimensionality, which describes the phenomenon
of query time complexity depending exponentially on dimensionality. As a result, even on datasets with moderately
high dimensionality, practitioners often have resort to naı̈ve
exhaustive search.
Two notions of dimensionality are commonly considered.
The more familiar notion, ambient dimensionality, refers to
the dimensionality of the space data points are embedded
in. On the other hand, intrinsic dimensionality1 characterizes the intrinsic properties of the data and measures the
rate at which the number of points inside a ball grows as
a function of its radius. More precisely, for a dataset with
intrinsic dimension d0 , any ball of radius r contains at most
0
O(rd ) points. Intuitively, if the data points are uniformly
distributed on a manifold, then the intrinsic dimensionality
is roughly the dimensionality of the manifold.
Most existing methods suffer from some form of curse
of dimensionality. Early methods like k-d trees (Bentley,
1975) and R-trees (Guttman, 1984) have query times that
grow exponentially in ambient dimensionality. Later methods (Krauthgamer & Lee, 2004; Beygelzimer et al., 2006;
Dasgupta & Freund, 2008) overcame the exponential dependence on ambient dimensionality, but have not been
able to escape from an exponential dependence on intrinsic dimensionality. Indeed, since a linear increase in the
intrinsic dimensionality results in an exponential increase
in the number of points near a query, the problem seems
fundamentally hard when intrinsic dimensionality is high.
Recently, Li & Malik (2016) proposed an approach known
as Dynamic Continuous Indexing (DCI) that successfully
reduces the dependence on intrinsic dimensionality from
exponential to sublinear, thereby making high-dimensional
nearest neighbour search more practical. The key observation is that the difficulties encountered by many existing
methods, including k-d trees and Locality-Sensitive Hashing (LSH) (Indyk & Motwani, 1998), may arise from their
reliance on space partitioning, which is a popular divideand-conquer strategy. It works by partitioning the vector
space into discrete cells and maintaining a data structure
1

The measure of intrinsic dimensionality used throughout
this paper is the expansion dimension, also known as the KRdimension, which is defined as log2 c, where c is the expansion
rate introduced in (Karger & Ruhl, 2002).

Fast k-Nearest Neighbour Search via Prioritized DCI

that keeps track of the points lying in each cell. At query
time, these methods simply look up of the contents of the
cell containing the query and possibly adjacent cells and
perform brute-force search over points lying in these cells.
While this works well in low-dimensional settings, would
it work in high dimensions?
Several limitations of this approach in high-dimensional
space are identified in (Li & Malik, 2016). First, because
the volume of space grows exponentially in dimensionality,
either the number or the volumes of cells must grow exponentially. Second, the discretization of the space essentially
limits the “field of view” of the algorithm, as it is unaware
of points that lie in adjacent cells. This is especially problematic when the query lies near a cell boundary, as there
could be points in adjacent cells that are much closer to
the query. Third, as dimensionality increases, surface area
grows faster than volume; as a result, points are increasingly likely to lie near cell boundaries. Fourth, when the
dataset exhibits varying density across space, choosing a
good partitioning is non-trivial. Furthermore, once chosen,
the partitioning is fixed and cannot adapt to changes in density arising from updates to the dataset.
In light of these observations, DCI is built on the idea
of avoiding partitioning the vector space. Instead, it constructs a number of indices, each of which imposes an ordering of all data points. Each index is constructed so that
two points with similar ranks in the associated ordering are
nearby along a certain random direction. These indices are
then combined to allow for retrieval of points that are close
to the query along multiple random directions.
In this paper, we propose a variant of DCI, which assigns a
priority to each index that is used to determine which index
to process in the upcoming iteration. For this reason, we
will refer to this algorithm as Prioritized DCI. This simple
change results in a significant improvement in the dependence of query time on intrinsic dimensionality. Specifically, we show a remarkable result: a linear increase in
intrinsic dimensionality, which could mean an exponential
increase in the number of points near a query, can be mostly
counteracted with a corresponding linear increase in the
number of indices. In other words, Prioritized DCI can
make a dataset with high intrinsic dimensionality seem almost as easy as a dataset with low intrinsic dimensionality,
with just a linear increase in space. To our knowledge, there
had been no exact method that can cope with high intrinsic
dimensionality; Prioritized DCI represents the first method
that can do so.
We also demonstrate empirically that Prioritized DCI significantly outperforms prior methods. In particular, compared to LSH, it achieves a 14- to 116-fold reduction in the
number of distance evaluations and a 21-fold reduction in
the memory usage.

2. Related Work
There is a vast literature on algorithms for nearest neighbour search. They can be divided into two categories:
exact algorithms and approximate algorithms. Early exact algorithms are deterministic and store points in treebased data structures. Examples include k-d trees (Bentley, 1975), R-trees (Guttman, 1984) and X-trees (Berchtold
et al., 1996; 1998), which divide the vector space into a
hierarchy of half-spaces, hyper-rectangles or Voronoi polygons and keep track of the points that lie in each cell. While
their query times are logarithmic in the size of the dataset,
they exhibit exponential dependence on the ambient dimensionality. A different method (Meiser, 1993) partitions the
space by intersecting multiple hyperplanes. It effectively
trades off space for time and achieves polynomial query
time in ambient dimensionality at the cost of exponential
space complexity in ambient dimensionality.

Spill Tree
RP Tree
Karger & Ruhl
Navigating Net
Cover Tree
Rank Cover Tree

DCI

Prioritized DCI
(Proposed Method)

Figure 1. Visualization of the query time complexities of various
exact algorithms as a function of the intrinsic dimensionality d0 .
Each curve represents an example from a class of similar query
time complexities. Algorithms that fall into each particular class
are shown next to the corresponding curve.

To avoid poor performance on worst-case configurations of
the data, exact randomized algorithms have been proposed.
Spill trees (Liu et al., 2004), RP trees (Dasgupta & Freund, 2008) and virtual spill trees (Dasgupta & Sinha, 2015)
extend the ideas behind k-d trees by randomizing the orientations of hyperplanes that partition the space into halfspaces at each node of the tree. While randomization enables them to avoid exponential dependence on the ambient
dimensionality, their query times still scale exponentially in
the intrinsic dimensionality. Whereas these methods rely
on space partitioning, other algorithms (Orchard, 1991;
Clarkson, 1999; Karger & Ruhl, 2002) have been proposed
that utilize local search strategies. These methods start with
a random point and look in the neighbourhood of the current point to find a new point that is closer to the query
than the original in each iteration. Like space partitioningbased approaches, the query time of (Karger & Ruhl, 2002)
scales exponentially in the intrinsic dimensionality. While

Fast k-Nearest Neighbour Search via Prioritized DCI
Method
Exact Algorithms:
RP Tree
Spill Tree
Karger & Ruhl (2002)
Navigating Net
Cover Tree
Rank Cover Tree
DCI
Prioritized DCI
(Proposed Method)

Query Time Complexity
0

O((d0 log d0 )d + log n)
0
O(d0d + log n)
0
O(23d log n)
0
2O(d ) log n
0
O(212d log n)
0
O(2O(d log h) n2/h ) for h 3
0
O(d max(log n, n1 1/d ))
0
O(d max(log n, n1 m/d )
+(m log m) max(log n, n1
for m 1

1/d0

))

Approximate Algorithms:
k-d Tree
O((1/✏)d log n)
BBD Tree
O((6/✏)d log n)
2
LSH
⇡ O(dn1/(1+✏) )
Table 1. Query time complexities of various algorithms for 1-NN
search. Ambient dimensionality, intrinsic dimensionality, dataset
size and approximation ratio are denoted as d, d0 , n and 1 + ✏.
A visualization of the growth of various time complexities as a
function of the intrinsic dimensionality is shown in Figure 1.

the query times of (Orchard, 1991; Clarkson, 1999) do not
exhibit such undesirable dependence, their space complexities are quadratic in the size of the dataset, making them impractical for large datasets. A different class of algorithms
performs search in a coarse-to-fine manner. Examples include navigating nets (Krauthgamer & Lee, 2004), cover
trees (Beygelzimer et al., 2006) and rank cover trees (Houle
& Nett, 2015), which maintain sets of subsampled data
points at different levels of granularity and descend through
the hierarchy of neighbourhoods of decreasing radii around
the query. Unfortunately, the query times of these methods
again scale exponentially in the intrinsic dimensionality.
Due to the difficulties of devising efficient algorithms for
the exact version of the problem, there has been extensive
work on approximate algorithms. Under the approximate
setting, returning any point whose distance to the query
is within a factor of 1 + ✏ of the distance between the
query and the true nearest neighbour is acceptable. Many
of the same strategies are employed by approximate algorithms. Methods based on tree-based space partitioning (Arya et al., 1998) and local search (Arya & Mount,
1993) have been developed; like many exact algorithms,
their query times also scale exponentially in the ambient
dimensionality. Locality-Sensitive Hashing (LSH) (Indyk
& Motwani, 1998; Datar et al., 2004; Andoni & Indyk,
2006) partitions the space into regular cells, whose shapes
are implicitly defined by the choice of the hash function. It
achieves a query time of O(dn⇢ ) using O(dn1+⇢ ) space,
where d is the ambient dimensionality, n is the dataset
size and ⇢ ⇡ 1/(1 + ✏)2 for large n in Euclidean space,

though the dependence on intrinsic dimensionality is not
made explicit. In practice, the performance of LSH degrades on datasets with large variations in density, due
to the uneven distribution of points across cells. Consequently, various data-dependent hashing schemes have
been proposed (Paulevé et al., 2010; Weiss et al., 2009; Andoni & Razenshteyn, 2015); unlike data-independent hashing schemes, however, they do not allow dynamic updates
to the dataset. A related approach (Jégou et al., 2011) decomposes the space into mutually orthogonal axis-aligned
subspaces and independently partitions each subspace. It
has a query time linear in the dataset size and no known
guarantee on the probability of correctness under the exact or approximate setting. A different approach (Anagnostopoulos et al., 2015) projects the data to a lower dimensional space that approximately preserves approximate
nearest neighbour relationships and applies other approximate algorithms like BBD trees (Arya et al., 1998) to the
projected data. Its query time is also linear in ambient dimensionality and sublinear in the dataset size. Unlike LSH,
it uses space linear in the dataset size, at the cost of longer
query time than LSH. Unfortunately, its query time is exponential in intrinsic dimensionality.
Our work is most closely related to Dynamic Continuous
Indexing (DCI) (Li & Malik, 2016), which is an exact randomized algorithm for Euclidean space whose query time
is linear in ambient dimensionality, sublinear in dataset size
and sublinear in intrinsic dimensionality and uses space linear in the dataset size. Rather than partitioning the vector space, it uses multiple global one-dimensional indices,
each of which orders data points along a certain random
direction and combines these indices to find points that are
near the query along multiple random directions. The proposed algorithm builds on the ideas introduced by DCI and
achieves a significant improvement in the dependence on
intrinsic dimensionality.
A summary of the query times of various prior algorithms
and the proposed algorithm is presented in Table 1 and their
growth as a function of intrinsic dimensionality is illustrated in Figure 1.

3. Prioritized DCI
DCI constructs a data structure consisting of multiple composite indices of data points, each of which in turn consists
of a number of simple indices. Each simple index orders
data points according to their projections along a particular random direction. Given a query, for every composite
index, the algorithm finds points that are near the query in
every constituent simple index, which are known as candidate points, and adds them to a set known as the candidate
set. The true distances from the query to every candidate
point are evaluated and the ones that are among the k clos-

Fast k-Nearest Neighbour Search via Prioritized DCI

est to the query are returned.

made for each individual query.

More concretely, each simple index is associated with a
random direction and stores the projections of every data
point along the direction. They are implemented using
standard data structures that maintain one-dimensional ordered sequences of elements, like self-balancing binary
search trees (Bayer, 1972; Guibas & Sedgewick, 1978)
or skip lists (Pugh, 1990). At query time, the algorithm
projects the query along the projection directions associated with each simple index and finds the position where
the query would have been inserted in each simple index,
which takes logarithmic time. It then iterates over, or visits, data points in each simple index in the order of their
distances to the query under projection, which takes constant time for each iteration. As it iterates, it keeps track of
how many times each data point has been visited across all
simple indices of each composite index. If a data point has
been visited in every constituent simple index, it is added
to the candidate set and is said to have been retrieved from
the composite index.

Prioritized DCI differs from standard DCI in the order in
which points from different simple indices are visited. In
standard DCI, the algorithm cycles through all constituent
simple indices of a composite index at regular intervals and
visits exactly one point from each simple index in each
pass. In Prioritized DCI, the algorithm assigns a priority
to each constituent simple index; in each iteration, it visits
the upcoming point from the simple index with the highest
priority and updates the priority at the end of the iteration.
The priority of a simple index is set to the negative absolute
difference between the query projection and the next data
point projection in the index.

Algorithm 1 Data structure construction procedure
Require: A dataset D of n points p1 , . . . , pn , the number of simple indices m that constitute a composite index and the number
of composite indices L
function C ONSTRUCT(D, m, L)
{ujl }j2[m],l2[L]
mL random unit vectors in Rd
{Tjl }j2[m],l2[L]
mL empty binary search trees or skip
lists
for j = 1 to m do
for l = 1 to L do
for i = 1 to n do
pijl
hpi , ujl i
Insert (pijl , i) into Tjl with pijl being the key and
i being the value
end for
end for
end for
return {(Tjl , ujl )}j2[m],l2[L]
end function

Algorithm 2 k-nearest neighbour querying procedure
Require: Query point q in Rd , binary search trees/skip lists and
their associated projection vectors {(Tjl , ujl )}j2[m],l2[L] , the
number of points to retrieve k0 and the number of points to visit
k1 in each composite index
function Q UERY(q, {(Tjl , ujl )}j,l , k0 , k1 )
Cl
array of size n with entries initialized to 0 8l 2 [L]
q jl
hq, ujl i 8j 2 [m], l 2 [L]
Sl
; 8l 2 [L]
Pl
empty priority queue 8l 2 [L]
for l = 1 to L do
for j = 1 to m do
(1)
(1)
(pjl , hjl )
the node in Tjl whose key is the
closest to q jl
(1)

(1)

(i+1)

which is denoted as (pjl
priority

DCI has a number of appealing properties compared to
methods based on space partitioning. Because points are
visited by rank rather than location in space, DCI performs
well on datasets with large variations in data density. It
naturally skips over sparse regions of the space and concentrates more on dense regions of the space. Since construction of the data structure does not depend on the dataset, the
algorithm supports dynamic updates to the dataset, while
being able to automatically adapt to changes in data density. Furthermore, because data points are represented in
the indices as continuous values without being discretized,
the granularity of discretization does not need to be chosen
at construction time. Consequently, the same data structure
can support queries at varying desired levels of accuracy,
which allows a different speed-vs-accuracy trade-off to be

(1)

Insert (pjl , hjl ) with priority |pjl
q jl |
into Pl
end for
end for
for i0 = 1 to k1 1 do
for l = 1 to L do
if |Sl | < k0 then
(i)
(i)
(pjl , hjl )
the node with the highest priority
in Pl
(i)
(i)
Remove (pjl , hjl ) from Pl and insert the node
in Tjl whose key is the next closest to q jl ,

(i)

Cl [hjl ]

(i+1)
|pjl
(i)
Cl [hjl ]

(i+1)

, hjl

), with

q jl | into Pl

+1

(i)

if Cl [hjl ] = m then
(i)

Sl
Sl [ {hjl }
end if
end if
end for
end for
S
return k points in l2[L] Sl that are the closest in
Euclidean distance in Rd to q
end function

Intuitively, this ensures data points are visited in the order
of their distances to the query under projection. Because
data points are only retrieved from a composite index when
they have been visited in all constituent simple indices, data

Fast k-Nearest Neighbour Search via Prioritized DCI
Property

Complexity

Construction
Query

O(m(dn
+ n log n))
⇣
0
O dk max(log(n/k), (n/k)1 m/d )+
⇣
⌘⌘
0
mk log m max(log(n/k), (n/k)1 1/d )
O(m(d + log n))
O(m log n)
O(mn)

Insertion
Deletion
Space

Table 2. Time and space complexities of Prioritized DCI.

points are retrieved in the order of the maximum of their
distances to the query along multiple projection directions.
Since distance under projection forms a lower bound on the
true distance, the maximum projected distance approaches
the true distance as the number of projection directions increases. Hence, in the limit as the number of simple indices
approaches infinity, data points are retrieved in the ideal order, that is, the order of their true distances to the query.

time spent on evaluating true distances between candidate
points and the query. Therefore, we need to find the number of candidate points that must be retrieved to ensure the
algorithm succeeds with high probability. To this end, we
derive an upper bound on the failure probability for any
given number of candidate points. The algorithm fails if
sufficiently many distant points are retrieved from each
composite index before some of the true k-nearest neighbours. We decompose this event into multiple (dependent)
events, each of which is the event that a particular distant
point is retrieved before some true k-nearest neighbours.
Since points are retrieved in the order of their maximum
projected distance, this event happens when the maximum
projected distance of the distant point is less than that of
a true k-nearest neighbour. We start by finding an upper
bound on the probability of this event. To simplify notation, we initially consider displacement vectors from the
query to each data point, and so relationships between projected distances of triplets of points translate relationships
between projected lengths of pairs of displacement vectors.

The construction and querying procedures of Prioritized DCI are presented formally in Algorithms 1 and
2.
To ensure the algorithm retrieves the exact knearest neighbours with high probability, the analysis in the next section shows that one should choose
0
k0 2 ⌦(k max(log(n/k), (n/k)1 m/d )) and k1 2
0
⌦(mk max(log(n/k), (n/k)1 1/d )), where d0 denotes the
intrinsic dimensionality. Though because this assumes
worst-case configuration of data points, it may be overly
conservative in practice; so, these parameters may be chosen by cross-validation.

We start by examining the event that a vector under random one-dimensional projection satisfies some geometric
constraint. We then find an upper bound on the probability that some combinations of these events occur, which is
related to the failure probability of the algorithm.
Lemma 1. Let v l , v s 2 Rd be such that v l 2 > v s 2 ,

We summarize the time and space complexities of Prioritized DCI in Table 2. Notably, the first term of the query
complexity, which dominates when the ambient dimensionality d is large, has a more favourable dependence on the intrinsic dimensionality d0 than the query complexity of standard DCI. In particular, a linear increase in the intrinsic dimensionality, which corresponds to an exponential increase
in the expansion rate, can be mitigated by just a linear increase in the number of simple indices m. This suggests
that Prioritized DCI can better handle datasets with high
intrinsic dimensionality than standard DCI, which is confirmed by empirical evidence later in this paper.

Proof. The event maxj hv l , u0j i  kv s k2 is equivalent to the event that hv l , u0j i  kv s k2 8j , which is
the intersection of the events hv l , u0j i  kv s k2 . Because u0j ’s are drawn independently, these events are independent.

u0j

In high-dimensional space, query time is dominated by the

be i.i.d. unit vectors in Rd drawn uniformly

at random.
2
⇡

1

cos

Then Pr maxj
1

v

s
2

/ v

M

l

hv l , u0j i

2

.

 vs

2

=

Let ✓j be the angle between v l and u0j , so that hv l , u0j i =
v l 2 cos ✓j . Since u0j is drawn uniformly, ✓j is uniformly
distributed
on [0, 2⇡]. Hence, ◆
✓
Pr max
j

=

M
Y

Pr

j=1

4. Analysis
We analyze the time and space complexities of Prioritized
DCI below and derive the stopping condition of the algorithm. Because the algorithm uses standard data structures,
analysis of the construction time, insertion time, deletion
time and space complexity is straightforward. Hence, this
section focuses mostly on analyzing the query time.

M
j=1

=

=

hv l , u0j i

o

 kv s k2

hv l , u0j i  kv s k2

⌘

✓
◆
kv s k2
Pr |cos ✓j | 
kv l k2
j=1
M
Y

M ✓
Y

j=1

=

⇣

n

✓

1

✓

2Pr ✓j 2 cos
2
cos
⇡

1

✓

kv s k2
kv l k2

✓

kv s k2
kv l k2
◆◆M

1

◆

,⇡

cos

1

✓

kv s k2
kv l k2

◆ ◆◆

Fast k-Nearest Neighbour Search via Prioritized DCI
N

Lemma 2. For any set of events {Ei }i=1 , the probability
PN
that at least k 0 of them happen is at most k10 i=1 Pr (Ei ).

Proof. For any set T ✓ [N ], define ẼT to be the intersection of events indexed by TTand complements
of events not
T
E
indexed
by
T
,
i.e.
Ẽ
=
E
\
T
i
i . Observe
i2T
i
2T
/
n o
that
T

are disjoint and that for any I ✓ [N ],
S
0
i2I Ei =S T ◆I ẼT . The
T event that at least k of Ei ’s
happen is I✓[N ]:|I|=k0 i2I Ei , which is equivalent to
S
S
S
I✓[N ]:|I|=k0
T ◆I ẼT =
T ✓[N ]:|T | k0 ẼT . We will
henceforth use T to denote {T ✓ [N ] : |T | k 0 }. Since
T is a finite set, we can impose an ordering on its elements
and denote the S
lth element as Tl . The event can therefore
|T |
be rewritten as l=1 ẼTl .
⇣S
⌘
|T |
0
Define Ei,j
to be Ei \
We claim
l=j+1 ẼTl .
⇣
⌘
PN
Pj
0
0
that
k
for all j 2
i=1 Pr Ei,j
l=1 Pr ẼTl
ẼT

T ✓[N ]

{0, . . . , |T |}. We will show this by induction on j.

For j = 0, the claim is vacuously true because probabili0
ties are non-negative. For j > 0, we observe that Ei,j
=
⇣
⌘ ⇣
⌘
⇣
⌘
0
0
0
0
Ei,j \ ẼTj [ Ei,j \ ẼTj = Ei,j 1 [ Ei,j \ ẼTj
0
0
for all i. Since Ei,j
\ ẼTj and Ei,j
\ ẼTj are disjoint,
⇣
⌘
0
0
0
Pr Ei,j = Pr Ei,j 1 + Pr Ei,j \ ẼTj .
P
0
Consider the quantity
which is
i,j ,
i2Tj Pr E
⇣
⇣
⌘⌘
P
0
0
by the above
i2Tj Pr Ei,j 1 + Pr Ei,j \ ẼTj

observation.
For each
i 2⇣ Tj , ẼTj ✓⌘ Ei , and so
⇣S
⌘
S|T |
|T |
0
ẼTj \
l=j+1 ẼTl ✓ Ei \
l=j+1 ẼTl = Ei,j . Ben
o|T |
⇣S
⌘
|T |
cause ẼTl
are disjoint, ẼTj \
l=j+1 ẼTl = ẼTj .
l=j

0
0
Hence, ẼTj ✓ Ei,j
and so Ei,j
\ Ẽ = ẼTj . Thus,
⇣
⌘ PTj
P
0
0
i2Tj Pr Ei,j = |Tj | Pr ẼTj +
i2Tj Pr Ei,j 1 .
⇣
⌘
PN
0
It follows that
Pr
E
=
|T
|
Pr
Ẽ
+
j
Tj
i,j
i=1
P
P
0
0
+
.
Because
i2Tj Pr Ei,j 1
i2T
/ j Pr Ei,j
⇣
⌘
0
0
0
Pr Ei,j
= Pr Ei,j
+ Pr Ei,j
\ ẼTj
1
PN
0
0
Pr Ei,j
and |Tj |
k0 ,
i=1 Pr Ei,j
⇣ 1⌘
P
N
0
k 0 Pr ẼTj +
By the inductive
i=1 Pr Ei,j 1 .
⌘
PN
Pj 1 ⇣
0
hypothesis,
k 0 l=1 Pr ẼTl .
i=1 Pr Ei,j 1
⇣
⌘
PN
Pj
0
Therefore, i=1 Pr Ei,j
k 0 l=1 Pr ẼTl , which
concludes the induction argument.

The lemma is a special case of ⇣this claim
when
⌘
⇣S j = |T⌘|,
P|T |
|T |
0
since Ei,|T | = Ei and l=1 Pr ẼTl = Pr
l=1 ẼTl .

Combining the above yields the following theorem, the
proof of which is found in the supplementary material.
N

N0

Theorem 1. Let vil i=1 and vis0 i0 =1 be sets of vectors such that vil 2 >
vis0 2 8i 2 [N ], i0 2
[N 0 ]. Furthermore, let u0ij i2[N ],j2[M ] be random uniformly distributed unit vectors such that u0i1 , . . . , u0iM
are independent for any given i. Consider the events
N
9vis0 s.t. maxj hvil , u0ij i  vis0 2 i=1 . The probability that at least k 0 of these events occur is at
PN
M
s
most k10 i=1 1 ⇡2 cos 1 vmax
/ vil 2
, where
2
s
s
0
0
vmax
=
max
v
.
Furthermore,
if
k
=
N , it is
0
i
2
n i 2
o
M
2
1
s
l
vmax 2 / vi 2
.
at most mini2[N ] 1 ⇡ cos
We now apply the results above to analyze specific properties of the algorithm. For convenience, instead of working
directly with intrinsic dimensionality, we will analyze the
query time in terms of a related quantity, global relative
sparsity, as defined in (Li & Malik, 2016). We reproduce
its definition below for completeness.
Definition 1. Given a dataset D ✓ Rd , let Bp (r) be the
set of points in D that are within a ball of radius r around
a point p. A dataset D has global relative sparsity of (⌧, )
if for all r and p 2 Rd such that |Bp (r)| ⌧ , |Bp ( r)| 
2 |Bp (r)|, where
1.
Global relative sparsity is related to the expansion
rate (Karger & Ruhl, 2002) and intrinsic dimensionality in
the following way: a dataset with global relative sparsity
of (⌧, ) has (⌧, 2(1/ log2 ) )-expansion and intrinsic dimensionality of 1/ log2 .
Below we derive two upper bounds on the probability that
some of the true k-nearest neighbours are missing from the
set of candidate points retrieved from a given composite
index, which are in expressed in terms of k0 and k1 respectively. These results inform us how k0 and k1 should be
chosen to ensure the querying procedure returns the correct
results with high probability. In the results that follow, we
use {p(i) }ni=1 to denote a re-ordering of the points {pi }ni=1
so that p(i) is the ith closest point to the query q. Proofs are
found in the supplementary material.
Lemma 3. Consider points in the order they are retrieved from a composite index that consists of m
simple indices.
The probability that there are at
least n0 points that are not the true k-nearest neighbours P
but are retrieved before some of them is at most
m
n
1
2
1
p(k) q 2 / p(i) q 2
.
i=2k+1 1
n0 k
⇡ cos
Lemma 4. Consider point projections in a composite
index that consists of m simple indices in the order they
are visited. The probability that n0 point projections that
are not of the true k-nearest neighbours are visited before
all true P
k-nearest neighbours have been retrieved is at most
n
m
2
1
p(k) q 2 / p(i) q 2 .
i=2k+1 1
n0 mk
⇡ cos

Fast k-Nearest Neighbour Search via Prioritized DCI

Lemma
relative
P

5.
On
a
dataset
with
global
sparsity
(k, ),
the
quantity
m
n
2
1
p(k) q 2 / p(i) q 2
is
i=2k+1 1
⇡ cos
at most O k max(log(n/k), (n/k)1 m log2 ) .
Lemma 6. For a dataset with global relative sparsity (k, ) and a given composite index consisting of m simple indices, there is some k0 2
⌦(k max(log(n/k), (n/k)1 m log2 )) such that the probability that the candidate points retrieved from the composite
index do not include some of the true k-nearest neighbours
is at most some constant ↵0 < 1.
Lemma 7. For a dataset with global relative sparsity (k, ) and a given composite index consisting of m simple indices, there is some k1 2
⌦(mk max(log(n/k), (n/k)1 log2 )) such that the probability that the candidate points retrieved from the composite
index do not include some of the true k-nearest neighbours
is at most some constant ↵1 < 1.
Theorem 2. For a dataset with global relative sparsity (k, ), for any ✏ > 0, there is some L,
k0 2 ⌦(k max(log(n/k), (n/k)1 m log2 )) and k1 2
⌦(mk max(log(n/k), (n/k)1 log2 )) such that the algorithm returns the correct set of k-nearest neighbours with
probability of at least 1 ✏.
Now that we have found a choice of k0 and k1 that suffices
to ensure correctness with high probability, we can derive
a bound on the query time that guarantees correctness. We
then analyze the time complexity for construction, insertion and deletion and the space complexity. Proofs of the
following are found in the supplementary material.
Theorem 3. For a given
⇣ number of simple indices m,0 the
algorithm takes O dk max(log(n/k), (n/k)1 m/d )+
⇣
⌘⌘
0
mk log m max(log(n/k), (n/k)1 1/d )
time to re-

trieve the k-nearest neighbours at query time, where d0 denotes the intrinsic dimensionality.
Theorem 4. For a given number of simple indices m, the
algorithm takes O(m(dn + n log n)) time to preprocess the
data points in D at construction time.
Theorem 5. The algorithm requires O(m(d + log n)) time
to insert a new data point and O(m log n) time to delete a
data point.
Theorem 6. The algorithm requires O(mn) space in addition to the space used to store the data.

5. Experiments
We compare the performance of Prioritized DCI to that
of standard DCI (Li & Malik, 2016), product quantization (Jégou et al., 2011) and LSH (Datar et al., 2004),
which is perhaps the algorithm that is most widely used

in high-dimensional settings. Because LSH operates under the approximate setting, in which the performance metric of interest is how close the returned points are to the
query rather than whether they are the true k-nearest neighbours. All algorithms are evaluated in terms of the time
they would need to achieve varying levels of approximation quality.
Evaluation is performed on two datasets, CIFAR100 (Krizhevsky & Hinton, 2009) and MNIST (LeCun
et al., 1998). CIFAR-100 consists of 60, 000 colour images of 100 types of objects in natural scenes and MNIST
consists of 70, 000 grayscale images of handwritten digits.
The images in CIFAR-100 have a size of 32 ⇥ 32 and three
colour channels, and the images in MNIST have a size of
28 ⇥ 28 and a single colour channel. We reshape each image into a vector whose entries represent pixel intensities
at different locations and colour channels in the image. So,
each vector has a dimensionality of 32 ⇥ 32 ⇥ 3 = 3072 for
CIFAR-100 and 28 ⇥ 28 = 784 for MNIST. Note that the
dimensionalities under consideration are much higher than
those typically used to evaluate prior methods.
For the purposes of nearest neighbour search, MNIST is a
more challenging dataset than CIFAR-100. This is because
images in MNIST are concentrated around a few modes;
consequently, data points form dense clusters, leading to
higher intrinsic dimensionality. On the other hand, images in CIFAR-100 are more diverse, and so data points
are more dispersed in space. Intuitively, it is much harder
to find the closest digit to a query among 6999 other digits
of the same category that are all plausible near neighbours
than to find the most similar natural image among a few
other natural images with similar appearance. Later results
show that all algorithms need fewer distance evaluations to
achieve the same level of approximation quality on CIFAR100 than on MNIST.
We evaluate performance of all algorithms using crossvalidation, where we randomly choose ten different splits
of query vs. data points. Each split consists of 100 points
from the dataset that serve as queries, with the remainder
designated as data points. We use each algorithm to retrieve
the 25 nearest neighbours at varying levels of approximation quality and report mean performance and standard deviation over all splits.
Approximation quality is measured using the approximation ratio, which is defined to be the ratio of the radius of
the ball containing the set of true k-nearest neighbours to
the radius of the ball containing the set of approximate knearest neighbours returned by the algorithm. The closer
the approximation ratio is to 1, the higher the approximation quality. In high dimensions, the time taken to compute
true distances between the query and the candidate points
dominates query time, so the number of distance evalua-

Fast k-Nearest Neighbour Search via Prioritized DCI

(a)

(b)

(c)

Figure 2. Comparison of the number of distance evaluations needed by different algorithms to achieve varying levels of approximation
quality on (a) CIFAR-100 and (b,c) MNIST. Each curve represents the mean over ten folds and the shaded area represents ±1 standard
deviation. Lower values are better. (c) Close-up view of the figure in (b).

tions can be used as an implementation-independent proxy
for the query time.
For LSH, we used 24 hashes per table and 100 tables, which
we found to achieve the best approximation quality given
the memory constraints. For product quantization, we used
a data-independent codebook with 256 entries so that the
algorithm supports dynamic updates. For standard DCI, we
used the same hyparameter settings used in (Li & Malik,
2016) (m = 25 and L = 2 on CIFAR-100 and m = 15 and
L = 3 on MNIST). For Prioritized DCI, we used two different settings: one that matches the hyperparameter settings
of standard DCI, and another that uses less space (m = 10
and L = 2 on both CIFAR-100 and MNIST).
We plot the number of distance evaluations that each algorithm requires to achieve each desired level of approximation ratio in Figure 2. As shown, on CIFAR-100, under the
same hyperparameter setting used by standard DCI, Prioritized DCI requires 87.2% to 92.5% fewer distance evaluations than standard DCI, 91.7% to 92.8% fewer distance
evaluations than product quantization, and 90.9% to 93.8%
fewer distance evaluations than LSH to achieve same levels
approximation quality, which represents a 14-fold reduction in the number of distance evaluations relative to LSH
on average. Under the more space-efficient hyperparameter
setting, Prioritized DCI achieves a 6-fold reduction compared to LSH. On MNIST, under the same hyperparameter setting used by standard DCI, Prioritized DCI requires
96.4% to 97.0% fewer distance evaluations than standard
DCI, 87.1% to 89.8% fewer distance evaluations than product quantization, and 98.8% to 99.3% fewer distance evaluations than LSH, which represents a 116-fold reduction
relative to LSH on average. Under the more space-efficient
hyperparameter setting, Prioritized DCI achieves a 32-fold
reduction compared to LSH.
We compare the space efficiency of Prioritized DCI to that

of standard DCI and LSH. As shown in Figure 3 in the
supplementary material, compared to LSH, Prioritized DCI
uses 95.5% less space on CIFAR-100 and 95.3% less space
on MNIST under the same hyperparameter settings used
by standard DCI. This represents a 22-fold reduction in
memory consumption on CIFAR-100 and a 21-fold reduction on MNIST. Under the more space-efficient hyperparameter setting, Prioritized DCI uses 98.2% less space on
CIFAR-100 and 97.9% less space on MNIST relative to
LSH, which represents a 55-fold reduction on CIFAR-100
and a 48-fold reduction on MNIST.
In terms of wall-clock time, our implementation of Prioritized DCI takes 1.18 seconds to construct the data structure
and execute 100 queries on MNIST, compared to 104.71
seconds taken by LSH.

6. Conclusion
In this paper, we presented a new exact randomized algorithm for k-nearest neighbour search, which we refer to as
Prioritized DCI. We showed that Prioritized DCI achieves
a significant improvement in terms of the dependence of
query time complexity on intrinsic dimensionality compared to standard DCI. Specifically, Prioritized DCI can to
a large extent counteract a linear increase in the intrinsic
dimensionality, or equivalently, an exponential increase in
the number of points near a query, using just a linear increase in the number of simple indices. Empirical results
validated the effectiveness of Prioritized DCI in practice,
demonstrating the advantages of Prioritized DCI over prior
methods in terms of speed and memory usage.
Acknowledgements. This work was supported by
DARPA W911NF-16-1-0552. Ke Li thanks the Natural
Sciences and Engineering Research Council of Canada
(NSERC) for fellowship support.

Fast k-Nearest Neighbour Search via Prioritized DCI

References
Anagnostopoulos, Evangelos, Emiris, Ioannis Z, and Psarros, Ioannis. Low-quality dimension reduction and
high-dimensional approximate nearest neighbor. In 31st
International Symposium on Computational Geometry
(SoCG 2015), pp. 436–450, 2015.
Andoni, Alexandr and Indyk, Piotr. Near-optimal hashing
algorithms for approximate nearest neighbor in high dimensions. In Foundations of Computer Science, 2006.
FOCS’06. 47th Annual IEEE Symposium on, pp. 459–
468. IEEE, 2006.
Andoni, Alexandr and Razenshteyn, Ilya. Optimal datadependent hashing for approximate near neighbors. In
Proceedings of the Forty-Seventh Annual ACM on Symposium on Theory of Computing, pp. 793–801. ACM,
2015.
Arya, Sunil and Mount, David M. Approximate nearest
neighbor queries in fixed dimensions. In SODA, volume 93, pp. 271–280, 1993.
Arya, Sunil, Mount, David M, Netanyahu, Nathan S, Silverman, Ruth, and Wu, Angela Y. An optimal algorithm for approximate nearest neighbor searching fixed
dimensions. Journal of the ACM (JACM), 45(6):891–
923, 1998.
Bayer, Rudolf. Symmetric binary b-trees: Data structure
and maintenance algorithms. Acta informatica, 1(4):
290–306, 1972.
Behnam, Ehsan, Waterman, Michael S, and Smith, Andrew D. A geometric interpretation for local alignmentfree sequence comparison. Journal of Computational Biology, 20(7):471–485, 2013.
Bentley, Jon Louis. Multidimensional binary search trees
used for associative searching. Communications of the
ACM, 18(9):509–517, 1975.
Berchtold, Stefan, Keim, Daniel A., and peter Kriegel,
Hans.
The X-tree: An index structure for highdimensional data. In Very Large Data Bases, pp. 28–39,
1996.
Berchtold, Stefan, Ertl, Bernhard, Keim, Daniel A, Kriegel,
H-P, and Seidl, Thomas. Fast nearest neighbor search
in high-dimensional space. In Data Engineering, 1998.
Proceedings., 14th International Conference on, pp.
209–218. IEEE, 1998.
Beygelzimer, Alina, Kakade, Sham, and Langford, John.
Cover trees for nearest neighbor. In Proceedings of
the 23rd International Conference on Machine Learning, pp. 97–104. ACM, 2006.

Biau, Gérard, Chazal, Frédéric, Cohen-Steiner, David, Devroye, Luc, Rodriguez, Carlos, et al. A weighted knearest neighbor density estimate for geometric inference. Electronic Journal of Statistics, 5:204–237, 2011.
Clarkson, Kenneth L. Nearest neighbor queries in metric
spaces. Discrete & Computational Geometry, 22(1):63–
93, 1999.
Dasgupta, Sanjoy and Freund, Yoav. Random projection
trees and low dimensional manifolds. In Proceedings
of the Fortieth Annual ACM Symposium on Theory of
Computing, pp. 537–546. ACM, 2008.
Dasgupta, Sanjoy and Sinha, Kaushik. Randomized partition trees for nearest neighbor search. Algorithmica, 72
(1):237–263, 2015.
Datar, Mayur, Immorlica, Nicole, Indyk, Piotr, and Mirrokni, Vahab S. Locality-sensitive hashing scheme based
on p-stable distributions. In Proceedings of the twentieth annual symposium on Computational geometry, pp.
253–262. ACM, 2004.
Eldawy, Ahmed and Mokbel, Mohamed F. SpatialHadoop:
A MapReduce framework for spatial data. In Data Engineering (ICDE), 2015 IEEE 31st International Conference on, pp. 1352–1363. IEEE, 2015.
Guibas, Leo J and Sedgewick, Robert. A dichromatic
framework for balanced trees. In Foundations of Computer Science, 1978., 19th Annual Symposium on, pp.
8–21. IEEE, 1978.
Guttman, Antonin. R-trees: a dynamic index structure
for spatial searching. In Proceedings of the 1984 ACM
SIGMOD International Conference on Management of
Data, pp. 47–57, 1984.
Houle, Michael E and Nett, Michael. Rank-based similarity
search: Reducing the dimensional dependence. Pattern
Analysis and Machine Intelligence, IEEE Transactions
on, 37(1):136–150, 2015.
Indyk, Piotr and Motwani, Rajeev. Approximate nearest
neighbors: towards removing the curse of dimensionality. In Proceedings of the Thirtieth Annual ACM Symposium on Theory of Computing, pp. 604–613. ACM,
1998.
Jégou, Hervé, Douze, Matthijs, and Schmid, Cordelia.
Product quantization for nearest neighbor search. Pattern Analysis and Machine Intelligence, IEEE Transactions on, 33(1):117–128, 2011.
Karger, David R and Ruhl, Matthias. Finding nearest
neighbors in growth-restricted metrics. In Proceedings
of the Thiry-fourth Annual ACM Symposium on Theory
of Computing, pp. 741–750. ACM, 2002.

Fast k-Nearest Neighbour Search via Prioritized DCI

Krauthgamer, Robert and Lee, James R. Navigating nets:
simple algorithms for proximity search. In Proceedings
of the Fifteenth Annual ACM-SIAM Symposium on Discrete Algorithms, pp. 798–807. Society for Industrial and
Applied Mathematics, 2004.
Krizhevsky, Alex and Hinton, Geoffrey. Learning multiple
layers of features from tiny images. Technical report,
University of Toronto, 2009.
LeCun, Yann, Bottou, Léon, Bengio, Yoshua, and Haffner,
Patrick. Gradient-based learning applied to document
recognition. Proceedings of the IEEE, 86(11):2278–
2324, 1998.
Li, Ke and Malik, Jitendra. Fast k-nearest neighbour search
via Dynamic Continuous Indexing. In International
Conference on Machine Learning, pp. 671–679, 2016.
Liu, Ting, Moore, Andrew W, Yang, Ke, and Gray, Alexander G. An investigation of practical approximate nearest
neighbor algorithms. In Advances in Neural Information
Processing Systems, pp. 825–832, 2004.
Meiser, Stefan. Point location in arrangements of hyperplanes. Information and Computation, 106(2):286–303,
1993.
Minsky, Marvin and Papert, Seymour. Perceptrons: an introduction to computational geometry. pp. 222, 1969.
Orchard, Michael T. A fast nearest-neighbor search algorithm. In Acoustics, Speech, and Signal Processing,
1991. ICASSP-91., 1991 International Conference on,
pp. 2297–2300. IEEE, 1991.
Paulevé, Loı̈c, Jégou, Hervé, and Amsaleg, Laurent. Locality sensitive hashing: A comparison of hash function
types and querying mechanisms. Pattern Recognition
Letters, 31(11):1348–1358, 2010.
Pugh, William. Skip lists: a probabilistic alternative to balanced trees. Communications of the ACM, 33(6):668–
676, 1990.
Weiss, Yair, Torralba, Antonio, and Fergus, Rob. Spectral
hashing. In Advances in Neural Information Processing
Systems, pp. 1753–1760, 2009.

