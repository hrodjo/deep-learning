Rule-Enhanced Penalized Regression by Column Generation
using Rectangular Maximum Agreement

Jonathan Eckstein 1 Noam Goldberg 2 Ai Kagawa 3

Abstract
We describe a procedure enhancing L1 -penalized
regression by adding dynamically generated
rules describing multidimensional ‚Äúbox‚Äù sets.
Our rule-adding procedure is based on the
classical column generation method for highdimensional linear programming. The pricing
problem for our column generation procedure
reduces to the N P-hard rectangular maximum
agreement (RMA) problem of finding a box
that best discriminates between two weighted
datasets. We solve this problem exactly using a parallel branch-and-bound procedure. The
resulting rule-enhanced regression method is
computation-intensive, but has promising prediction performance.

1. Motivation and Overview
This paper considers the general learning problem in which
we have m observation vectors X1 , . . . , Xm ‚àà Rn , with
matching response values y1 , . . . , ym ‚àà R. Each response
yi is a possibly noisy evaluation of an unknown function
f : Rn ‚Üí R at Xi , that is, yi = f (Xi ) + ei , where ei ‚àà
R represents the noise or measurement error. The goal is
to estimate f by some fÀÜ : Rn ‚Üí R such that fÀÜ(Xi ) is
a good fit for yi , that is, |fÀÜ(Xi ) ‚àí yi | tends to be small.
The estimate fÀÜ may then be used to predict the response
value y corresponding to a newly encountered observation
x ‚àà Rn through the prediction yÃÇ = fÀÜ(x). A classical
linear regression model is one simple example of the many
possible techniques one might employ for constructing fÀÜ.
The classical regression approach to this problem is to posit
1
Management Science and Information Systems, Rutgers
University, Piscataway, NJ, USA 2 Department of Management, Bar-Ilan University, Ramat Gan, Israel 3 Doctoral Program in Operations Research, Rutgers University, Piscataway, NJ, USA. Correspondence to: Jonathan Eckstein <jeckstei@business.rutgers.edu>.

Proceedings of the 34 th International Conference on Machine
Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017
by the author(s).

a particular functional form for fÀÜ(x) (for example, an affine
function of x) and then use an optimization procedure to
estimate the parameters in this functional form.
Here, we are interested in cases in which a concise candidate functional form for fÀÜ is not readily apparent, and
we wish to estimate fÀÜ by searching over a very highdimensional space of parameters. For example, Breiman
(2001) proposed the method of random forests, which
constructs fÀÜ by training regression trees on multiple random subsamples of the data, and then averaging the resulting predictors. Another proposal is the RuleFit algorithm (Friedman & Popescu, 2008), which enhances L1 regularized regression by generating box-based rules to use
as additional explanatory variables. Given a, b ‚àà Rn with
a ‚â§ b, the rule function r(a,b) : Rn ‚Üí {0, 1} is given by

r(a,b) (x) = I ‚àßj‚àà{1,...,n} (aj ‚â§ xj ‚â§ bj ) ,

(1)

that is r(a,b) (x) = 1 if a ‚â§ x ‚â§ b (componentwise) and
r(a,b) (x) = 0 otherwise. RuleFit generates rules through a
two-phase procedure: first, it determines a regression tree
ensemble, and then decomposes these trees into rules and
determines the regression model coefficients (including for
the rules).
The approach of DembczynÃÅski et al. (2008a) generates
rules more directly (without having to rely on an initial ensemble of decision trees) within gradient boosting (Friedman, 2001) for non-regularized regression. In this scheme,
a greedy procedure generates the rules within a gradient
descent method runs that for a predetermined number of iterations. Aho et al. (2012) extended the RuleFit method to
solve more general multi-target regression problems. For
the special case of single-target regression, however, their
experiments suggest that random forests and RuleFit outperform several other methods, including their own extended implementation and the algorithm of DembczynÃÅski
et al. (2008a). Compared with random forests and other
popular learning approaches such as kernel-based methods
and neural networks, rule-based approaches have the advantage of generally being considered more accessible and
easier to interpret by domain experts. Rule-based methods
also have a considerable history in classification settings, as
in for example Weiss & Indurkhya (1993), Cohen & Singer

Rule-Enhanced Penalized Regression by Column Generation using Rectangular Maximum Agreement

(1999), and DembczynÃÅski et al. (2008b).
Here, we propose an iterative optimization-based regression procedure called REPR (Rule-Enhanced Penalized
Regression). Its output models resemble those of RuleFit, but our methodology draws more heavily on exact optimization techniques from the field of mathematical programming. While it is quite computationally intensive, its
prediction performance appears promising. As in RuleFit, we start with a linear regression model (in this case,
with L1 -penalized coefficients to promote sparsity), and
enhance it by synthesizing rules of the form (1). We incrementally adjoin such rules to our (penalized) linear regression model as if they were new observation variables.
Unlike RuleFit, we control the generation of new rules using the classical mathematical programming technique of
column generation. Our employment of column generation
roughly resembles its use in the LPBoost ensemble classification method of Demiriz et al. (2002).
Column generation involves cyclical alternation between
optimization of a restricted master problem (in our case
a linear or convex quadratic program) and a pricing problem that finds the most promising new variables to adjoin
to the formulation. In our case, the pricing problem is
equivalent to an N P-hard combinatorial problem we call
Rectangular Maximum Agreement (RMA), which generalizes the Maximum Mononial Agreement (MMA) problem
as formulated and solved by Eckstein & Goldberg (2012).
We solve the RMA problem by a similar branch-and-bound
method procedure, implemented using parallel computing
techniques.
To make our notation below more concise, we let X de>
, and also let
note the matrix whose rows are X1> , . . . , Xm
m
y = (y1 , . . . , ym ) ‚àà R . We may then express a problem instance by the pair (X, y). We also let xij denote the
(i, j)th element of this matrix, that is, the value of variable
j in observation i.

2. A Penalized Regression Model with Rules
Let K be a set of pairs (a, b) ‚àà Rn √ó Rn with a ‚â§ b, constituting a catalog of all the possible rules of the form (1)
that we wish to be available to our regression model. The
set K will typically be extremely large: restricting each
aj and bj to values that appear as xij for some i, which
is sufficient to describe all possible distinct behaviors of
rules of the form (1) on the dataset X, there are still
Q
n
`j (`j + 1)/2 ‚â• 3n possible choices for (a, b), where
j=1 S
m
`j = | i=1 {xij }| is the number of distinct values for xij .
The predictors fÀÜ that our method constructs are of the form

fÀÜ(x) = Œ≤0 +

n
X
j=1

Œ≤j x j +

X

Œ≥k rk (x)

(2)

k‚ààK

for some Œ≤0 , Œ≤1 , . . . , Œ≤n , (Œ≥k )k‚ààK ‚àà R. Finding an fÀÜ of
this form is a matter of linear regression, but with the regression coefficients in a space with the potentially very
high dimension of 1 + n + |K|. As is now customary in regression models in which the number of explanatory variables potentially outnumbers the number of observations,
we employ a LASSO-class model in which all explanatory
variables except the constant term have L1 penalties. Letting Œ≤ = (Œ≤1 , . . . , Œ≤n ) ‚àà Rn and Œ≥ ‚àà R|K| , let fŒ≤0 ,Œ≤,Œ≥ ( ¬∑ )
denote the predictor function in (2). We then propose to
estimate Œ≤0 , Œ≤, Œ≥ by solving
(m
)
X
p
min
|fŒ≤0 ,Œ≤,Œ≥ (Xi ) ‚àí yi | + C kŒ≤k1 + E kŒ≥k1 ,
Œ≤0 ,Œ≤,Œ≥

i=1

(3)
where p ‚àà {1, 2} and C, E ‚â• 0 are scalar parameters. For
p = 2 and C = E > 0, this model is essentially the classic
LASSO as originally proposed by Tibshirani (1996).
To put (3) into a more convenient form for our purposes,
we split the regression coefficient vectors into positive and
negative parts, so Œ≤ = Œ≤ + ‚àí Œ≤ ‚àí and Œ≥ = Œ≥ + ‚àí Œ≥ ‚àí , with
|K|
Œ≤ + , Œ≤ ‚àí ‚àà Rn+ and Œ≥ + , Œ≥ ‚àí ‚àà R+ . Introducing one more
m
vector of variables  ‚àà R , the model shown as (4) in Figure 1 is equivalent to (3). The model is constructed so that
i = |fŒ≤0 ,Œ≤,Œ≥ (Xi ) ‚àí yi | for i = 1, . . . , m. If p = 1, the
model is a linear program, and if p = 2 it is a convex, linearly constrained quadratic program. In either case, there
are 2m constraints (other than nonnegativity), but the number of variables is 1 + m + 2n + 2 |K|.
Because of this potentially unwieldy number of variables,
we propose to solve (4) by using the classical technique
of column generation, which dates back to Ford & Fulkerson (1958) and Gilmore & Gomory (1961); see for example
Section 7.3 of Griva et al. (2009) for a recent textbook treatment. In brief, column generation cycles between solving
two optimization problems, the restricted master problem
and the pricing problem. In our case, the restricted master
problem is the same as (4), but with K replaced by some
(presumably far smaller) K 0 ‚äÜ K. We initially choose
K 0 = ‚àÖ. Solving the restricted master problem yields opm
timal Lagrange multipliers ŒΩ ‚àà Rm
+ and ¬µ ‚àà R+ (for the
constraints other than simple nonnegativity). For each rule
k ‚àà K, these Lagrange multipliers yield respective reduced
costs rc[Œ≥k+ ], rc[Œ≥k‚àí ] for the variables Œ≥k+ , Œ≥k‚àí that are in the
master problem, but not the restricted master. One then
solves the pricing problem, whose job is to identify the
smallest of these reduced costs. The reduced cost rc[v] of a
variable v indicates the rate of change of the objective function as one increases v away from 0. If the smallest reduced

Rule-Enhanced Penalized Regression by Column Generation using Rectangular Maximum Agreement

min

m
X

pi + C

n
X

i=1

(Œ≤j+ + Œ≤j‚àí ) + E

j=1

‚àíŒ≤0 ‚àí Xi> (Œ≤ + ‚àí Œ≤ ‚àí ) ‚àí
‚â•0

(Œ≥k+ + Œ≥k‚àí )

k‚ààK

Œ≤0 + Xi> (Œ≤ + ‚àí Œ≤ ‚àí ) +

s. t.

X

Œ≤+, Œ≤‚àí ‚â• 0

X
k‚ààK
X

rk (Xi )(Œ≥k+ ‚àí Œ≥k‚àí ) ‚àí i ‚â§ yi ,

i = 1, . . . , m

rk (Xi )(Œ≥k+ ‚àí Œ≥k‚àí ) ‚àí i ‚â§ ‚àíyi ,

i = 1, . . . , m

(4)

k‚ààK
‚àí

Œ≥ , Œ≥+ ‚â• 0

Figure 1. Formulation of the REPR master problem, with scalar parameters p ‚àà {1, 2}, C ‚â• 0, and E ‚â• 0. The decision variables are
 ‚àà Rm , Œ≤0 ‚àà R, Œ≤ + , Œ≤ ‚àí ‚àà Rn , and Œ≥ + , Œ≥ ‚àí ‚àà R|K| . The input data are X = [X1 ¬∑ ¬∑ ¬∑ Xm ]> ‚àà Rm√ón and y ‚àà Rm .

cost is nonnegative, then clearly all the reduced costs are
nonnegative, which means that the current restricted master
problem yields an optimal solution to the master problem
by setting Œ≥k+ = Œ≥k‚àí = 0 for all k ‚àà K\K 0 , and the process
terminates. If the smallest reduced cost is negative, we adjoin elements to K 0 , including at least one corresponding
to a variable Œ≥k+ or Œ≥k‚àí with a negative reduced cost, and
we repeat the process, re-solving the expanded restricted
master problem.
In our case, the reduced costs take the form
rc[Œ≥k+ ] = E ‚àí
rc[Œ≥k‚àí ] = E +

m
X

rk (xi )ŒΩi +

m
X

i=1

i=1

m
X

m
X

rk (xi )ŒΩi ‚àí

i=1

rk (xi )¬µi
rk (xi )¬µi

i=1

and hence we have for each k ‚àà K that

m

X

	


+
‚àí
rk (xi )(ŒΩi ‚àí ¬µi ) . (5)
min rc[Œ≥k ], rc[Œ≥k ] = E ‚àí 


i=1

Therefore, the pricing problem may be solved by maximizing the second term on the right-hand side of (5), that is,
finding


m
X



‚àó
z = max 
rk (xi )(ŒΩi ‚àí ¬µi ) ,
(6)

k‚ààK 
i=1

and the stopping condition for the column generation procedure is z ‚àó ‚â§ E. This problem turns out to be equivalent
to the RMA problem, whose formulation and solution we
now describe.

3. The RMA Problem
3.1. Formulation and Input Data
Suppose we have m observations and n explanatory variables, expressed using a matrix X ‚àà Rm√ón as above.
Each observation i ‚àà {1, . . . , m} is assigned a nonegative weight wi ‚àà R+ . For any set S ‚äÜ {1, . . . , m},

P
let w(S) =
i‚ààS wi . We also assume we are given
a partition of the observations into two subsets, a ‚Äúpositive‚Äù subset ‚Ñ¶+ ‚äÇ {1, . . . , m} and a ‚Äúnegative‚Äù subset
‚Ñ¶‚àí = {1, . . . , m}\‚Ñ¶+ .
Given two vectors a, b ‚àà Rn , let B(a, b) denote the ‚Äúbox‚Äù
{x ‚àà Zn | a ‚â§ x ‚â§ b }. Given the input data X, the coverage CvrX (a, b) of B(a, b) consists of the indices of the
observations from X falling within B(a, b), that is,
CvrX (a, b) = {i ‚àà {1, . . . , m} | a ‚â§ Xi ‚â§ b } .
The rectangular maximum agreement (RMA) problem is



max w ‚Ñ¶+ ‚à© CvrX (a, b) ‚àí w ‚Ñ¶‚àí ‚à© CvrX (a, b) 
s.t.
a, b ‚àà Rn ,
(7)
with decision variables a, b ‚àà Rn . Essentially implicit
in this formulation is the constraint that a ‚â§ b, since if
a 6‚â§ b then CvrX (a, b) = ‚àÖ and the objective value is
0. The previously mentioned MMA problem is the special case of RMA in which all the observations are binary, X ‚àà {0, 1}m√ón . Since the MMA problem is N Phard (Eckstein & Goldberg, 2012), so is RMA.
If we take K to be the set of all possible boxes on Rn , the
pricing problem (6) may be reduced to RMA by setting
(‚àÄ i = 1, . . . , m) : wi = |ŒΩi ‚àí ¬µi |

(8)

‚Ñ¶+ = {i ‚àà {1, . . . , m} | ŒΩi ‚â• ¬µi } ,

(9)

‚àí

and thus ‚Ñ¶ = {i ‚àà {1, . . . , m} | ŒΩi < ¬µi }.
3.2. Preprocessing and Restriction to N
Any RMA problem instance may be converted to an equivalent instance in which all the observation data are integer.
Essentially, for each coordinate j = 1, . . . , n, one may simply record the distinct values of xij and replace each xij
with its ordinal position among these values. Algorithm 1,
with its parameter Œ¥ set to 0, performs exactly this procedure, outputing a equivalent data matrix X ‚àà SNm√ón and
m
a vector ` ‚àà Nn whose j th element is `j = | i=1 {xij }|

Rule-Enhanced Penalized Regression by Column Generation using Rectangular Maximum Agreement

Algorithm 1 Preprocessing discretization algorithm
1: Input: X ‚àà Rm√ón , Œ¥ ‚â• 0
2: Output: X ‚àà Nm√ón , ` ‚àà Nn
3: ProcessData
4: for j = 1 to n do
5:
`j ‚Üê 0
6:
Sort x1j , . . . , xmj and set (k1 , . . . , km ) such that
xk1 j ‚â§ xk2 j ‚â§ ¬∑ ¬∑ ¬∑ ‚â§ xkm j
7:
xÃÑk1 ,j ‚Üê 0
8:
for i = 1 to m ‚àí 1 do
9:
if xki+1 j ‚àí xki j > Œ¥ ¬∑ (xkm j ‚àí xk1 j ) then
10:
`j ‚Üê `j + 1
11:
end if
12:
xÃÑki+1 j ‚Üê `j
13:
end for
14:
`j ‚Üê `j + 1
15: end for
16: return (X, `)

as defined in the previous section. Algorithm 1‚Äôs output
values xÃÑij for attribute j vary between 0 and `j ‚àí 1.
The number of distinct values `j of each explanatory variable j directly influences the difficulty of RMA instances.
To obtain easier instances, Algorithm 1 can combine its
‚Äúintegerization‚Äù process with some binning of nearby values. Essentially, if the parameter Œ¥ is positive, the algorithm
bins together consecutive values xij that are within relative
tolerance Œ¥, resulting in a smaller number of distinct values
`j for each explanatory variable j.
Some datasets contain both categorical and numerical data.
In addition to Algorithm 1, we also convert each k-way
categorical attribute into k ‚àí 1 binary attributes.
Within the context of our REPR regression method, we set
the RMA weight vector and data partition as in (8)-(9), integerize the data X using Algorithm 1 with some (small)
parameter value Œ¥, solve the RMA problem, and then translate the resulting boxes back to the original, pre-integerized
coordinate system. We perform this translation by expanding box boundaries to lie halfway between the boundaries
of the clusters of points grouped by Algorithm 1, except
when the lower boundary of the box has the lowest possible value or the upper boundary has the largest possible
value. In these cases, we expand the box boundaries to
‚àí‚àû or +‚àû, respectively. More precisely, for each observation variable j and v ‚àà {0, . . . , `j ‚àí 1}, let xmin
j,v be the
smallest value of xij assigned to the integer value v by Aln
gorithm 1, and xmax
j,v be the largest. If aÃÇ, bÃÇ ‚àà N , aÃÇ ‚â§ bÃÇ
describe an integerized box arising from the solution of the
preprocessed RMA problem, we choose the corresponding
box boundaries a, b ‚àà Rn in the original coordinate system

to be given by, for j = 1, . . . , n,
(
‚àí‚àû,
aj = 1 max
min
2 (xj,aÃÇj ‚àí1 + xj,aÃÇj ),
(
+‚àû,
bj = 1 max
min
2 (xj,bÃÇ + xj,bÃÇ +1 ),
j

if aÃÇj = 0
otherwise
if bÃÇj = `j ‚àí 1
otherwise.

j

Overall, our procedure is equivalent to solving the pricing
problem (6) over some set of boxes K = KŒ¥ (X). For
Œ¥ = 0, the resulting set of boxes K0 (X) is such that the corresponding set of rules {rk | k ‚àà K0 (X) } comprises every box-based rule distinguishable on the dataset X. For
small positive values of Œ¥, the set of boxes KŒ¥ (X) excludes those corresponding to rules that ‚Äúcut‚Äù between very
closely spaced observations.
3.3. Branch-and-Bound Subproblems
In this and the following two subsections, we describe the
key elements of our branch-and-bound procedure for solving the RMA problem, assuming that the data X have already been preprocessed as above. For brevity, we omit
some details which will instead be covered in a forthcoming publication. For general background on branch-andbound algorithms, Morrison et al. (2016) provide a recent
survey with numerous citations.
Branch-and-bound methods search a tree of subproblems,
each describing some subset of the search space. In our
RMA method, each subproblem P is characterized by
four vectors a(P ), a(P ), b(P ), b(P ) ‚àà Nn , and represents
search space subset consisting of vector pairs (a, b) for
which a(P ) ‚â§ a ‚â§ a(P ) and b(P ) ‚â§ b ‚â§ b(P ). Any valid
subproblem conforms to a(P ) ‚â§ a(P ), b(P ) ‚â§ b(P ),
a(P ) ‚â§ b(P ), and a(P ) ‚â§ b(P ). The root problem R
of the branch-and-bound tree is R = (0, ` ‚àí 1, 0, ` ‚àí 1),
where where ` ‚àà Nn is as output from Algorithm 1, and
0 and 1 respectively denote the vectors (0, 0, . . . , 0) ‚àà Nn
and (1, 1, . . . , 1) ‚àà Nn .
3.4. Inseparability and the Bounding Function
In branch-and-bound methods, the bounding function provides an upper bound (when maximizing) on the best possible objective value in the region of the search space corresponding to a subproblem. Our bounding function is based
on an extension of the notion of inseparability developed
by Eckstein & Goldberg (2012). Consider any subproblem
P = (a, a, b, b) and two observations i and i0 . If xij = xi0 j
or aj ‚â§ xij , xi0 j ‚â§ bj for each j = 1, . . . , n, then
xi , xi0 ‚àà Nn are inseparable with respect to a, b ‚àà Nn ,
in the sense that any box B(a, b) with a ‚â§ a and b ‚â• b
must either cover both of xi , xi0 or neither of them.
Inseparability with respect to a, b is an equivalence relation,

Rule-Enhanced Penalized Regression by Column Generation using Rectangular Maximum Agreement

X


 Ô£º
w(C ‚à© CvrX (a, b) ‚à© ‚Ñ¶+ ) ‚àí w(C ‚à© CvrX (a, b) ‚à© ‚Ñ¶‚àí ) + ,Ô£¥
Ô£¥
Ô£Ω
C‚ààE(a,b)
X 

Œ≤(a, a, b, b) = max
.
Ô£¥
w(C ‚à© CvrX (a, b) ‚à© ‚Ñ¶‚àí ) ‚àí w(C ‚à© CvrX (a, b) ‚à© ‚Ñ¶+ ) + Ô£¥
Ô£¥
Ô£¥
Ô£≥
Ô£æ
Ô£±
Ô£¥
Ô£¥
Ô£≤

(10)

C‚ààE(a,b)

Figure 2. The RMA bounding function.

and we denote the equivalence classes it induces among the
observation indices 1, . . . , m by E(a, b). That is, observation indices i and i0 are in the same equivalence class of
E(a, b) if xi and xi0 are inseparable with respect to a, b.
Our bounding function Œ≤(a, a, b, b) for each subproblem
P = (a, a, b, b) is shown in (10) in Figure 2. The reasoning
behind this bound is that each possible box in the set specified by (a, a, b, b) must either cover or not cover the entirety
of each C ‚àà E(a, b). The first argument to the ‚Äúmax‚Äù operation reflects the situation that every equivalence class C
with a positive net weight is covered, and no classes with
negative net weight are covered; this is the best possible
situation if the box ends up covering a higher weight of
positive observations than of negative. The second ‚Äúmax‚Äù
argument reflects the opposite situation, the best possible
case in which the box covers a greater weight of negative
observations than of positive ones.
3.5. Branching
The branching scheme of a branch-and-bound algorithm
divides subproblems into smaller ones in order to improve their bounds. In our case, branching a subproblem
P = (a, a, b, b) involves choosing an explanatory variable
j ‚àà {1, . . . , n} and a cutpoint v ‚àà {aj , . . . , bj ‚àí 1} ‚àà Nn .
There are three possible cases, the first of which is when
bj < aj and v ‚àà {bj , . . . , aj ‚àí 1}. In this case, our scheme
creates three children based on the disjunction that either
bj ‚â§ v ‚àí 1 (the box lies below v), aj ‚â§ v ‚â§ bj (the box
straddles v), or aj ‚â• v + 1 (the box lies above
	 v). The next
case is that v ‚àà aj , . . . , min{aj , bj } ‚àí 1 , in which case
the box cannot lie below v and we split P into two children based on the disjunction that either aj ‚â§ v (the box
straddles v) or aj ‚â• v+ 1 (the box is above v).	 The third
case occurs when v ‚àà max{aj , bj }, . . . , bj ‚àí1 , in which
case we split P into two children based on the disjunction
that either bj ‚â§ v (the box is does not extend above v) or
bj ‚â• v + 1 (the box extends above v). If no v falling under
one of these three cases exists for any dimension j, then the
subproblem represents a single possible box, that is, a = a
and b = b. Such a subproblem is a terminal node of the
branch-and-bound tree, and in this case we simply compute
the RMA objective value for a = a = a and b = b = b as
the subproblem bound.

When more than one possible variable-cutpoint pair (j, v)
exists, as is typically the case, our algorithm must select one. We use two related procedures for branching selection: strong branching and cutpoint caching. In
strong branching, we simply experiment with all applicable
variable-cutpoint pairs (j, v), and select one that the maximizes the minimum bound of the resulting two or three
children. This is a standard technique in branch-and-bound
algorithms, and involves evaluating the bounds of all the
potential children of the current search node. To make this
process as efficient as possible, we have developed specialized data structures for manipulating equivalence classes,
and we analyze the branching possibilities in a particular
order. In cutpoint caching, some subproblems use strong
branching, while others select from a list of cutpoints that
were chosen by strong branching for previously processed
search nodes. The details of these procedures will be covered in a forthcoming companion publication.

4. Full Algorithm and Implementation
The pseudocode in Algorithm 2 describes our full REPR
column generation procedure for solving (4), using the
RMA preprocessing and branch-and-bound methods described above to solve the pricing problem. Several points
bear mentioning: first, the nonnegative scalar parameter Œ∏
allows us to incorporate a tolerance into the column generation stopping criterion, so that we terminate when all
reduced costs exceed ‚àíŒ∏ instead of when all reduced costs
are nonnegative. This kind of tolerance is customary in
column generation methods. The tolerance Œ¥, on the other
hand, controls the space of columns searched over. Furthermore, our implementation of the RMA branch-and-bound
algorithm can identify any desired number t ‚â• 1 of the best
possible RMA solutions, as opposed to just one value of k
attaining the maximum in (11). This t is also a parameter to
our procedure, so at each iteration of Algorithm 2 we may
adjoin up to t new rules to K 0 . Adding multiple columns
per iteration is a common technique in column generation
methods. Finally, the algorithm has a parameter S specifying a limit on the number of column generation iterations,
meaning that at the output model will contain at most St
rules.
We implemented the algorithm in C++, using the GuRoBi

Rule-Enhanced Penalized Regression by Column Generation using Rectangular Maximum Agreement

Algorithm 2 REPR: Rule-enhanced penalized regression
1: Input: data X ‚àà Rm√ón , y ‚àà Rm , penalty parameters
C, E ‚â• 0, column generation tolerance Œ∏ ‚â• 0, integer
t ‚â• 1, aggregation tolerance Œ¥ ‚â• 0, iteration limit S
0
2: Output: Œ≤0 ‚àà R, Œ≤ ‚àà Rn , K 0 ‚äÇ KŒ¥ (X), Œ≥ ‚àà R|K |
3: REPR
4: K 0 ‚Üê ‚àÖ
5: for s = 1, . . . , S do
6:
Solve the restricted master problem to obtain optimal primal variables (Œ≤0 , Œ≤ + , Œ≤ ‚àí , Œ≥ + , Œ≥ ‚àí ) and dual
variables (ŒΩ, ¬µ)
7:
Use the RMA branch-and-bound algorithm, with
preprocessing as in Algorithm 1, to identify a t-best
solution k1 , . . . , kt to


m
X



(11)
rk (xi )(ŒΩi ‚àí ¬µi ) ,
max 

k‚ààKŒ¥ (X) 
i=1

8:
9:
10:
11:
12:
13:

with k1 , . . . , kt having respective objective values
z1 ‚â• z2 ‚â• ¬∑ ¬∑ ¬∑ ‚â• zt
if z1 ‚â§ E + Œ∏ break
for each l ‚àà {1, . . . , t} with zl > E + Œ∏ do
K 0 ‚Üê K 0 ‚à™ {kl }
end for
end for
return (Œ≤0 , Œ≤ := Œ≤ + ‚àí Œ≤ ‚àí , K 0 , Œ≥ := Œ≥ + ‚àí Œ≥ ‚àí )

commercial optimizer (Gurobi Optimization, 2016) to
solve the restricted master problems. We implemented
the RMA algorithm using using the PEBBL C++ class library (Eckstein et al., 2015), an open-source C++ framework for parallel branch and bound. PEBBL employs MPIbased parallelism (Gropp et al., 1994). Since solving the
RMA pricing problem is by far the most time-consuming
part of Algorithm 2, we used true parallel computing only
in that portion of the algorithm. The remainder of the algorithm, including solving the restricted master problems,
was executed in serial and redundantly on all processors.

5. Preliminary Testing of REPR
For preliminary testing of REPR, we selected 8 datasets
from the UCI repository (Lichman, 2013), choosing small
datasets with continuous response variables. The first four
columns of Table 1 summarize the number of observations
m, the number of attributes n, and the maximum number
of distinguishable box-based rules |K0 (X)| for these data
sets.
In our initial testing, we focused on the p = 2 case in which
fitting errors are penalized quadratically, and set t = 1, that
is, we added one model rule per REPR iteration. We set the
iteration limit S to 100 and effectively set the termination

REPR
RMA
Dataset
m
n |K0 (X)|
Time
Nodes
SERVO
167 10
9.8e05 0:00:11 3.6e2
CONCRETE 103 9
2.7e29 0:29:51 3.0e5
MACHINE
209 6
2.5e15 0:03:07 5.6e4
YACHT
308 6
2.6e10 0:00:36 5.3e2
MPG
392 7
3.3e19 13:09:58 2.4e6
COOL
768 8
1.1e10 0:04:48 3.7e3
HEAT
768 8
1.1e10 0:03:42 3.9e3
AIRFOIL
1503 5
1.0e11 2:13:04 5.1e3
Table 1. Summary of experimental datasets. The last two columns
respectively show REPR‚Äôs average run time for an 80% sample of
the dataset (on a 16-core workstation, in hh:mm:ss format) and the
average resulting number of RMA search nodes per RMA invocation.

tolerance Œ∏ so that REPR terminated when

	
z1 ‚â§ max 0, E ¬∑ |E[y]| ‚àí 0.1œÉ[y] + 0.001,
where E[y] denotes the sample mean of the response variable and œÉ[y] its sample standard deviation. We found this
rule of thumb to work well in pracice, but it likely merits
further study. We also chose C = 1 and E = 1. We used
Œ¥ = 0 for SERVO, YACHT, and MPG, and Œ¥ = 0.005 for
the remaining datasets.
With the fixed parameters given above, we tested REPR
and some competing regression procedures on ten different randomly-chosen partitions of each dataset; each partition consists of 80% training data and 20% testing data.
The competing procedures are RuleFit, random forests,
LASSO, and classical linear regression. The penalty parameter in LASSO is the same as the value of C chosen for
REPR. To implement RuleFit and random forests, we used
their publicly available R packages. Table 2 shows the averages of the resulting mean square errors and Table 3 shows
their standard deviations. REPR has the smallest average
MSE for 5 of the 8 datasets and has the second smallest average MSE on the remaining 3 datasets, coming very close
to random forests on MPG. For the standard deviation of
the MSE, which we take as a general measure of prediction stability, REPR has the lowest values for 6 of the 8
datasets. The box plots in Figures 3 and 4 visualize these
results in more detail for HEAT and MACHINE, respectively. Figure 5 displays the average MSEs in a bar-chart
format, with the MSE of REPR normalized to 1.
Figures 6-9 give more detailed information for specific
datasets. Figure 6 and 7 respectively show how REPR‚Äôs
prediction MSEs for HEAT and CONCRETE evolve with
each iteration, with each data point averaged over the 10
different REPR runs; the horizontal lines indicate the average MSE level for the competing procedures. MSE generally declines as REPR adds rules, although some diminish-

Rule-Enhanced Penalized Regression by Column Generation using Rectangular Maximum Agreement

Method Dataset:
REPR
RuleFit
Random forests
Lasso
Linear regression

SERVO
0.08228
0.10053
0.24305
0.67362
0.67723

CONCRETE
0.00447
0.00736
0.01348
0.00573
0.00573

MACHINE
0.37128
0.97250
0.55456
0.48776
0.48776

YACHT
0.00630
0.00571
0.13343
0.74694
0.74455

MPG
0.01380
0.01430
0.01348
0.01981
0.02073

COOL
0.00218
0.00094
0.00302
0.01757
0.01708

HEAT
0.00220
0.01063
0.00544
0.01694
0.01581

AIRFOIL
0.00030
0.00032
0.00083
0.00150
0.00149

Table 2. Average MSE over the experimental datasets. The smallest value in each column is bolded.

Method Dataset:
REPR
RuleFit
Random forests
Lasso
Linear regression

SERVO
0.03196
0.05173
0.07554
0.15302
0.15814

CONCRETE
0.00220
0.00188
0.00521
0.00255
0.00255

MACHINE
0.14625
0.65957
0.31717
0.24303
0.24303

YACHT
0.00186
0.00287
0.04922
0.10380
0.09806

MPG
0.00213
0.00430
0.00403
0.00300
0.00251

COOL
0.00091
0.00007
0.00044
0.00270
0.00251

HEAT
0.00043
0.01453
0.00055
0.00145
0.00192

AIRFOIL
0.00006
0.00011
0.00006
0.00010
0.00010

Table 3. Standard deviation of MSE over the experimental datasets. The smallest value in each column is bolded.

The last two columns of Table 1 show, for a 16-core Xeon
E5-2660 workstation, REPR‚Äôs average total run time per
data partition and the average number of search node per
invocation of RMA. The longer runs could likely be accelerated by the application of more parallel processors.

3.0
2.5
2.0
MSE

ing returns are evident for CONCRETE. Interestingly, neither of these figures shows appreciable evidence of overfitting by REPR, even when large numbers of rules are incorporated into the model. Figures 8 and 9 display testing-set
predictions for specific (arbitrarily chosen) partitions of the
MACHINE and CONCRETE datasets, respectively, with
the observations sorted by response value. REPR seems
to outperform the other methods in predicting extreme response values, although it is somewhat worse than the other
methods at predicting non-extreme values for MACHINE.

1.5
1.0
0.5
0.0

REPR

RuleFit

Random
Forests

LASSO

Linear
Regression

Figure 4. MSE box plots of for the MACHINE data set.

0.06

6. Conclusions and Future Research

0.05

The results presented here suggest that REPR has significant potential as a regression tool, at least for small
datasets. Clearly, it should be tested on more datasets and
larger datasets.

MSE

0.04
0.03
0.02
0.01
0.00

REPR

RuleFit

Random
Forests

LASSO

Linear
Regression

Figure 3. MSE box plots of for the HEAT data set.

Here, we have tested REPR using fixed values of most of
its parameters, and we expect we should be able to improve
its performance by using intelligent heuristics or crossvalidation procedures to select key parameters such as C
and E. Improved preprocessing may also prove helpful: judicious normalization of the input data (X, y) should assist
in finding good parameter choices, and we are also working
on more sophisticated discretization technique for preprocessing the RMA solver input, as well as branch selection
heuristics that are more efficient for large `j .

Rule-Enhanced Penalized Regression by Column Generation using Rectangular Maximum Agreement
5

4

0.012

3

REPR
RuleFit
Random Forests
Linear Regression

0.010
MSE

Relative MSE

0.014

REPR
RuleFit
Random Forests

2

0.008

1

0.006
IL
IR

FO

EA

0.004

A

H

CO

T

L
O

PG
M

T
CH

IN

E
A
Y

CH
A

Dataset

M

CR
CO

N

SE

RV

O

ET
E

0

Figure 5. Comparison the average MSEs, with the MSE of REPR
normalized to 1. The random forest value for YACHT is truncated.

0

20

40

60

80

100

Iterations

Figure 7. MSE as a function of iterations for the CONCRETE
dataset.

0.018

1200

0.014

1000

MSE

0.012

REPR
RuleFit
Random Forests
Linear Regression

0.010
0.008
0.006

Response value

0.016

0.004
0.002

0

20

40

60

80

Response
REPR
RuleFit
Random Forests

800
600
400
200
0

100

Iterations

‚àí200

0

5

10

15

Figure 6. MSE as a function of iterations for the HEAT dataset.

20
25
Observation

30

35

40

Figure 8. Sorted predictions for the MACHINE data set.

For problems with large numbers of observations m, it
is conceivable that solving the restricted master problems
could become a serial bottleneck in our current implementation strategy. If this phenomenon is observed in practice,
it could be worth investigating parallel solution strategies
for the restricted master.

50
Response
REPR
RuleFit
Random Forests

45
Response value

It would be interesting to see how well REPR performs if
the pricing problems are solved less exactly. For example,
one could use various techniques for truncating the branchand-bound search, such as setting a limit on the number of
subproblems explored or loosening the conditions for pruning unpromising subtrees. Or one could use, perhaps selectively, some entirely heuristic procedure to identify rules to
add to the restricted master problem.

40
35
30
25
20
15

0

5

10
Observation

15

20

Figure 9. Sorted predictions for the CONCRETE data set.

Rule-Enhanced Penalized Regression by Column Generation using Rectangular Maximum Agreement

References
Aho, Timo, ZÃåenko, Bernard, DzÃåeroski, SasÃåo, and Elomaa,
Tapio. Multi-target regression with rule ensembles. J.
Mach. Learn. Res., 13(Aug):2367‚Äì2407, 2012.
Breiman, Leo. Random forests. Mach. Learn., 45:5‚Äì32,
2001.
Cohen, William W. and Singer, Yoram. A simple, fast, and
effective rule learner. In Proc. of the 16th Nat. Conf. on
Artificial Intelligence, pp. 335‚Äì342, 1999.
DembczynÃÅski, Krzysztof, Kot≈Çowski, Wojciech, and
S≈ÇowinÃÅski, Roman. Solving regression by learning an
ensemble of decision rules. In International Conference
on Artificial Intelligence and Soft Computing, 2008, volume 5097 of Lecture Notes in Artificial Intelligence, pp.
533‚Äì544. Springer-Verlag, 2008a.
DembczynÃÅski, Krzysztof, Kot≈Çowski, Wojciech, and
S≈ÇowinÃÅski, Roman. Maximum likelihood rule ensembles. In Proceedings of the 25th International Conference on Machine Learning, ICML ‚Äô08, pp. 224‚Äì231,
New York, NY, USA, 2008b. ACM.
Demiriz, Ayhan, Bennett, Kristin P., and Shawe-Taylor,
John. Linear programming boosting via column generation. Mach. Learn., 46(1-3):225‚Äì254, 2002.
Eckstein, Jonathan and Goldberg, Noam.
An improved branch-and-bound method for maximum monomial agreement. INFORMS J. Comput., 24(2):328‚Äì341,
2012.
Eckstein, Jonathan, Hart, William E., and Phillips, Cynthia A. PEBBL: an object-oriented framework for scalable parallel branch and bound. Math. Program. Comput., 7(4):429‚Äì469, 2015.
Ford, Jr., Lester R. and Fulkerson, David R. A suggested computation for maximal multi-commodity network flows. Manage. Sci., 5:97‚Äì101, 1958.

Friedman, Jerome H. Greedy function approximation: a
gradient boosting machine. Ann. of Stat., pp. 1189‚Äì1232,
2001.
Friedman, Jerome H. and Popescu, Bogdan E. Predictive
learning via rule ensembles. Ann. Appl. Stat., 2(3):916‚Äì
954, 2008.
Gilmore, Paul C. and Gomory, Ralph E. A linear programming approach to the cutting-stock problem. Oper. Res.,
9:849‚Äì859, 1961.
Griva, Igor, Nash, Stephen G., and Sofer, Ariela. Linear and Nonlinear Optimization. SIAM, second edition,
2009.
Gropp, William, Lusk, Ewing, and Skjellum, Anthony.
Using MPI: Portable Parallel Programming with the
Message-Passing Interface. MIT Press, 1994.
Gurobi Optimization, Inc. Gurobi optimizer reference
manual, 2016. URL http://www.gurobi.com/
documentation/7.0/refman/index.html.
Lichman, Moshe. UCI machine learning repository, 2013.
URL http://archive.ics.uci.edu/ml.
Morrison, David R., Jacobson, Sheldon H., Sauppe, Jason J., and Sewell, Edward C. Branch-and-bound algorithms: a survey of recent advances in searching, branching, and pruning. Discrete Optim., 19(C):79‚Äì102, 2016.
Tibshirani, Robert. Regression shrinkage and selection via
the lasso. J. R. Statist. Soc. B, 58(1):267‚Äì288, 1996.
Weiss, Sholom M. and Indurkhya, Nitin. Optimized rule
induction. IEEE Expert, 8(6):61‚Äì69, 1993.

