Understanding Black-box Predictions via Influence Functions
Pang Wei Koh 1 Percy Liang 1

Abstract
How can we explain the predictions of a blackbox model? In this paper, we use influence functions ‚Äî a classic technique from robust statistics ‚Äî to trace a model‚Äôs prediction through the
learning algorithm and back to its training data,
thereby identifying training points most responsible for a given prediction. To scale up influence
functions to modern machine learning settings,
we develop a simple, efficient implementation
that requires only oracle access to gradients and
Hessian-vector products. We show that even on
non-convex and non-differentiable models where
the theory breaks down, approximations to influence functions can still provide valuable information. On linear models and convolutional neural networks, we demonstrate that influence functions are useful for multiple purposes: understanding model behavior, debugging models, detecting dataset errors, and even creating visuallyindistinguishable training-set attacks.

1. Introduction
A key question often asked of machine learning systems
is ‚ÄúWhy did the system make this prediction?‚Äù We want
models that are not just high-performing but also explainable. By understanding why a model does what it does, we
can hope to improve the model (Amershi et al., 2015), discover new science (Shrikumar et al., 2016), and provide
end-users with explanations of actions that impact them
(Goodman & Flaxman, 2016).
However, the best-performing models in many domains ‚Äî
e.g., deep neural networks for image and speech recognition (Krizhevsky et al., 2012) ‚Äî are complicated, blackbox models whose predictions seem hard to explain. Work
on interpreting these black-box models has focused on understanding how a fixed model leads to particular predictions, e.g., by locally fitting a simpler model around the test
1

Stanford University, Stanford, CA. Correspondence to:
Pang Wei Koh <pangwei@cs.stanford.edu>, Percy Liang <pliang@cs.stanford.edu>.
Proceedings of the 34 th International Conference on Machine
Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017
by the author(s).

point (Ribeiro et al., 2016) or by perturbing the test point to
see how the prediction changes (Simonyan et al., 2013; Li
et al., 2016b; Datta et al., 2016; Adler et al., 2016). These
works explain the predictions in terms of the model, but
how can we explain where the model came from?
In this paper, we tackle this question by tracing a model‚Äôs
predictions through its learning algorithm and back to the
training data, where the model parameters ultimately derive from. To formalize the impact of a training point on a
prediction, we ask the counterfactual: what would happen
if we did not have this training point, or if the values of this
training point were changed slightly?
Answering this question by perturbing the data and retraining the model can be prohibitively expensive. To overcome
this problem, we use influence functions, a classic technique from robust statistics (Cook & Weisberg, 1980) that
tells us how the model parameters change as we upweight
a training point by an infinitesimal amount. This allows us
to ‚Äúdifferentiate through the training‚Äù to estimate in closedform the effect of a variety of training perturbations.
Despite their rich history in statistics, influence functions
have not seen widespread use in machine learning; to the
best of our knowledge, the work closest to ours is Wojnowicz et al. (2016), which introduced a method for approximating a quantity related to influence in generalized
linear models. One obstacle to adoption is that influence functions require expensive second derivative calculations and assume model differentiability and convexity,
which limits their applicability in modern contexts where
models are often non-differentiable, non-convex, and highdimensional. We address these challenges by showing that
we can efficiently approximate influence functions using
second-order optimization techniques (Pearlmutter, 1994;
Martens, 2010; Agarwal et al., 2016), and that they remain
accurate even as the underlying assumptions of differentiability and convexity degrade.
Influence functions capture the core idea of studying models through the lens of their training data. We show that
they are a versatile tool that can be applied to a wide variety
of seemingly disparate tasks: understanding model behavior, debugging models, detecting dataset errors, and creating visually-indistinguishable adversarial training examples that can flip neural network test predictions, the training set analogue of Goodfellow et al. (2015).

Understanding Black-box Predictions via Influence Functions

2. Approach

2.2. Perturbing a training input

Consider a prediction problem from some input space X
(e.g., images) to an output space Y (e.g., labels). We are
given training points z1 , . . . , zn , where zi = (xi , yi ) ‚àà
X √ó Y. For a point z and P
parameters Œ∏ ‚àà Œò, let
n
L(z, Œ∏) be the loss, and let n1 i=1 L(zi , Œ∏) be the empirical risk. The empirical risk minimizer is given by
Pn
def
Œ∏ÃÇ = arg minŒ∏‚ààŒò n1 i=1 L(zi , Œ∏).1 Assume that the empirical risk is twice-differentiable and strictly convex in Œ∏;
in Section 4 we explore relaxing these assumptions.

Let us develop a finer-grained notion of influence by studying a different counterfactual: how would the model‚Äôs predictions change if a training input were modified?

2.1. Upweighting a training point
Our goal is to understand the effect of training points on a
model‚Äôs predictions. We formalize this goal by asking the
counterfactual: how would the model‚Äôs predictions change
if we did not have this training point?
Let us begin by studying the change in model parameters due to removing a point z from the training set. Formally, this change is Œ∏ÃÇ‚àíz ‚àí Œ∏ÃÇ, where
P
def
Œ∏ÃÇ‚àíz = arg minŒ∏‚ààŒò zi 6=z L(zi , Œ∏). However, retraining
the model for each removed z is prohibitively slow.
Fortunately, influence functions give us an efficient approximation. The idea is to compute the parameter change if z
were upweighted by some small , giving us new paramPn
def
eters Œ∏ÃÇ,z = arg minŒ∏‚ààŒò n1 i=1 L(zi , Œ∏) + L(z, Œ∏). A
classic result (Cook & Weisberg, 1982) tells us that the influence of upweighting z on the parameters Œ∏ÃÇ is given by
dŒ∏ÃÇ,z 
(1)
= ‚àíHŒ∏ÃÇ‚àí1 ‚àáŒ∏ L(z, Œ∏ÃÇ),

d =0
Pn
def
where HŒ∏ÃÇ = n1 i=1 ‚àá2Œ∏ L(zi , Œ∏ÃÇ) is the Hessian and is
positive definite (PD) by assumption. In essence, we form
a quadratic approximation to the empirical risk around Œ∏ÃÇ
and take a single Newton step; see appendix A for a derivation. Since removing a point z is the same as upweighting
it by  = ‚àí n1 , we can linearly approximate the parameter change due to removing z by computing Œ∏ÃÇ‚àíz ‚àí Œ∏ÃÇ ‚âà
‚àí n1 Iup,params (z), without retraining the model.
def

Iup,params (z) =

Next, we apply the chain rule to measure how upweighting
z changes functions of Œ∏ÃÇ. In particular, the influence of
upweighting z on the loss at a test point ztest again has a
closed-form expression:
dL(ztest , Œ∏ÃÇ,z ) 
(2)

d
=0
dŒ∏ÃÇ,z 
= ‚àáŒ∏ L(ztest , Œ∏ÃÇ)>

d =0
= ‚àí‚àáŒ∏ L(ztest , Œ∏ÃÇ)> HŒ∏ÃÇ‚àí1 ‚àáŒ∏ L(z, Œ∏ÃÇ).
def

Iup,loss (z, ztest ) =

1

We fold in any regularization terms into L.

def

For a training point z = (x, y), define zŒ¥ = (x + Œ¥, y).
Consider the perturbation z 7‚Üí zŒ¥ , and let Œ∏ÃÇzŒ¥ ,‚àíz be the
empirical risk minimizer on the training points with zŒ¥ in
place of z. To approximate its effects, define the parameters
def
resulting from P
moving  mass from z onto zŒ¥ : Œ∏ÃÇ,zŒ¥ ,‚àíz =
n
1
arg minŒ∏‚ààŒò n i=1 L(zi , Œ∏) + L(zŒ¥ , Œ∏) ‚àí L(z, Œ∏). An
analogous calculation to (1) yields:
dŒ∏ÃÇ,zŒ¥ ,‚àíz 
= Iup,params (zŒ¥ ) ‚àí Iup,params (z)

d
=0

= ‚àíHŒ∏ÃÇ‚àí1 ‚àáŒ∏ L(zŒ¥ , Œ∏ÃÇ) ‚àí ‚àáŒ∏ L(z, Œ∏ÃÇ) . (3)
As before, we can make the linear approximation Œ∏ÃÇzŒ¥ ,‚àíz ‚àí
Œ∏ÃÇ ‚âà ‚àí n1 (Iup,params (zŒ¥ ) ‚àí Iup,params (z)), giving us a closedform estimate of the effect of z 7‚Üí zŒ¥ on the model. Analogous equations also apply for changes in y. While influence functions might appear to only work for infinitesimal (therefore continuous) perturbations, it is important to
note that this approximation holds for arbitrary Œ¥: the upweighting scheme allows us to smoothly interpolate between z and zŒ¥ . This is particularly useful for working with
discrete data (e.g., in NLP) or with discrete label changes.
If x is continuous and Œ¥ is small, we can further approximate (3). Assume that the input domain X ‚äÜ Rd , the parameter space Œò ‚äÜ Rp , and L is differentiable in Œ∏ and x.
As kŒ¥k ‚Üí 0, ‚àáŒ∏ L(zŒ¥ , Œ∏ÃÇ) ‚àí ‚àáŒ∏ L(z, Œ∏ÃÇ) ‚âà [‚àáx ‚àáŒ∏ L(z, Œ∏ÃÇ)]Œ¥,
where ‚àáx ‚àáŒ∏ L(z, Œ∏ÃÇ) ‚àà Rp√ód . Substituting into (3),
dŒ∏ÃÇ,zŒ¥ ,‚àíz 
‚âà ‚àíHŒ∏ÃÇ‚àí1 [‚àáx ‚àáŒ∏ L(z, Œ∏ÃÇ)]Œ¥.

d
=0

(4)

We thus have Œ∏ÃÇzŒ¥ ,‚àíz ‚àí Œ∏ÃÇ ‚âà ‚àí n1 HŒ∏ÃÇ‚àí1 [‚àáx ‚àáŒ∏ L(z, Œ∏ÃÇ)]Œ¥. Differentiating w.r.t. Œ¥ and applying the chain rule gives us

def

Ipert,loss (z, ztest )> = ‚àáŒ¥ L(ztest , Œ∏ÃÇzŒ¥ ,‚àíz )> 
(5)
Œ¥=0

= ‚àí‚àáŒ∏ L(ztest , Œ∏ÃÇ)> HŒ∏ÃÇ‚àí1 ‚àáx ‚àáŒ∏ L(z, Œ∏ÃÇ).
Ipert,loss (z, ztest )> Œ¥ tells us the approximate effect that z 7‚Üí
z + Œ¥ has on the loss at ztest . By setting Œ¥ in the direction of
Ipert,loss (z, ztest ), we can construct local perturbations of z
that maximally increase the loss at ztest . In Section 5.2, we
will use this to construct training-set attacks. Finally, we
note that Ipert,loss (z, ztest ) can help us identify the features
of z that are most responsible for the prediction on ztest .
2.3. Relation to Euclidean distance
To find the training points most relevant to a test point, it
is common to look at its nearest neighbors in Euclidean

Understanding Black-box Predictions via Influence Functions

Figure 1. Components of influence. (a) What is the effect of the training loss and HŒ∏ÃÇ‚àí1 terms in Iup,loss ? Here, we plot Iup,loss against
variants that are missing these terms and show that they are necessary for picking up the truly influential training points. For these
calculations, we use logistic regression to distinguish 1‚Äôs from 7‚Äôs in MNIST (LeCun et al., 1998), picking an arbitrary test point ztest ;
similar trends hold across other test points. Green dots are train images of the same label as the test image (7) while red dots are 1‚Äôs.
Left: Without the train loss term, we overestimate the influence of many training points: the points near the y=0 line should have
Iup,loss close to 0, but instead have high influence when we remove the train loss term. Mid: Without HŒ∏ÃÇ‚àí1 , all green training points are
helpful (removing each point increases test loss) and all red points are harmful (removing each point decreases test loss). This is because
‚àÄx, x  0 (all pixel values are positive), so x ¬∑ xtest ‚â• 0, but it is incorrect: many harmful training points actually share the same label as
ztest . See panel (b). Right: Without training loss or HŒ∏ÃÇ‚àí1 , what is left is the scaled Euclidean inner product ytest y ¬∑ œÉ(‚àíytest Œ∏> xtest ) ¬∑ x>
test x,
which fails to accurately capture influence; the scatter plot deviates quite far from the diagonal. (b) The test image and a harmful training
image with the same label. To the model, they look very different, so the presence of the training image makes the model think that the
test image is less likely to be a 7. The Euclidean inner product does not pick up on these less intuitive, but important, harmful influences.

space (e.g., Ribeiro et al. (2016)); if all points have the
same norm, this is equivalent to choosing x with the largest
x ¬∑ xtest . For intuition, we compare this to Iup,loss (z, ztest ) on
a logistic regression model and show that influence is much
more accurate at accounting for the effect of training.
Let p(y | x) = œÉ(yŒ∏> x), with y ‚àà {‚àí1, 1} and œÉ(t) =
1
1+exp(‚àít) . We seek to maximize the probability of the
training set. For a training point z = (x, y), L(z, Œ∏) =
>
>
log(1 + exp(‚àíyŒ∏
x)yx,
Pn x)), >‚àáŒ∏ L(z, Œ∏)> = ‚àíœÉ(‚àíyŒ∏
1
>
and HŒ∏ = n i=1 œÉ(Œ∏ xi )œÉ(‚àíŒ∏ xi )xi xi . From (2),
Iup,loss (z, ztest ) is:
‚àí1
‚àíytest y ¬∑ œÉ(‚àíytest Œ∏> xtest ) ¬∑ œÉ(‚àíyŒ∏> x) ¬∑ x>
test HŒ∏ÃÇ x.

We highlight two key differences from x ¬∑ xtest . First,
œÉ(‚àíyŒ∏> x) gives points with high training loss more influence, revealing that outliers can dominate the model parameters. Second, the weighted covariance matrix HŒ∏ÃÇ‚àí1
measures the ‚Äúresistance‚Äù of the other training points to the
removal of z; if ‚àáŒ∏ L(z, Œ∏ÃÇ) points in a direction of little
variation, its influence will be higher since moving in that
direction will not significantly increase the loss on other
training points. As we show in Fig 1, these differences
mean that influence functions capture the effect of model
training much more accurately than nearest neighbors.

is too expensive for models like deep neural networks with
millions of parameters. Second, we often want to calculate
Iup,loss (zi , ztest ) across all training points zi .
The first problem is well-studied in second-order optimization. The idea is to avoid explicitly computing HŒ∏ÃÇ‚àí1 ; instead, we use implicit Hessian-vector products (HVPs) to
def
efficiently approximate stest = HŒ∏ÃÇ‚àí1 ‚àáŒ∏ L(ztest , Œ∏ÃÇ) and then
compute Iup,loss (z, ztest ) = ‚àístest ¬∑ ‚àáŒ∏ L(z, Œ∏ÃÇ). This also
solves the second problem: for each test point of interest, we can precompute stest and then efficiently compute
‚àístest ¬∑ ‚àáŒ∏ L(zi , Œ∏ÃÇ) for each training point zi .
We discuss two techniques for approximating stest , both
relying on the fact that the HVP of a single term in HŒ∏ÃÇ ,
[‚àá2Œ∏ L(zi , Œ∏ÃÇ)]v, can be computed for arbitrary v in the same
time that ‚àáŒ∏ L(zi , Œ∏ÃÇ) would take, which is typically O(p)
(Pearlmutter, 1994).

3. Efficiently Calculating Influence

Conjugate gradients (CG). The first technique is a standard transformation of matrix inversion into an optimization problem. Since HŒ∏ÃÇ  0 by assumption, HŒ∏ÃÇ‚àí1 v ‚â°
arg mint { 21 t> HŒ∏ÃÇ t ‚àí v > t}. We can solve this with CG
approaches that only require the evaluation of HŒ∏ÃÇ t, which
takes O(np) time, without explicitly forming HŒ∏ÃÇ . While an
exact solution takes p CG iterations, in practice we can get
a good approximation with fewer iterations; see Martens
(2010) for more details.

There are two computational challenges to using
Iup,loss (z, ztest ) = ‚àí‚àáŒ∏ L(ztest , Œ∏ÃÇ)> HŒ∏ÃÇ‚àí1 ‚àáŒ∏ L(z, Œ∏ÃÇ). First, it
Pn
requires forming and inverting HŒ∏ÃÇ = n1 i=1 ‚àá2Œ∏ L(zi , Œ∏ÃÇ),
the Hessian of the empirical risk. With n training points
and Œ∏ ‚àà Rp , this requires O(np2 + p3 ) operations, which

Stochastic estimation. With large datasets, standard CG
can be slow; each iteration still goes through all n training points. We use a method developed by Agarwal et al.
(2016) to get an estimator that only samples a single point
per iteration, which results in significant speedups.

Understanding Black-box Predictions via Influence Functions
def Pj
Dropping the Œ∏ÃÇ subscript for clarity, let Hj‚àí1 = i=0 (I ‚àí
H)i , the first j terms in the Taylor expansion of H ‚àí1 .
‚àí1
Rewrite this recursively as Hj‚àí1 = I + (I ‚àí H)Hj‚àí1
.
‚àí1
‚àí1
From the validity of the Taylor expansion, Hj ‚Üí H as
j ‚Üí ‚àû.2 The key is that at each iteration, we can substitute the full H with a draw from any unbiased (and fasterto-compute) estimator of H to form HÃÉj . Since E[HÃÉj‚àí1 ] =
Hj‚àí1 , we still have E[HÃÉj‚àí1 ] ‚Üí H ‚àí1 .

In particular, we can uniformly sample zi and use
‚àá2Œ∏ L(zi , Œ∏ÃÇ) as an unbiased estimator of H. This gives
us the following procedure: uniformly sample t points
zs1 , . . . , zst from the training data; define HÃÉ0‚àí1 v =
v; and recursively compute HÃÉj‚àí1 v = v + I ‚àí
 ‚àí1
‚àá2Œ∏ L(zsj , Œ∏ÃÇ) HÃÉj‚àí1
v, taking HÃÉt‚àí1 v as our final unbiased estimate of H ‚àí1 v. We pick t to be large enough such that HÃÉt
stabilizes, and to reduce variance we repeat this procedure
r times and average results. Empirically, we found this significantly faster than CG.
We note that the original method of Agarwal et al. (2016)
dealt only with generalized linear models, for which
[‚àá2Œ∏ L(zi , Œ∏ÃÇ)]v can be efficiently computed in O(p) time.
In our case, we rely on Pearlmutter (1994)‚Äôs more general
algorithm for fast HVPs, described above, to achieve the
same time complexity.3
With these techniques, we can compute Iup,loss (zi , ztest )
on all training points zi in O(np + rtp) time; we show in
Section 4.1 that empirically, choosing rt = O(n) gives accurate results. Similarly, we compute Ipert,loss (zi , ztest )> =
with
two
‚àí n1 ‚àáŒ∏ L(ztest , Œ∏ÃÇ)> HŒ∏ÃÇ‚àí1 ‚àáx ‚àáŒ∏ L(zi , Œ∏ÃÇ)
matrix-vector products: we first compute stest , then
s>
These
test ‚àáx ‚àáŒ∏ L(zi , Œ∏ÃÇ), with the same HVP trick.
computations are easy to implement in auto-grad systems
like TensorFlow (Abadi et al., 2015) and Theano (Theano
D. Team, 2016), as users need only specify L; the rest is
automatically handled.

4. Validation and Extensions
Recall that influence functions are asymptotic approximations of leave-one-out retraining under the assumptions that
(i) the model parameters Œ∏ÃÇ minimize the empirical risk,
and that (ii) the empirical risk is twice-differentiable and
2

‚àÄi, ‚àá2Œ∏ L(zi , Œ∏ÃÇ)

We assume w.l.o.g. that
4 I; if this is not
true, we can scale the loss down without affecting the parameters.
In some cases, we can get an upper bound on ‚àá2Œ∏ L(zi , Œ∏ÃÇ) (e.g., for
linear models and bounded input), which makes this easy. Otherwise, we treat the scaling as a separate hyperparameter and tune
it such that the Taylor expansion converges.
3
To increase stability, especially with non-convex models (see
Section 4.2), we can also sample a mini-batch of training points
at each iteration, instead of relying on a single training point.

Figure 2. Influence matches leave-one-out retraining. We arbitrarily picked a wrongly-classified test point ztest , but this trend
held more broadly. These results are from 10-class
 MNIST. Left:

For each of the 500 training points z with largest Iup,loss (z, ztest ),
we plotted ‚àí n1 ¬∑ Iup,loss (z, ztest ) against the actual change in test
loss after removing that point and retraining. The inverse HVP
was solved exactly with CG. Mid: Same, but with the stochastic
approximation. Right: The same plot for a CNN, computed on
the 100 most influential points with CG. For the actual difference
in loss, we removed each point and retrained from Œ∏ÃÉ for 30k steps.

strictly convex. Here, we empirically show that influence
functions are accurate approximations (Section 4.1) that
provide useful information even when these assumptions
are violated (Sections 4.2, 4.3).
4.1. Influence functions vs. leave-one-out retraining
Influence functions assume that the weight on a training
point is changed by an infinitesimally small . To investigate the accuracy of using influence functions to approximate the effect of removing a training point and retraining, we compared ‚àí n1 Iup,loss (z, ztest ) with L(ztest , Œ∏ÃÇ‚àíz ) ‚àí
L(ztest , Œ∏ÃÇ) (i.e., actually doing leave-one-out retraining).
With a logistic regression model on 10-class MNIST,4 the
predicted and actual changes matched closely (Fig 2-Left).
The stochastic approximation from Agarwal et al. (2016)
was also accurate with r = 10 repeats and t = 5, 000 iterations (Fig 2-Mid). Since each iteration only requires one
HVP [‚àá2Œ∏ L(zi , Œ∏ÃÇ)]v, this runs quickly: in fact, we accurately estimated H ‚àí1 v without even looking at every data
point, since n = 55, 000 > rt. Surprisingly, even r = 1
worked; while results were noisier, it was still able to identify the most influential points.
4.2. Non-convexity and non-convergence
In Section 2, we took Œ∏ÃÇ as the global minimum. In practice,
if we obtain our parameters Œ∏ÃÉ by running SGD with early
stopping or on non-convex objectives, Œ∏ÃÉ 6= Œ∏ÃÇ. As a result,
HŒ∏ÃÉ could have negative eigenvalues. We show that influence functions on Œ∏ÃÉ still give meaningful results in practice.
Our approach is to form a convex quadratic approximation of the loss around Œ∏ÃÉ, i.e., LÃÉ(z, Œ∏) = L(z, Œ∏ÃÉ) +
4
We trained with L-BFGS (Liu & Nocedal, 1989), with L2
regularization of 0.01, n = 55, 000, and p = 7, 840 parameters.

Understanding Black-box Predictions via Influence Functions

Figure 3. Smooth approximations to the hinge loss. (a) By varying t, we can approximate the hinge loss with arbitrary accuracy: the
green and blue lines are overlaid on top of each other. (b) Using a random, wrongly-classified test point, we compared the predicted
vs. actual differences in loss after leave-one-out retraining onP
the 100 most influential training points. A similar trend held for other test
points. The SVM objective is to minimize 0.005 kwk22 + n1 i Hinge(yi w> xi ). Left: Influence functions were unable to accurately
predict the change, overestimating its magnitude considerably. Mid: Using SmoothHinge(¬∑, 0.001) let us accurately predict the change
in the hinge loss after retraining. Right: Correlation remained high over a wide range of t, though it degrades when t is too large. When
t = 0.001, Pearson‚Äôs R = 0.95; when t = 0.1, Pearson‚Äôs R = 0.91.

‚àáL(z, Œ∏ÃÉ)> (Œ∏ ‚àí Œ∏ÃÉ)+ 12 (Œ∏ ‚àí Œ∏ÃÉ)> (HŒ∏ÃÉ +ŒªI)(Œ∏ ‚àí Œ∏ÃÉ). Here, Œª is
a damping term that we add if HŒ∏ÃÉ has negative eigenvalues;
this corresponds to adding L2 regularization on Œ∏. We then
calculate Iup,loss using LÃÉ. If Œ∏ÃÉ is close to a local minimum,
this is correlated with the result of taking a Newton step
from Œ∏ÃÉ after removing  weight from z (see appendix B).
We checked the behavior of Iup,loss in a non-convergent,
non-convex setting by training a convolutional neural network for 500k iterations.5 The model had not converged
and HŒ∏ÃÉ was not PD, so we added a damping term with
Œª = 0.01. Even in this difficult setting, the predicted and
actual changes in loss were highly correlated (Pearson‚Äôs R
= 0.86, Fig 2-Right).
4.3. Non-differentiable losses
What happens when the derivatives of the loss, ‚àáŒ∏ L and
‚àá2Œ∏ L, do not exist? In this section, we show that influence functions computed on smooth approximations to
non-differentiable losses can predict the behavior of the
original, non-differentiable loss under leave-one-out retraining. The robustness of this approximation suggests
that we can train non-differentiable models and swap out
non-differentiable components for smoothed versions for
the purposes of calculating influence.
To see this, we trained a linear SVM on the same 1s
vs. 7s MNIST task in Section 2.3. This involves min5

The network had 7 sets of convolutional layers with tanh(¬∑)
non-linearities, modeled after the all-convolutional network from
(Springenberg et al., 2014). For speed, we used 10% of the
MNIST training set and only 2,616 parameters, since repeatedly
retraining the network was expensive. Training was done with
mini-batches of 500 examples and the Adam optimizer (Kingma
& Ba, 2014). The model had not converged after 500k iterations;
training it for another 500k iterations, using a full training pass
for each iteration, reduced train loss from 0.14 to 0.12.

imizing Hinge(s) = max(0, 1 ‚àí s); this simple piecewise linear function is similar to ReLUs, which cause nondifferentiability in neural networks. We set the derivatives at the hinge to 0 and calculated Iup,loss . As one
might expect, this was inaccurate (Fig 3b-Left): the second derivative carries no information about how close a
support vector z is to the hinge, so the quadratic approximation of L(z, Œ∏ÃÇ) is linear (up to regularization), which
leads to Iup,loss (z, ztest ) overestimating the influence of z.
For the purposes of calculating influence, we approximated
Hinge(s) with SmoothHinge(s, t) = t log(1+exp( 1‚àís
t )),
which approaches the hinge loss as t ‚Üí 0 (Fig 3a). Using
the same SVM weights as before, we found that calculating Iup,loss using SmoothHinge(s, 0.001) closely matched
the actual change due to retraining in the original Hinge(s)
(Pearson‚Äôs R = 0.95; Fig 3b-Mid) and remained accurate
over a wide range of t (Fig 3b-Right).

5. Use Cases of Influence Functions
5.1. Understanding model behavior
By telling us the training points ‚Äúresponsible‚Äù for a given
prediction, influence functions reveal insights about how
models rely on and extrapolate from the training data. In
this section, we show that two models can make the same
correct predictions but get there in very different ways.
We compared (a) the state-of-the-art Inception v3 network
(Szegedy et al., 2016) with all but the top layer frozen6 to
(b) an SVM with an RBF kernel on a dog vs. fish image
classification dataset we extracted from ImageNet (Russakovsky et al., 2015), with 900 training examples for each
class. Freezing neural networks in this way is not uncom6

We used pre-trained weights from Keras (Chollet, 2015).

Understanding Black-box Predictions via Influence Functions

mon in computer vision and is equivalent to training a logistic regression model on the bottleneck features (Donahue et al., 2014). We picked a test image both models
got correct (Fig 4-Top) and used SmoothHinge(¬∑, 0.001)
to compute the influence for the SVM.
As expected, Iup,loss in the RBF SVM varied inversely with
raw pixel distance, with training images far from the test
image in pixel space having almost no influence. The Inception influences were much less correlated with distance
in pixel space (Fig 4-Left). Looking at the two most helpful images (most positive ‚àíIup,loss ) for each model in Fig
4-Right, we see that the Inception network picked up on the
distinctive characteristics of clownfish, whereas the RBF
SVM pattern-matched training images superficially.
Moreover, in the RBF SVM, fish (green points) close to
the test image were mostly helpful, while dogs (red) were
mostly harmful, with the RBF acting as a soft nearest
neighbor function (Fig 4-Left). In contrast, in the Inception network, fish and dogs could be helpful or harmful for
correctly classifying the test image as a fish; in fact, some
of the most helpful training images were dogs that, to the
model, looked very different from the test fish (Fig 4-Top).

Figure 4. Inception vs.
RBF SVM. Bottom left:
‚àíIup,loss (z, ztest ) vs. kz ‚àí ztest k22 . Green dots are fish and
red dots are dogs. Bottom right: The two most helpful training
images, for each model, on the test. Top right: An image of a
dog in the training set that helped the Inception model correctly
classify the test image as a fish.

5.2. Adversarial training examples
In this section, we show that models that place a lot of influence on a small number of points can be vulnerable to
training input perturbations, posing a serious security risk
in real-world ML systems where attackers can influence the
training data (Huang et al., 2011). Recent work has generated adversarial test images that are visually indistinguish-

able from real test images but completely fool a classifier
(Goodfellow et al., 2015; Moosavi-Dezfooli et al., 2016).
We demonstrate that influence functions can be used to
craft adversarial training images that are similarly visuallyindistinguishable and can flip a model‚Äôs prediction on a separate test image. To the best of our knowledge, this is the
first proof-of-concept that visually-indistinguishable training attacks can be executed on otherwise highly-accurate
neural networks.
The key idea is that Ipert,loss (z, ztest ) tells us how to modify training point z to most increase the loss on ztest .
Concretely, for a target test image ztest , we can construct
zÃÉi , an adversarial version of a training image zi , by initializing zÃÉi := zi and then iterating zÃÉi := Œ†(zÃÉi +
Œ± sign(Ipert,loss (zÃÉi , ztest ))), where Œ± is the step size and Œ†
projects onto the set of valid images that share the same 8bit representation with zi . After each iteration, we retrain
the model. This is an iterated, training-set analogue of the
methods used by, e.g., Goodfellow et al. (2015); MoosaviDezfooli et al. (2016) for test-set attacks.
We tested these training attacks on the same Inception network on dogs vs. fish from Section 5.1, choosing this pair
of animals to provide a stark contrast between the classes.
We set Œ± = 0.02 and ran the attack for 100 iterations
on each test image. As before, we froze all but the top
layer for training; note that computing Ipert,loss still involves
differentiating through the entire network. Originally, the
model correctly classified 591 / 600 test images. For each
of these 591 test images, considered separately, we tried to
find a visually-indistinguishable perturbation (i.e., same 8bit representation) to a single training image, out of 1,800
total training images, that would flip the model‚Äôs prediction. We were able to do this on 335 (57%) of the 591
test images. By perturbing 2 training images for each test
image, we could flip predictions on 77% of the 591 test images; and if we perturbed 10 training images, we could flip
all but 1 of the 591. The above results are from attacking
each test image separately, i.e., using a different training set
to attack each test image. We also tried to attack multiple
test images simultaneously by increasing their average loss,
and found that single training image perturbations could simultaneously flip multiple test predictions as well (Fig 5).
We make three observations about these attacks. First,
though the change in pixel values is small, the change in
the final Inception feature layer is significantly larger: using L2 distance in pixel space, the training values change
by less than 1% of the mean distance of a training point to
its class centroid, whereas in Inception feature space, the
change is on the same order as the mean distance. This
leaves open the possibility that our attacks, while visuallyimperceptible, can be detected by examining the feature
space. Second, the attack tries to perturb the training ex-

Understanding Black-box Predictions via Influence Functions
Figure 5. Training-set attacks.
We targeted a
set of 30 test images featuring the first author‚Äôs
dog in a variety of poses
and backgrounds.
By
maximizing the average
loss over these 30 images, we created a visuallyimperceptible change to
the particular training image (shown on top) that
flipped predictions on 16
test images.

ample in a direction of low variance, causing the model to
overfit in that direction and consequently incorrectly classify the test images; we expect attacking to be harder as
the number of training examples grows. Third, ambiguous
or mislabeled training images are effective points to attack:
the model has low confidence and thus high loss on them,
making them highly influential (recall Section 2.3). For example, the image in Fig 5 contains both a dog and a fish and
is highly ambiguous; as a result, it is the training example
that the model is least confident on (with a confidence of
77%, compared to the next lowest confidence of 90%).
This attack is mathematically equivalent to the gradientbased training set attacks explored by Biggio et al. (2012);
Mei & Zhu (2015b) and others in the context of different
models. Biggio et al. (2012) constructed a dataset poisoning attack against a linear SVM on a two-class MNIST task,
but had to modify the training points in an obviously distinguishable way to be effective. Measuring the magnitude of
Ipert,loss gives model developers a way of quantifying how
vulnerable their models are to training-set attacks.
5.3. Debugging domain mismatch
Domain mismatch ‚Äî where the training distribution does
not match the test distribution ‚Äî can cause models with
high training accuracy to do poorly on test data (Ben-David
et al., 2010). We show that influence functions can identify
the training examples most responsible for the errors, helping model developers identify domain mismatch.

3 out of the 24 children under age 10 in this dataset were
re-admitted. To induce a domain mismatch, we filtered out
20 children who were not re-admitted, leaving 3 out of 4 readmitted. This caused the model to wrongly classify many
children in the test set. Our aim is to identify the 4 children
in the training set as being ‚Äúresponsible‚Äù for these errors.
As a baseline, we tried the common practice of looking at
the learned parameters Œ∏ÃÇ to see if the indicator variable for
being a child was obviously different. However, this did
not work: 14/127 features had a larger coefficient.
Picking a random child ztest that the model got wrong, we
calculated ‚àíIup,loss (zi , ztest ) for each training point zi . This
clearly highlighted the 4 training children, each of whom
were 30-40 times as influential as the next most influential
examples. The 1 child in the training set who was not readmitted had a very positive influence, while the other 3 had
very negative influences. Moreover, calculating Ipert,loss on
these 4 children showed that the ‚Äòchild‚Äô indicator variable
contributed significantly to the magnitude of Iup,loss .
5.4. Fixing mislabeled examples
Labels in the real world are often noisy, especially if crowdsourced (FreÃÅnay & Verleysen, 2014), and can even be adversarially corrupted. Even if a human expert could recognize wrongly labeled examples, it is impossible in many
applications to manually review all of the training data. We
show that influence functions can help human experts prioritize their attention, allowing them to inspect only the examples that actually matter.

As a case study, we predicted whether a patient would be
readmitted to hospital. Domain mismatches are common
in biomedical data, e.g., different hospitals serve different
populations, and models trained on one population can do
poorly on another (Kansagara et al., 2011). We used logistic regression to predict readmission with a balanced training dataset of 20K diabetic patients from 100+ US hospitals, each represented by 127 features (Strack et al., 2014).7

The key idea is to flag the training points that exert the
most influence on the model. Because we do not have access to the test set, we measure the influence of zi with
Iup,loss (zi , zi ), which approximates the error incurred on zi
if we remove zi from the training set.

7
Hospital readmission was defined as whether a patient would
be readmitted within the next 30 days. Features were demo-

graphic (e.g., age, race, gender), administrative (e.g., length of
hospital stay), or medical (e.g., test results).

Our case study is email spam classification, which relies

Understanding Black-box Predictions via Influence Functions

on user-provided labels and is also vulnerable to adversarial attack (Biggio et al., 2011). We flipped the labels of a
random 10% of the training data and then simulated manually inspecting a fraction of the training points, correcting
them if they had been flipped. Using influence functions
to prioritize the training points to inspect allowed us to repair the dataset (Fig 6, blue) without checking too many
points, outperforming the baselines of checking points with
the highest train loss (Fig 6, green) or at random (Fig 6,
red). No method had access to the test data.

Figure 6. Fixing mislabeled examples. Plots of how test accuracy (left) and the fraction of flipped data detected (right) change
with the fraction of train data checked, using different algorithms
for picking points to check. Error bars show the std. dev. across
40 repeats of this experiment, with a different subset of labels
flipped in each; error bars on the right are too small to be seen.
These results are on the Enron1 spam dataset (Metsis et al., 2006),
with 4,147 training and 1,035 test examples; we trained logistic
regression on a bag-of-words representation of the emails.

6. Related Work
The use of influence-based diagnostics originated in statistics in the 70s and 80s, driven by seminal papers by Cook
and others (Cook, 1977; Cook & Weisberg, 1980; 1982),
though similar ideas appeared even earlier in other forms,
e.g., the infinitesimal jackknife (Jaeckel, 1972). Earlier
work focused on removing training points from linear models, with later work extending this to more general models
and a wider variety of perturbations (Cook, 1986; Thomas
& Cook, 1990; Chatterjee & Hadi, 1986; Wei et al., 1998).
Most of this prior work focused on experiments with small
datasets, e.g., n = 24 and p = 10 in Cook & Weisberg
(1980), with special attention therefore paid to exact solutions, or if not possible, characterizations of the error terms.
Influence functions have not been used much in the ML
literature, with some exceptions. Christmann & Steinwart (2004); Debruyne et al. (2008); Liu et al. (2014) use
influence functions to study model robustness and to do
fast cross-validation in kernel methods. Wojnowicz et al.
(2016) uses matrix sketching to estimate Cook‚Äôs distance,
which is closely related to influence; they focus on prioritizing training points for human attention and derive meth-

ods specific to generalized linear models.
As noted in Section 5.2, our training-set attack is mathematically equivalent to an approach first explored by Biggio et al. (2012) in the context of SVMs, with follow-up
work extending the framework and applying it to linear
and logistic regression (Mei & Zhu, 2015b), topic modeling (Mei & Zhu, 2015a), and collaborative filtering (Li
et al., 2016a). These papers derived the attack directly from
the KKT conditions without considering influence, though
for continuous data, the end result is equivalent. Influence functions additionally let us consider attacks on discrete data (Section 2.2), but we have not tested this empirically. Our work connects the literature on trainingset attacks with work on ‚Äúadversarial examples‚Äù (Goodfellow et al., 2015; Moosavi-Dezfooli et al., 2016), visuallyimperceptible perturbations on test inputs.
In contrast to training-set attacks, Cadamuro et al. (2016)
consider the task of taking an incorrect test prediction and
finding a small subset of training data such that changing
the labels on this subset makes the prediction correct. They
provide a solution for OLS and Gaussian process models
when the labels are continuous. Our work with influence
functions allow us to solve this problem in a much larger
range of models and in datasets with discrete labels.

7. Discussion
We have discussed a variety of applications, from creating training-set attacks to debugging models and fixing
datasets. Underlying each of these applications is a common tool, the influence function, which is based on a simple idea ‚Äî we can better understand model behavior by
looking at how it was derived from its training data.
At their core, influence functions measure the effect of local changes: what happens when we upweight a point by
an infinitesimally-small ? This locality allows us to derive efficient closed-form estimates, and as we show, they
can be surprisingly effective. However, we might want to
ask about more global changes, e.g., how does a subpopulation of patients from this hospital affect the model? Since
influence functions depend on the model not changing too
much, how to tackle this is an open question.
It seems inevitable that high-performing, complex, blackbox models will become increasingly prevalent and important. We hope that the approach presented here ‚Äî of looking at the model through the lens of the training data ‚Äî
will become a standard part of the toolkit of developing,
understanding, and diagnosing machine learning.
The code and data for replicating our experiments is available on GitHub http://bit.ly/gt-influence
and Codalab http://bit.ly/cl-influence.

Understanding Black-box Predictions via Influence Functions

Acknowledgements

Chollet, F. Keras, 2015.

We thank Jacob Steinhardt, Zhenghao Chen, and Hongseok
Namkoong for helpful discussions and comments. This
work was supported by a Future of Life Research Award
and a Microsoft Research Faculty Fellowship.

Christmann, A. and Steinwart, I. On robustness properties
of convex risk minimization methods for pattern recognition. Journal of Machine Learning Research (JMLR),
5(0):1007‚Äì1034, 2004.

References

Cook, R. D. Detection of influential observation in linear
regression. Technometrics, 19:15‚Äì18, 1977.

Abadi, M., Agarwal, A., Barham, P., Brevdo, E., Chen, Z.,
Citro, C., Corrado, G. S., Davis, A., Dean, J., Devin, M.,
Ghemawat, S., Goodfellow, I. J., Harp, A., Irving, G.,
Isard, M., Jia, Y., JoÃÅzefowicz, R., Kaiser, L., Kudlur, M.,
Levenberg, J., ManeÃÅ, D., Monga, R., Moore, S., Murray, D. G., Olah, C., Schuster, M., Shlens, J., Steiner,
B., Sutskever, I., Talwar, K., Tucker, P. A., Vanhoucke,
V., Vasudevan, V., VieÃÅgas, F. B., Vinyals, O., Warden, P.,
Wattenberg, M., Wicke, M., Yu, Y., and Zheng, X. Tensorflow: Large-scale machine learning on heterogeneous
distributed systems. arXiv preprint arXiv:1603.04467,
2015.
Adler, P., Falk, C., Friedler, S. A., Rybeck, G., Scheidegger, C., Smith, B., and Venkatasubramanian, S. Auditing
black-box models for indirect influence. arXiv preprint
arXiv:1602.07043, 2016.

Cook, R. D. Assessment of local influence. Journal of the
Royal Statistical Society. Series B (Methodological), pp.
133‚Äì169, 1986.
Cook, R. D. and Weisberg, S. Characterizations of an empirical influence function for detecting influential cases
in regression. Technometrics, 22:495‚Äì508, 1980.
Cook, R. D. and Weisberg, S. Residuals and influence in
regression. New York: Chapman and Hall, 1982.
Datta, A., Sen, S., and Zick, Y. Algorithmic transparency
via quantitative input influence: Theory and experiments
with learning systems. In Security and Privacy (SP),
2016 IEEE Symposium on, pp. 598‚Äì617, 2016.

Agarwal, N., Bullins, B., and Hazan, E. Second order
stochastic optimization in linear time. arXiv preprint
arXiv:1602.03943, 2016.

Debruyne, M., Hubert, M., and Suykens, J. A. Model selection in kernel based regression using the influence function. Journal of Machine Learning Research (JMLR), 9
(0):2377‚Äì2400, 2008.

Amershi, S., Chickering, M., Drucker, S. M., Lee, B.,
Simard, P., and Suh, J. Modeltracker: Redesigning performance analysis tools for machine learning. In Conference on Human Factors in Computing Systems (CHI),
pp. 337‚Äì346, 2015.

Donahue, J., Jia, Y., Vinyals, O., Hoffman, J., Zhang, N.,
Tzeng, E., and Darrell, T. Decaf: A deep convolutional
activation feature for generic visual recognition. In International Conference on Machine Learning (ICML), volume 32, pp. 647‚Äì655, 2014.

Ben-David, S., Blitzer, J., Crammer, K., Kulesza, A.,
Pereira, F., and Vaughan, J. W. A theory of learning
from different domains. Machine Learning, 79(1):151‚Äì
175, 2010.

FreÃÅnay, B. and Verleysen, M. Classification in the presence
of label noise: a survey. IEEE Transactions on Neural
Networks and Learning Systems, 25:845‚Äì869, 2014.

Biggio, B., Nelson, B., and Laskov, P. Support vector machines under adversarial label noise. ACML, 20:97‚Äì112,
2011.
Biggio, B., Nelson, B., and Laskov, P. Poisoning attacks
against support vector machines. In International Conference on Machine Learning (ICML), pp. 1467‚Äì1474,
2012.

Goodfellow, I. J., Shlens, J., and Szegedy, C. Explaining
and harnessing adversarial examples. In International
Conference on Learning Representations (ICLR), 2015.
Goodman, B. and Flaxman, S. European union regulations
on algorithmic decision-making and a ‚Äúright to explanation‚Äù. arXiv preprint arXiv:1606.08813, 2016.

Cadamuro, G., Gilad-Bachrach, R., and Zhu, X. Debugging machine learning models. In ICML Workshop on
Reliable Machine Learning in the Wild, 2016.

Huang, L., Joseph, A. D., Nelson, B., Rubinstein, B. I., and
Tygar, J. Adversarial machine learning. In Proceedings
of the 4th ACM workshop on Security and artificial intelligence, pp. 43‚Äì58, 2011.

Chatterjee, S. and Hadi, A. S. Influential observations, high
leverage points, and outliers in linear regression. Statistical Science, pp. 379‚Äì393, 1986.

Jaeckel, L. A. The infinitesimal jackknife. Unpublished memorandum, Bell Telephone Laboratories, Murray Hill, NJ, 1972.

Understanding Black-box Predictions via Influence Functions

Kansagara, D., Englander, H., Salanitro, A., Kagen, D.,
Theobald, C., Freeman, M., and Kripalani, S. Risk prediction models for hospital readmission: a systematic review. JAMA, 306(15):1688‚Äì1698, 2011.

Ribeiro, M. T., Singh, S., and Guestrin, C. ‚Äùwhy should
I trust you?‚Äù: Explaining the predictions of any classifier. In International Conference on Knowledge Discovery and Data Mining (KDD), 2016.

Kingma, D. and Ba, J. Adam: A method for stochastic
optimization. arXiv preprint arXiv:1412.6980, 2014.

Russakovsky, O., Deng, J., Su, H., Krause, J., Satheesh, S.,
Ma, S., Huang, Z., Karpathy, A., Khosla, A., Bernstein,
M., et al. ImageNet large scale visual recognition challenge. International Journal of Computer Vision, 115(3):
211‚Äì252, 2015.

Krizhevsky, A., Sutskever, I., and Hinton, G. E. Imagenet
classification with deep convolutional neural networks.
In Advances in Neural Information Processing Systems
(NIPS), pp. 1097‚Äì1105, 2012.
LeCun, Y., Bottou, L., Bengio, Y., and Haffner, P. Gradientbased learning applied to document recognition. Proceedings of the IEEE, 86(11):2278‚Äì2324, 1998.
Li, B., Wang, Y., Singh, A., and Vorobeychik, Y. Data poisoning attacks on factorization-based collaborative filtering. In Advances in Neural Information Processing Systems (NIPS), 2016a.
Li, J., Monroe, W., and Jurafsky, D. Understanding neural
networks through representation erasure. arXiv preprint
arXiv:1612.08220, 2016b.
Liu, D. C. and Nocedal, J. On the limited memory BFGS
method for large scale optimization. Mathematical Programming, 45(1):503‚Äì528, 1989.
Liu, Y., Jiang, S., and Liao, S. Efficient approximation
of cross-validation for kernel methods using Bouligand
influence function. In International Conference on Machine Learning (ICML), pp. 324‚Äì332, 2014.
Martens, J. Deep learning via hessian-free optimization. In
International Conference on Machine Learning (ICML),
pp. 735‚Äì742, 2010.
Mei, S. and Zhu, X. The security of latent Dirichlet allocation. In Artificial Intelligence and Statistics (AISTATS),
2015a.
Mei, S. and Zhu, X. Using machine teaching to identify
optimal training-set attacks on machine learners. In Association for the Advancement of Artificial Intelligence
(AAAI), 2015b.
Metsis, V., Androutsopoulos, I., and Paliouras, G. Spam filtering with naive Bayes ‚Äì which naive Bayes? In CEAS,
volume 17, pp. 28‚Äì69, 2006.
Moosavi-Dezfooli, S., Fawzi, A., and Frossard, P. Deepfool: a simple and accurate method to fool deep neural
networks. In Computer Vision and Pattern Recognition
(CVPR), pp. 2574‚Äì2582, 2016.
Pearlmutter, B. A. Fast exact multiplication by the hessian.
Neural Computation, 6(1):147‚Äì160, 1994.

Shrikumar, A., Greenside, P., Shcherbina, A., and Kundaje, A. Not just a black box: Learning important features through propagating activation differences. arXiv
preprint arXiv:1605.01713, 2016.
Simonyan, K., Vedaldi, A., and Zisserman, A. Deep inside convolutional networks: Visualising image classification models and saliency maps. arXiv preprint
arXiv:1312.6034, 2013.
Springenberg, J. T., Dosovitskiy, A., Brox, T., and Riedmiller, M. Striving for simplicity: The all convolutional
net. arXiv preprint arXiv:1412.6806, 2014.
Strack, B., DeShazo, J. P., Gennings, C., Olmo, J. L., Ventura, S., Cios, K. J., and Clore, J. N. Impact of HbA1c
measurement on hospital readmission rates: analysis of
70,000 clinical database patient records. BioMed Research International, 2014, 2014.
Szegedy, C., Vanhoucke, V., Ioffe, S., Shlens, J., and Wojna, Z. Rethinking the Inception architecture for computer vision. In Computer Vision and Pattern Recognition (CVPR), pp. 2818‚Äì2826, 2016.
Theano D. Team. Theano: A Python framework for
fast computation of mathematical expressions. arXiv
preprint arXiv:1605.02688, 2016.
Thomas, W. and Cook, R. D. Assessing influence on predictions from generalized linear models. Technometrics,
32(1):59‚Äì65, 1990.
Wei, B., Hu, Y., and Fung, W. Generalized leverage and
its applications. Scandinavian Journal of Statistics, 25:
25‚Äì37, 1998.
Wojnowicz, M., Cruz, B., Zhao, X., Wallace, B., Wolff, M.,
Luan, J., and Crable, C. ‚ÄúInfluence sketching‚Äù: Finding influential samples in large-scale regressions. arXiv
preprint arXiv:1611.05923, 2016.

