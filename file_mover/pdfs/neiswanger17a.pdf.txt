Post-Inference Prior Swapping

Willie Neiswanger 1 Eric Xing 2

Abstract
While Bayesian methods are praised for their
ability to incorporate useful prior knowledge, in
practice, convenient priors that allow for computationally cheap or tractable inference are commonly used. In this paper, we investigate the following question: for a given model, is it possible
to compute an inference result with any convenient false prior, and afterwards, given any target prior of interest, quickly transform this result into the target posterior? A potential solution is to use importance sampling (IS). However, we demonstrate that IS will fail for many
choices of the target prior, depending on its parametric form and similarity to the false prior. Instead, we propose prior swapping, a method that
leverages the pre-inferred false posterior to efficiently generate accurate posterior samples under arbitrary target priors. Prior swapping lets us
apply less-costly inference algorithms to certain
models, and incorporate new or updated prior information ‚Äúpost-inference‚Äù. We give theoretical
guarantees about our method, and demonstrate it
empirically on a number of models and priors.

1. Introduction
There are many cases in Bayesian modeling where a certain choice of prior distribution allows for computationally
simple or tractable inference. For example,
‚Ä¢ Conjugate priors yield posteriors with a known parametric form and therefore allow for non-iterative, exact inference (Diaconis et al., 1979).
‚Ä¢ Certain priors yield models with tractable conditional
or marginal distributions, which allows efficient approximate inference algorithms to be applied (e.g.
Gibbs sampling (Smith & Roberts, 1993), sampling
1

Carnegie Mellon University, Machine Learning Department,
Pittsburgh, USA 2 CMU School of Computer Science. Correspondence to: Willie Neiswanger <willie@cs.cmu.edu>.
th

Proceedings of the 34 International Conference on Machine
Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017
by the author(s).

in collapsed models (Teh et al., 2006), or mean-field
variational methods (Wang & Blei, 2013)).
‚Ä¢ Simple parametric priors allow for computationally
cheap density queries, maximization, and sampling,
which can reduce costs in iterative inference algorithms (e.g. Metropolis-Hastings (Metropolis et al.,
1953), gradient-based MCMC (Neal, 2011), or sequential Monte Carlo (Doucet et al., 2000)).
For these reasons, one might hope to infer a result under a
convenient-but-unrealistic prior, and afterwards, attempt to
correct the result. More generally, given an inference result
(under a convenient prior or otherwise), one might wish to
incorporate updated prior information, or see a result under different prior assumptions, without having to re-run a
costly inference algorithm.
This leads to the main question of this paper: for a given
model, is it possible to use any convenient false prior to
infer a false posterior, and afterwards, given any target prior
of interest, efficiently and accurately infer the associated
target posterior?
One potential strategy involves sampling from the false
posterior and reweighting these samples via importance
sampling (IS). However, depending on the chosen target
prior‚Äîboth its parametric form and similarity to the false
prior‚Äîthe resulting inference can be inaccurate due to high
or infinite variance IS estimates (demonstrated in Sec. 2.1).
We instead aim to devise a method that yields accurate inferences for arbitrary target priors. Furthermore, like IS, we
want to make use of the pre-inferred false posterior, without
simply running standard inference algorithms on the target
posterior. Note that most standard inference algorithms are
iterative and data-dependent: parameter updates at each iteration involve data, and the computational cost or quality
of each update depends on the amount of data used. Hence,
running inference algorithms directly on the target posterior can be costly (especially given a large amount of data
or many target priors of interest) and defeats the purpose of
using a convenient false prior.
In this paper, we propose prior swapping, an iterative, dataindependent method for generating accurate posterior samples under arbitrary target priors. Prior swapping uses the
pre-inferred false posterior to perform efficient updates that

Post-Inference Prior Swapping

do not depend on the data, and thus proceeds very quickly.
We therefore advocate breaking difficult inference problems into two easier steps: first, do inference using the most
computationally convenient prior for a given model, and
then, for all future priors of interest, use prior swapping.
In the following sections, we demonstrate the pitfalls of
using IS, describe the proposed prior swapping methods
for different types of false posterior inference results (e.g.
exact or approximate density functions, or samples) and
give theoretical guarantees for these methods. Finally, we
show empirical results on heavy-tailed and sparsity priors
in Bayesian generalized linear models, and relational priors
over components in mixture and topic models.

2. Methodology
Suppose we have a dataset of n vectors xn = {x1 , . . . , xn },
xi ‚àà Rp , and we have chosen a family of models with the
likelihood function L(Œ∏|xn ) = p(xn |Œ∏), parameterized by
Œ∏ ‚àà Rd . Suppose we have a prior distribution over the
space of model parameters Œ∏, with probability density function (PDF) œÄ(Œ∏). The likelihood and prior define a joint
model with PDF p(Œ∏, xn ) = œÄ(Œ∏)L(Œ∏|xn ). In Bayesian inference, we are interested in computing the posterior (conditional) distribution of this joint model, with PDF
p(Œ∏|xn ) = R

œÄ(Œ∏)L(Œ∏|xn )
.
œÄ(Œ∏)L(Œ∏|xn ) dŒ∏

(1)

Suppose we‚Äôve chosen a different prior distribution œÄf (Œ∏),
which we refer to as a false prior (while we refer to œÄ(Œ∏)
as the target prior). We can now define a new posterior
pf (Œ∏|xn ) = R

œÄf (Œ∏)L(Œ∏|xn )
œÄf (Œ∏)L(Œ∏)|xn ) dŒ∏

(2)

which we refer to as a false posterior.
We are interested in the following task: given a false posterior inference result (i.e. samples from pf (Œ∏|xn ), or some
exact or approximate PDF), choose an arbitrary target prior
œÄ(Œ∏) and efficiently sample from the associated target posterior p(Œ∏|xn )‚Äîor, more generally, compute an expectation ¬µh = Ep [h(Œ∏)] for some test function h(Œ∏) with respect to the target posterior.
2.1. Importance Sampling and Prior Sensitivity
We begin by describing an initial strategy, and existing
work in a related task known as prior sensitivity analysis.
{Œ∏ÃÉt }Tt=1

Suppose we have T false posterior samples
‚àº
pf (Œ∏|xn ). In importance sampling (IS), samples from an
importance distribution are used to estimate the expectation of a test function with respect to a target distribution.
A straightforward idea is to use the false posterior as an

importance distribution, and compute the IS estimate
¬µÃÇIS
h =

T
X

w(Œ∏ÃÉt )h(Œ∏ÃÉt )

(3)

t=1
n

)
where the weight function w(Œ∏) ‚àù pp(Œ∏|x
‚àù
n
f (Œ∏|x )
the T weights are normalized to sum to one.

œÄ(Œ∏)
œÄf (Œ∏) ,

and

IS-based methods have been developed for the task of prior
sensitivity analysis (PSA). In PSA, the goal is to determine
how the posterior varies over a sequence of priors (e.g. over
a parameterized family of priors œÄ(Œ∏; Œ≥i ), i = 0, 1, . . .).
Existing work has proposed inferring a single posterior under prior œÄ(Œ∏; Œ≥0 ), and then using IS methods to infer further posteriors in the sequence (Besag et al., 1995; Hastings, 1970; Bornn et al., 2010).
This strategy is effective when subsequent priors are similar enough, but breaks down when two priors are sufficiently dissimilar, or are from ill-matched parametric families, which we illustrate in an example below.
Note that, in general for IS, as T ‚Üí ‚àû, ¬µÃÇIS
h ‚Üí ¬µh almost surely. However, IS estimates can still fail in practice
if ¬µÃÇIS
h has high or infinite variance. If so, the variance of
the weights w(Œ∏ÃÉt ) will be large (a problem often referred
to as weight degeneracy), which can lead to inaccurate estimates. In our case, the variance of ¬µÃÇIS
h is only finite if




2
2 œÄ(Œ∏)
2 œÄ(Œ∏)
< ‚àû. (4)
‚àù Ep h(Œ∏)
Epf h(Œ∏)
œÄf (Œ∏)2
œÄf (Œ∏)
For a broad class of h, this is satisfied if there exists M ‚àà R
such that œÄœÄ(Œ∏)
< M, ‚àÄŒ∏ (Geweke, 1989). Given some pref (Œ∏)
n
inferred pf (Œ∏|x ) with false prior œÄf (Œ∏), the accuracy of IS
thus depends on the target prior of interest. For example, if
œÄ(Œ∏) has heavier tails than œÄf (Œ∏), the variance of ¬µÃÇIS
h will
be infinite for many h. Intuitively, we expect the variance
to be higher for œÄ that are more dissimilar to œÄf .
We show a concrete example of this in Fig. 1. Consider a
normal model for data xn ‚àº N (Œ∏, 1), with a standard normal false prior œÄf (Œ∏) = N (Œ∏|0, 1). This yields a closedform false posterior (due to the conjugate œÄf ), which is also
normal. Suppose we‚Äôd like to estimate the posterior expectation under a Laplace target prior, with mean 10 and variance 1, for test function h(Œ∏) = Œ∏ (i.e. an estimate of the
target posterior mean). We draw T false posterior samples
{Œ∏ÃÉt }Tt=1 ‚àº pf (Œ∏|xn ), compute weights w(Œ∏ÃÉt ) and IS estimate ¬µÃÇIS
h , and compare it with the true expectation ¬µh .
We see in Fig. 1 that |¬µh ‚àí ¬µÃÇIS
h | slows significantly as T
increases, and maintains a high error even as T is made
very large. We can analyze this issue theoretically. Supn
pose we want |¬µh ‚àí ¬µÃÇIS
h | < Œ¥. Since we know pf (Œ∏|x )
is normal, we can compute a lower bound on the number of false posterior samples T that would be needed for

Post-Inference Prior Swapping
1.5

PDF

=

1
0.5
0
False posterior samples

‚àí2

0

2

4

6

8

10

12

Figure 1. Importance sampling with false posterior samples. As the number of samples T grows, the difference between the IS estimate
8
¬µÃÇIS
h and the true value ¬µh decreases increasingly slowly. The difference remains large even when T = 10 . See text for analysis.

the expected estimate to be within Œ¥ of ¬µh . Namely, if
pf (Œ∏|xn ) = N (Œ∏|m, s2 ), in order for |¬µh ‚àí Epf [¬µÃÇIS
h ]| < Œ¥,
we‚Äôd need


1
2
T ‚â• exp
(|¬µ
‚àí
m|
‚àí
Œ¥)
.
h
2s2

later; assume for now that it is either equal to pf (Œ∏|xn ) or
approximates it). We then define the prior swap density as

In the example in Fig. 1, we have m = 1, s2 = 0.25, and
¬µh = 7.9892. Hence, for |¬µh ‚àí Epf [¬µÃÇIS
h ]| < 1, we‚Äôd need
T > 1031 samples (see appendix for full details of this
analysis). Note that this bound actually has nothing to do
with the parametric form of œÄ(Œ∏)‚Äîit is based solely on the
normal false posterior, and its distance to the target posterior mean ¬µh . However, even if this distance was small,
the importance estimate would still have infinite variance
due to the Laplace target prior. Further, note that the situation can significantly worsen in higher dimensions, or if
the false posterior has a lower variance.

Note that if pÃÉf (Œ∏) = pf (Œ∏|xn ), then ps (Œ∏) = p(Œ∏|xn ).
However, depending on how we represent pÃÉf (Œ∏), ps (Œ∏) can
have a much simpler analytic representation than p(Œ∏|xn ),
which is typically defined via a likelihood function (i.e. a
function of the data) and causes inference algorithms to
have costs that scale with the data size n. Specifically, we
will only use low-complexity pÃÉf (Œ∏) that can be evaluated
in constant time with respect to the data size n.

2.2. Prior Swapping
We‚Äôd like a method that will work well even when false
and target priors œÄf (Œ∏) and œÄ(Œ∏) are significantly different,
or are from different parametric families, with performance
that does not worsen (in accuracy nor computational complexity) as the priors are made more dissimilar.

ps (Œ∏) ‚àù

pÃÉf (Œ∏)œÄ(Œ∏)
.
œÄf (Œ∏)

(5)

Our general strategy is to use ps (Œ∏) as a surrogate for
p(Œ∏|xn ) in standard MCMC or optimization procedures, to
yield data-independent algorithms with constant cost per iteration. Intuitively, the likelihood information is captured
by the false posterior‚Äîwe make use of this instead of the
likelihood function, which is costly to evaluate.

Redoing inference for each new target posterior can be
very costly, especially when the data size n is large, because the per-iteration cost of most standard inference algorithms scales with n, and many iterations may be needed
for accurate inference. This includes both MCMC and sequential monte carlo (SMC) algorithms (i.e. repeated-ISmethods that infer a sequence of distributions). In SMC,
the per-iteration cost still scales with n, and the variance
estimates can still be infinite if subsequent distributions are
ill-matched.

More concretely, at each iteration in standard inference algorithms, we must evaluate a data-dependent function associated with the posterior density. For example, we evaluate
a function proportional to p(Œ∏|xn ) in Metropolis-Hastings
(MH) (Metropolis et al., 1953), and ‚àáŒ∏ log p(Œ∏|xn ) in
gradient-based MCMC methods (such as Langevin dynamics (LD) (Rossky et al., 1978) and Hamiltonian Monte
Carlo (HMC) (Neal, 2011)) and in optimization procedures
that yield a MAP point estimate. In prior swapping, we instead evaluate ps (Œ∏) in MH, or ‚àáŒ∏ log ps (Œ∏) in LD, HMC,
or gradient optimization to a MAP estimate (see appendix
for algorithm pseudocode). Here, each iteration only requires evaluating a few simple analytic expressions, and
thus has O(1) complexity with respect to data size.

Instead, we aim to leverage the inferred false posterior to
more-efficiently compute any future target posterior. We
begin by defining a prior swap density ps (Œ∏). Suppose for
now that a false posterior inference algorithm has returned
a density function pÃÉf (Œ∏) (we will give more details on pÃÉf

We demonstrate prior swapping on our previous example
(using a normal false prior and Laplace target prior) in
Fig. 2, where we have a closed-form (normal PDF) pÃÉf (Œ∏).
To do prior swapping, we run a Metropolis-Hastings algorithm on the target density ps (Œ∏). Note that drawing each

Post-Inference Prior Swapping
1.5
=

PDF

1
0.5
0
Prior swapping samples

‚àí2

0

2

4

6

8

10

12

T
Figure 2. Using prior swapping to compute estimate ¬µÃÇPS
h by drawing samples {Œ∏t }t=1 ‚àº ps (Œ∏).

sample in this Markov chain does not involve the data xn ,
and can be done in constant time with respect to n (which
we can see by viewing the wall time for different T ). In
Fig. 2, we draw T samples {Œ∏t }Tt=1 ‚àº ps (Œ∏), compute a
PT
1
sample estimate ¬µÃÇPS
h = T
t=1 Œ∏t , and compare it with
the true value ¬µh . We see that ¬µÃÇPS
h converges to ¬µh after a
relatively small number of samples T.
2.3. Prior Swapping with False Posterior Samples
The previous method is only applicable if our false posterior inference result is a PDF pÃÉf (Œ∏) (such as in closed-form
inference or variational approximations). Here, we develop
prior swapping methods for the setting where we only have
Tf
access to samples {Œ∏ÃÉt }t=1
‚àº pf (Œ∏|xn ). We propose the
following procedure:
T

f
1. Use {Œ∏ÃÉt }t=1
to form an estimate pÃÉf (Œ∏) ‚âà pf (Œ∏|xn ).

2. Sample from ps (Œ∏) ‚àù
as before.

œÄ(Œ∏)pÃÉf (Œ∏)
œÄf (Œ∏)

with prior swapping,

Note that, in general, ps (Œ∏) only approximates p(Œ∏|xn ). As
a final step, after sampling from ps (Œ∏), we can:
3. Apply a correction to samples from ps (Œ∏).
We will describe two methods for applying a correction to
ps samples‚Äîone involving importance sampling, and one
involving semiparametric density estimation. Additionally,
we will discuss forms for pÃÉf (Œ∏), guarantees about these
forms, and how to optimize the choice of pÃÉf (Œ∏). In particular, we will argue why (in constrast to the initial IS strategy)
these methods do not fail when p(Œ∏|xn ) and pf (Œ∏|xn ) are
very dissimilar or have ill-matching parametric forms.
Prior swap importance sampling. Our first proposal for
applying a correction to prior swap samples involves IS: after estimating some pÃÉf (Œ∏), and sampling {Œ∏t }Tt=1 ‚àº ps (Œ∏),
we can treat {Œ∏t }Tt=1 as importance samples, and compute
the IS estimate
¬µÃÇPSis
h

=

T
X
t=1

w(Œ∏t )h(Œ∏t )

(6)

where the weight function is now
w(Œ∏) ‚àù

p(Œ∏|xn )
pf (Œ∏|xn )
‚àù
ps (Œ∏)
pÃÉf (Œ∏)

and the weights are normalized so that

PT

t=1

(7)
w(Œ∏t ) = 1.

The key difference between this and the previous IS strategy is the weight function. Recall that, previously, an accurate estimate depended on the similarity between œÄ(Œ∏) and
œÄf (Œ∏); both the distance to and parametric form of œÄ(Œ∏)
could produce high or infinite variance estimates. This was
an issue because we wanted the procedure to work well for
any œÄ(Œ∏). Now, however, the performance depends on the
similarity between pÃÉf (Œ∏) and pf (Œ∏|xn )‚Äîand by using the
false posterior samples, we can estimate a pÃÉf (Œ∏) that well
approximates pf (Œ∏|xn ). Additionally, we can prove that
certain choices of pÃÉf (Œ∏) guarantee a finite variance IS estimate. Note that the variance of ¬µÃÇPSis
is only finite if
h




n
pf (Œ∏|xn )2
2 pf (Œ∏|x )
Epf h(Œ∏)2
< ‚àû.
‚àù
E
h(Œ∏)
p
pÃÉf (Œ∏)2
pÃÉf (Œ∏)
To bound this, it is sufficient
to show that there exists
p (Œ∏|xn )
M ‚àà R such that fpÃÉf (Œ∏) < M for all Œ∏ (assuming a
test function h(Œ∏) with finite variance) (Geweke, 1989). To
satisfy this condition, we will propose a certain parametric
family pÃÉŒ±
f (Œ∏). Note that, to maintain a prior swapping procedure with O(1) cost, we want a pÃÉŒ±
f (Œ∏) that can be evaluated in constant time. In general, a pÃÉŒ±
f (Œ∏) with fewer terms
will yield a faster procedure. With these in mind, we propose the following family of densities.
Definition. For a parameter Œ± = (Œ±1 , . . . , Œ±k ), Œ±j ‚àà Rp ,
k > 0, let density pÃÉŒ±
f (Œ∏) satisfy
pÃÉŒ±
f (Œ∏)

‚àù œÄf (Œ∏)

k
Y

p(Œ±j |Œ∏)n/k

(8)

j=1

where p(Œ±j |Œ∏) denotes the model conditional PDF.
The number of terms in pÃÉŒ±
f (Œ∏) (and cost to evaluate) is
determined by the parameter k. Note that this family is

Post-Inference Prior Swapping

inspired by the true form of the false posterior pf (Œ∏|xn ).
However, pÃÉŒ±
f (Œ∏) has constant-time evaluation, and we
T

f
can estimate its parameter Œ± using samples {Œ∏ÃÉt }t=1
‚àº
pf (Œ∏|xn ). Furthermore, we have the following guarantees.

Theorem 2.1. For any Œ± = (Œ±1 , . . . , Œ±k ) ‚äÇ Rp and k > 0
let pÃÉŒ±
f (Œ∏) be defined as in Eq. (8). Then, there exists M > 0
such that

pf (Œ∏|xn )
pÃÉŒ±
f (Œ∏)

< M , for all Œ∏ ‚àà Rd .
pÃÉŒ± (Œ∏)œÄ(Œ∏)

f
Corollary 2.1.1. For {Œ∏t }Tt=1 ‚àº pŒ±
s (Œ∏) ‚àù
œÄf (Œ∏) ,


‚àí1
n
n
P
pf (Œ∏r |x )
p (Œ∏t |x )
T
, and test function
w(Œ∏t ) = fpÃÉŒ± (Œ∏
r=1 pÃÉŒ± (Œ∏r )
t)
f

f

that satisfies Varp [h(Œ∏)] < ‚àû, the variance of IS estimate
PT
¬µÃÇPSis
= t=1 h(Œ∏t )w(Œ∏t ) is finite.
h
Proofs for these theorems are given in the appendix.
Note that we do not know the normalization constant for
pÃÉŒ±
f (Œ∏). This is not an issue for its use in prior swapping,
since we only need access to a function proportional to
Œ±
‚àí1
in most MCMC algorithms.
pŒ±
s (Œ∏) ‚àù pÃÉf (Œ∏)œÄ(Œ∏)œÄf (Œ∏)
However, we still need to estimate Œ±, which is an issue because the unknown normalization constant is a function of
Œ±. Fortunately, we can use the method of score matching
(HyvaÃàrinen, 2005) to estimate Œ± given a density such as
pÃÉŒ±
f (Œ∏) with unknown normalization constant.
Once we have found an optimal parameter Œ±‚àó , we draw
‚àó
Œ±‚àó
‚àí1
samples from pŒ±
, compute
s (Œ∏) ‚àù pÃÉf (Œ∏)œÄ(Œ∏)œÄf (Œ∏)
weights for these samples (Eq. (7)), and compute the IS
estimate ¬µÃÇPSis
h . We give pseudocode for the full prior swap
importance sampling procedure in Alg. 1.
Algorithm 1: Prior Swap Importance Sampling
T

f
Input: False posterior samples {Œ∏ÃÉt }t=1
‚àº pf (Œ∏|xn ).
Output: IS estimate ¬µÃÇPSis
.
h

1

T

f
Score matching: estimate Œ±‚àó using {Œ∏ÃÉt }t=1
.

‚àó

‚àó
pÃÉŒ±
f (Œ∏)œÄ(Œ∏)
‚àº pŒ±
.
s (Œ∏) ‚àù
œÄf (Œ∏)
PT
PSis
¬µÃÇh = t=1 h(Œ∏t )w(Œ∏t ).

{Œ∏t }Tt=1

2

Prior swapping: sample

3

Importance sampling: compute

Semiparametric prior swapping. In the previous
method, we chose a parametric form for pÃÉŒ±
f (Œ∏); in general,
even the optimal Œ± will yield an inexact approximation to
pf (Œ∏|xn ). Here, we aim to incorporate methods that return
an increasingly exact estimate pÃÉf (Œ∏) when given more
Tf
false posterior samples {Œ∏ÃÉt }t=1
.
One idea is to use a nonparametric kernel density estimate
np
np
‚àí1
pÃÉnp
.
f (Œ∏) and plug this into ps (Œ∏) ‚àù pÃÉf (Œ∏)œÄ(Œ∏)œÄf (Œ∏)
However, nonparametric density estimates can yield inaccurate density tails and fare badly in high dimensions. To
help mitigate these problems, we turn to a semiparametric estimate, which begins with a parametric estimate, and

adjusts it as samples are generated. In particular, we use
a density estimate that can be viewed as the product of a
parametric density estimate and a nonparametric correction function (Hjort & Glad, 1995). This density estimate
is consistent as the number of samples Tf ‚Üí ‚àû. Instead
of (or in addition to) correcting prior swap samples with
importance sampling, we can correct them by updating the
nonparametric correction function as we continue to generate false posterior samples.
T

f
Given Tf samples {Œ∏ÃÉt }t=1
‚àº pf (Œ∏|xn ), we write the semiparametric false posterior estimate as
!
#
Tf "
kŒ∏ ‚àí Œ∏et k pÃÉŒ±
1 X 1
f (Œ∏)
sp
K
, (9)
pÃÉf (Œ∏) =
Tf t=1 bd
b
pÃÉŒ±
f (Œ∏ÃÉt )

where K denotes a probability density kernel, with bandwidth b, where b ‚Üí 0 as Tf ‚Üí ‚àû (see (Wasserman, 2006)
for details on probability density kernels and bandwidth selection). The semiparametric prior swap density is then


Tf K kŒ∏‚àíŒ∏ÃÉt k pÃÉŒ± (Œ∏)œÄ(Œ∏)
sp
X
pÃÉ
(Œ∏)œÄ(Œ∏)
f
b
1
f
=
psp
s (Œ∏) ‚àù
Œ±
œÄf (Œ∏)
Tf t=1
pÃÉf (Œ∏ÃÉt )œÄf (Œ∏)bd
Ô£π

Ô£Æ
Tf K kŒ∏‚àíŒ∏ÃÉt k
X
b
Ô£ª.
Ô£∞ 1
(10)
‚àù [pŒ±
s (Œ∏)]
Œ±
Tf t=1
pÃÉf (Œ∏ÃÉt )
Hence, the prior swap density psp
s (Œ∏) is proportional to the
product of two densities: the parametric prior swap density
pŒ±
s (Œ∏), and a correction density. To estimate expectations
with respect to psp
s (Œ∏), we can follow Alg. 1 as before, but
replace the weight function in the final IS estimate with


Tf K kŒ∏‚àíŒ∏ÃÉt k
sp
X
b
p (Œ∏)
1
w(Œ∏) ‚àù sŒ±
‚àù
.
(11)
Œ±
ps (Œ∏)
Tf t=1
pÃÉf (Œ∏ÃÉt )
One advantage of this strategy is that computing the
weights doesn‚Äôt require the data‚Äîit thus has constant cost
with respect to data size n (though its cost does increase
with the number of false posterior samples Tf ). Additionally, as in importance sampling, we can prove that this procedure yields an exact estimate of E[h(Œ∏)], asymptotically,
as Tf ‚Üí ‚àû (and we can provide an explicit bound on the
n
rate at which psp
s (Œ∏) converges to p(Œ∏|x )). We do this by
sp
showing that ps (Œ∏) is consistent for p(Œ∏|xn ).
T

f
Theorem 2.2. Given false posterior samples {Œ∏ÃÉt }t=1
‚àº
‚àí1/(4+d)
n
sp
pf (Œ∏|x ) and b  Tf
, the estimator ps is consistent for p(Œ∏|xn ), i.e. its mean-squared error satisfies
Z

c
n 2
sup E
(psp
(Œ∏)
‚àí
p(Œ∏|x
))
dŒ∏
< 4/(4+d)
s
p(Œ∏|xn )
Tf

for some c > 0 and 0 < b ‚â§ 1.
The proof for this theorem is given in the appendix.

Post-Inference Prior Swapping

3. Empirical Results
We show empirical results on Bayesian generalized linear models (including linear and logistic regression) with
sparsity and heavy tailed priors, and on latent factor models (including mixture models and topic models) with relational priors over factors (e.g. diversity-encouraging,
agglomerate-encouraging, etc.). We aim to demonstrate
empirically that prior swapping efficiently yields correct
samples and, in some cases, allows us to apply certain inference algorithms to more-complex models than was previously possible. In the following experiments, we will refer
to the following procedures:
‚Ä¢ Target posterior inference: some standard inference
algorithm (e.g. MCMC) run on p(Œ∏|xn ).
‚Ä¢ False posterior inference: some standard inference
algorithm run on pf (Œ∏|xn ).
‚Ä¢ False posterior IS: IS using samples from pf (Œ∏|xn ).
‚Ä¢ Prior swap exact: prior swapping with closed-form
pÃÉf (Œ∏) = pf (Œ∏|xn ).
‚Ä¢ Prior swap parametric: prior swapping with parametric pÃÉŒ±
f (Œ∏) given by Eq. (8).
‚Ä¢ Prior swap IS: correcting samples from
IS.

pÃÉŒ±
f (Œ∏)

with

‚Ä¢ Prior swap semiparametric: correcting samples
from pÃÉŒ±
f (Œ∏) with the semiparametric estimate IS procedure.
To assess performance, we choose a test function h(Œ∏), and
compute the Euclidean distance between ¬µh = Ep [h(Œ∏)]
and some estimate ¬µÃÇh returned by a procedure. We denote
this performance metric by posterior error = k¬µh ‚àí ¬µÃÇh k2 .
Since ¬µh is typically not available analytically, we run a
single chain of MCMC on the target posterior for one million steps, and use these samples as ground truth to compute ¬µh . For timing plots, to assess error of a method at a
given time point, we collect samples drawn before this time
point, remove the first quarter as burn in, and add the time
it takes to compute any of the corrections.
3.1. Sparsity Inducing and Heavy Tailed Priors in
Bayesian Generalized Linear Models
Sparsity-encouraging regularizers have gained a high level
of popularity over the past decade due to their ability to produce models with greater interpretability and parsimony.
For example, the L1 norm has been used to induce sparsity
with great effect (Tibshirani, 1996), and has been shown
to be equivalent to a mean-zero independent Laplace prior
(Tibshirani, 1996; Seeger, 2008). In a Bayesian setting, inference given a sparsity prior can be difficult, and often requires a computationally intensive method (such as MH or

HMC) or posterior approximations (e.g. expectation propagation (Minka, 2001)) that make factorization or parametric assumptions (Seeger, 2008; Gerwinn et al., 2010). We
propose a cheap yet accurate solution: first get an inference
result with a more-tractable prior (such as a normal prior),
and then use prior swapping to quickly convert the result to
the posterior given a sparsity prior.
Our first set of experiments are on Bayesian linear regression models, which we can write as yi = Xi Œ∏ +
,  ‚àº N (0, œÉ 2 ), Œ∏ ‚àº œÄ, i = 1,...,n. For œÄ, we
compute results on Laplace, Student‚Äôs t, and VerySparse
Qd 1
exp{‚àí|Œ∏i |0.4 /œÉ}
(with PDF VerySparse(œÉ) = i=1 2œÉ
(Seeger, 2008)) priors. Here, a normal œÄf is conjugate
and allows for exact false posterior inference. Our second set of experiments are on Bayesian logistic regression models, which we write as yi ‚àº Bern(pi ), pi =
logistic(Xi Œ∏), Œ∏ ‚àº œÄ, i = 1,...,n. which we will pair
with both heavy tailed priors and a hierarchical target prior
œÄ = N (0, Œ±‚àí1 I), Œ± ‚àº Gamma(Œ≥, 1). For these experiments, we also use a normal œÄf . However, this false prior
is no longer conjugate, and so we use MCMC to sample
from pf (Œ∏|xn ).
For linear regression, we use the YearPredictionMSD data
set* , (n = 515345, d = 90), in which regression is used to
predict the year associated with a a song, and for logistic regression we use the MiniBooNE particle identification data
set‚Ä† , (n = 130065, d = 50), in which binary classification
is used to distinguish particles.
In Fig. 3, we compare prior swapping and IS methods, in
order to show that the prior swapping procedures yield accurate posterior estimates, and to compare their speeds of
convergence. We plot posterior error vs. wall time for each
method‚Äôs estimate of the posterior mean Ep [h(Œ∏)] = Ep [Œ∏]
for two sparsity target priors (Laplace and VerySparse),
for both linear and logistic regression. In linear regression
(only), since the normal conjugate œÄf allows us to compute
a closed form pf (Œ∏|xn ), we can run the prior swap exact
method, where pÃÉf (Œ∏) = pf (Œ∏|xn ). However, we can also
‚àó
sample from pf (Œ∏|xn ) to compute pÃÉŒ±
f (Œ∏), and therefore
compare methods such as prior swap parametric and the
two correction methods. In logistic regression, we do not
have a closed form pf (Œ∏|xn ); here, we only compare the
methods that make use of samples from pf (Œ∏|xn ). In Fig. 3,
we see that the prior swapping methods (particularly prior
swap IS) quickly converge to nearly zero posterior error.
Additionally, in linear regression, we see that prior swap
‚àó
parametric, using pÃÉf (Œ∏) = pÃÉŒ±
f (Œ∏), yields similar posterior
error as prior swap exact, which uses pÃÉf (Œ∏) = p(Œ∏|xn ).
* https://archive.ics.uci.edu/ml/datasets/
YearPredictionMSD
‚Ä†
https://archive.ics.uci.edu/ml/datasets/
MiniBooNE+particle+identification

Post-Inference Prior Swapping

0.4
0.35

0.35
0.3

0.25

0.25
0.2

0.2

0.15

0.15
0.1

0.1

50

100

150

200

0
0

250

Wall time (s)

100

200

300

400

1.6

1.4

1.4

1.2

1.2

1
0.8

Prior swap exact,

1

0.8

0.6

0.6

0.4

0.4
0.2

0
0

500

Wall time (s)

False posterior IS,

1.8

1.6

0.2

0.05

0.05
0
0

0.3

1.8

Posterior error

0.4

Posterior error

0.45

Posterior error

0.45

Bayesian Logistic Regression

Posterior error

Bayesian Linear Regression

100

200

300

400

Wall time (s)

Prior swap parametric,

0
0

500

Prior swap IS,

100

200

300

400

500

600

700

Wall time (s)

800

Prior swap SP

Figure 3. Comparison of prior swapping and IS methods for Bayesian linear and logistic regression under Laplace and VerySparse target
priors. The prior swapping methods (particularly prior swap exact and prior swap IS) quickly converge to low posterior errors.
(c)

Application: fast inference in Bayesian linear regression
(a)

= Laplace(0.1)

60

= Laplace(0.01)

60

= Laplace(0.001)

60

1

0.5
0.4

0
0

20

10

10

0

(d)
200

400

600

800

1000

‚àí0.15

‚àí0.1

‚àí0.05

= Student's t(0.1)

= Normal(0.1)

0

30

20

10

0

0.05

‚àí0.15

= Laplace(0.1)

‚àí0.1

‚àí0.05

0

0

0.05

‚àí0.15

‚àí0.1

0.06

0.06

0.06

0.06

0.06

0.04

0.04

0.04

0.04

0.04

0.04

1

0.02

0.02

0.02

0.02

0.02

0.9

0

0

0

0

0

0

0.8

‚àí0.02

‚àí0.02

‚àí0.02

‚àí0.02

‚àí0.02

‚àí0.02

0.7

‚àí0.04

‚àí0.04

‚àí0.02

0

0.02

0.04

0.06

‚àí0.06

‚àí0.04

‚àí0.02

0

0.02

0.04

‚àí0.04

‚àí0.02

0

0.02

0.04

0.06

‚àí0.04

‚àí0.06

‚àí0.06

‚àí0.06
‚àí0.06

0.06

‚àí0.06

‚àí0.04

‚àí0.02

0

0.02

0.04

‚àí0.06

0.06

0.05

0.02

‚àí0.04

‚àí0.04

‚àí0.06

‚àí0.06
‚àí0.06

‚àí0.04

‚àí0.02

0

0.02

0.04

‚àí0.06

0.06

0.1

0.1

0.1

0.1

0.1

0.1

0

0

0

0

0

0

‚àí0.1

‚àí0.1

‚àí0.1

‚àí0.1

‚àí0.1

‚àí0.1

‚àí0.04

‚àí0.02

0

0.02

0.04

0.06

0

0.05

Dimensions
4 and 5

0.5

‚àí0.04

‚àí0.04

‚àí0.06

0.6

0

= VerySparse(0.01)

0.06

Wall time (s)

‚àí0.05

= VerySparse(0.1)

= Laplace(0.01)

Dimensions
2 and 3

Posterior error

20

0.2
0.1

(b)

40

30

30

Prior swap (exact)

0.3

50

40

PDF

0.6

50

40

PDF

0.7

50

PDF

Posterior error

0.8

Dimension 1

False posterior
inference (exact)
Target posterior
inference (MCMC)
False posterior IS

0.9

0.4
0.3
0.2
0.1
0
0

200

400

600

Wall time (s)

800

1000
‚àí0.2

‚àí0.2

‚àí0.15

‚àí0.1

‚àí0.05

0

0.05

‚àí0.2

‚àí0.2

‚àí0.15

‚àí0.1

‚àí0.05

0

0.05

‚àí0.2

‚àí0.2

‚àí0.15

‚àí0.1

‚àí0.05

0

0.05

‚àí0.2

‚àí0.2

‚àí0.15

‚àí0.1

‚àí0.05

0

0.05

‚àí0.2

‚àí0.2

‚àí0.15

‚àí0.1

‚àí0.05

0

0.05

‚àí0.2

‚àí0.2

‚àí0.15

‚àí0.1

‚àí0.05

Figure 4. Prior swapping for fast inference in Bayesian linear models with sparsity and heavy-tailed priors: (a-b) Convergence plots
showing that prior swapping performs accurate inference faster than the comparison methods and is robust to changing œÄ. (c) Inferred
1-d density marginals when prior sparsity is increased. (d) Prior swapping results for a variety of different sparsity priors.

In Fig. 4, we show how prior swapping can be used for
fast inference in Bayesian linear models with sparsity or
heavy-tailed priors. We plot the time needed to first compute the false posterior (via exact inference) and then run
prior swapping (via the MH procedure) on some target posterior, and compare this with the MH algorithm run directly
on the target posterior. In (a) and (b) we show convergence
plots and see that prior swapping performs faster inference
(by a few orders of magnitude) than direct MH. In plot
(b) we reduce the variance of the target prior; while this
hurts the accuracy of false posterior IS, prior swapping still
quickly converges to zero error. In (c) we show 1-d density
marginals as we increase the prior sparsity, and in (d) we
show prior swapping results for various sparsity priors.
In the appendix, we also include results on logistic regression with the hierarchical target prior, as well as results for
synthetic data where we are able to compare timing and
posterior error as we tune n and d.

3.2. Priors over Factors in Latent Variable Models
Many latent variable models in machine learning‚Äîsuch as
mixture models, topic models, probabilistic matrix factorization, and others‚Äîinvolve a set of latent factors (e.g.
components or topics). Often, we‚Äôd like to use priors
that encourage interesting behaviors among the factors.
For example, we might want dissimilar factors through
a diversity-promoting prior (Kwok & Adams, 2012; Xie
et al., 2016) or for the factors to show some sort of sparsity pattern (Mayrink et al., 2013; Knowles & Ghahramani,
2011). Inference in such models is often computationally
expensive or designed on a case-by-case basis (Xie et al.,
2016; Knowles & Ghahramani, 2011).
However, when conjugate priors are placed over the factor
parameters, collapsed Gibbs sampling can be applied. In
this method, the factor parameters are integrated out, leaving only a subset of variables; on these, the conditional

Post-Inference Prior Swapping
(a)

(b)

Relational target priors (over factors

)

Mixture Model: False Posterior via Collapsed Gibbs, Target Posterior via Prior Swapping
2. Agglom(0.1)

4. Diverse(0.1)

3. Chain(0.1)

4

4

4

3

3

3

3

2

2

2

2

2

1

1

1

1

1

0

0

0

0

0

‚àí1

‚àí1

‚àí1

‚àí1

‚àí1

‚àí2

‚àí2

‚àí2

‚àí2

‚àí2

4

‚àí3

‚àí2

‚àí1

0

1

2

3

4

‚àí3

‚àí3
‚àí2

‚àí1

0

1

2

3

4

‚àí3

5. SparseOrigin(0.1) 6. SparseAgglom(0.1)

‚àí3
‚àí2

‚àí1

0

1

2

3

4

‚àí3

4

4

4

4

3

3

3

3

2

2

2

2

1

1

1

1

0

0

0

0

‚àí1

‚àí1

‚àí1

‚àí1

‚àí2

‚àí3

‚àí2

‚àí2

‚àí3
‚àí1

0

1

2

3

4

‚àí3

‚àí2

‚àí1

0

1

2

Cluster:
Geography

Topic 6
1. southern
2. northern
3. region
4. western
5. eastern
6. south

Topic 171
1. west
2. south
3. coast
4. north
5. east
6. western

Topic 285
1. north
2. asia
3. south
4. western
5. southern
6. eastern

Topic 353
1. north
2. west
3. east
4. south
5. eastern
6. western

Cluster:
Family

(c)
Topic Model: False Posterior via Collapsed Gibbs

Topic 11
1. father
2. family
3. brother
4. born
5. son
6. children

Topic 243
1. children
2. daughter
3. born
4. son
5. family
6. father

Topic 280
1. born
2. died
3. father
4. years
5. family
6. lived

Topic 306
1. born
2. parents
3. studied
4. moved
5. age
6. year

3

4

‚àí1

0

1

2

3

4

‚àí2

‚àí3

‚àí3
‚àí2

‚àí2

7. SparseChain(0.1) 8. Origin+Diverse(0.1)

‚àí3

‚àí3
‚àí2

‚àí1

0

1

2

3

4

‚àí3

‚àí2

‚àí1

0

1

2

3

4

Topic Model: Target Posterior via Prior Swapping
Topic 6
1. territory
2. region
3. regions
4. provinces
5. capital
6. territories
Topic 11
1. brother
2. sister
3. younger
4. older
5. youngest
6. sisters

Topic 171
1. bay
2. south
3. coast
4. area
5. land
6. sea
Topic 243
1. husband
2. marriage
3. wife
4. death
5. marry
6. children

Topic 285
1. america
2. europe
3. asia
4. world
5. countries
6. africa
Topic 280
1. important
2. stayed
3. wrote
4. travelled
5. started
6. died

Topic 353
1. side
2. east
3. bordered
4. west
5. middle
6. border
Topic 306
1. school
2. college
3. graduated
4. studies
5. university
6. fellow

4

3

Wall time (seconds)

3

Border

2

School

1

Countries

0

Territories

‚àí1

Biography

‚àí3

‚àí3
‚àí2

Wall time (seconds)

Siblings

‚àí3

Prior swapping for diverse topics.
= Diverse(0.5)

‚àí3

Coast

1. Origin(0.1)
4

3

Marriage

False-Posterior
4

x 10

2.5
2
1.5
1
0.5
0

Collapsed
Gibbs

Prior
Swapping

Figure 5. Latent factor models: (a) Prior swapping results for relational target priors (defined in (b)) over components in a mixture
model. (c) Prior swapping with a diversity-promoting target prior on an LDA topic model (Simple English Wikipedia corpus) to separate
redundant topic clusters; the top 6 words per topic are shown. In (a, c) we show wall times for the initial inference and prior swapping.

distributions can be computed analytically, which allows
for Gibbs sampling over these variables. Afterwards, samples of the collapsed factor parameters can be computed.
Hence, we propose the following strategy: first, assign a
prior for the factor parameters that allows for collapsed
Gibbs sampling; afterwards, reconstruct the factor samples
and apply prior swapping for more complex relational priors over the factors. We can thus perform convenient inference in the collapsed model, yet apply more-sophisticated
priors to variables in the uncollapsed model.
We first show results on a Gaussian mixture model (GMM),
written xi ‚àº N (¬µzi , Œ£zi ), zi ‚àº Dir(Œ±), {¬µm }M
m=1 ‚àº
œÄ, i = 1,...,n. Using a normal œÄf over {¬µm }M
m=1 allows
for collapsed Gibbs sampling. We also show results on a
topic model (latent Dirichlet allocation (LDA) (Blei et al.,
2003)) for text data (for the form of this model, see (Blei
et al., 2003; Wang & Blei, 2011)). Here, using a Dirichlet
œÄf over topics allows for collapsed Gibbs sampling. For
mixture models, we generate synthetic data from the above
model (n=10,000, d=2, M =9), and for topic models, we
use the Simple English Wikipedia‚Ä° corpus (n=27,443 documents, vocab=10,192 words), and set M =400 topics.
‚Ä°

https://simple.wikipedia.org/

In Fig. 5, we show results for mixture and topic models.
In (a) we show inferred posteriors over GMM components
for a number of relational target priors, which we define
in (b). In (c), we apply the diversity-promoting target
prior to LDA, to separate redundant topics. Here, we show
two topic clusters (‚Äúgeography‚Äù and ‚Äúfamily‚Äù) in pf (Œ∏|xn ),
which are separated into distinct, yet thematically-similar,
topics after prior swapping. In (a) and (c) we also show
wall times of the inference methods.

4. Conclusion
Given some false posterior inference result, and an arbitrary target prior, we have studied methods to accurately
compute the associated target posterior (or expectations
with respect to it), and to do this efficiently by leveraging the pre-inferred result. We have argued and shown empirically that this strategy is effective even when the false
and target posteriors are quite dissimilar. We believe that
this strategy shows promise to allow a wider range of (and
possibly less-costly) inference alorithms to be applied to
certain models, and to allow updated or new prior information to be more-easily incorporated into models without
re-incurring the full costs of standard inference algorithms.

Post-Inference Prior Swapping

References
Besag, Julian, Green, Peter, Higdon, David, and
Mengersen, Kerrie. Bayesian computation and stochastic systems. Statistical science, pp. 3‚Äì41, 1995.
Blei, David M, Ng, Andrew Y, and Jordan, Michael I. Latent dirichlet allocation. The Journal of Machine Learning Research, 3:993‚Äì1022, 2003.
Bornn, Luke, Doucet, Arnaud, and Gottardo, Raphael.
An efficient computational approach for prior sensitivity analysis and cross-validation. Canadian Journal of
Statistics, 38(1):47‚Äì64, 2010.
Diaconis, Persi, Ylvisaker, Donald, et al. Conjugate priors
for exponential families. The Annals of statistics, 7(2):
269‚Äì281, 1979.
Doucet, Arnaud, Godsill, Simon, and Andrieu, Christophe.
On sequential monte carlo sampling methods for
bayesian filtering. Statistics and computing, 10(3):197‚Äì
208, 2000.
Gerwinn, Sebastian, Macke, Jakob H, and Bethge,
Matthias. Bayesian inference for generalized linear models for spiking neurons. Frontiers in Computational Neuroscience, 4(12), 2010.
Geweke, John. Bayesian inference in econometric models
using monte carlo integration. Econometrica: Journal of
the Econometric Society, pp. 1317‚Äì1339, 1989.
Hastings, W Keith. Monte carlo sampling methods using
markov chains and their applications. Biometrika, 57(1):
97‚Äì109, 1970.

Metropolis, Nicholas, Rosenbluth, Arianna W, Rosenbluth,
Marshall N, Teller, Augusta H, and Teller, Edward.
Equation of state calculations by fast computing machines. The journal of chemical physics, 21(6):1087‚Äì
1092, 1953.
Minka, Thomas P. Expectation propagation for approximate bayesian inference. In Proceedings of the Seventeenth conference on Uncertainty in artificial intelligence, pp. 362‚Äì369. Morgan Kaufmann Publishers Inc.,
2001.
Neal, R. MCMC using hamiltonian dynamics. Handbook
of Markov Chain Monte Carlo, pp. 113‚Äì162, 2011.
Rossky, PJ, Doll, JD, and Friedman, HL. Brownian dynamics as smart monte carlo simulation. The Journal of
Chemical Physics, 69(10):4628‚Äì4633, 1978.
Seeger, Matthias W. Bayesian inference and optimal design for the sparse linear model. The Journal of Machine
Learning Research, 9:759‚Äì813, 2008.
Smith, Adrian FM and Roberts, Gareth O. Bayesian computation via the gibbs sampler and related markov chain
monte carlo methods. Journal of the Royal Statistical
Society. Series B (Methodological), pp. 3‚Äì23, 1993.
Teh, Yee W, Newman, David, and Welling, Max. A collapsed variational bayesian inference algorithm for latent
dirichlet allocation. In Advances in neural information
processing systems, pp. 1353‚Äì1360, 2006.
Tibshirani, Robert. Regression shrinkage and selection via
the lasso. Journal of the Royal Statistical Society. Series
B (Methodological), pp. 267‚Äì288, 1996.

Hjort, Nils Lid and Glad, Ingrid K. Nonparametric density
estimation with a parametric start. The Annals of Statistics, pp. 882‚Äì904, 1995.

Wang, Chong and Blei, David M. Collaborative topic modeling for recommending scientific articles. In Proceedings of the 17th ACM SIGKDD international conference
on Knowledge discovery and data mining, pp. 448‚Äì456.
ACM, 2011.

HyvaÃàrinen, Aapo. Estimation of non-normalized statistical
models by score matching. Journal of Machine Learning
Research, 6(Apr):695‚Äì709, 2005.

Wang, Chong and Blei, David M. Variational inference in
nonconjugate models. The Journal of Machine Learning
Research, 14(1):1005‚Äì1031, 2013.

Knowles, David and Ghahramani, Zoubin. Nonparametric
bayesian sparse factor models with application to gene
expression modeling. The Annals of Applied Statistics,
pp. 1534‚Äì1552, 2011.

Wasserman, Larry.
All of nonparametric statistics.
Springer Science & Business Media, 2006.

Kwok, James T and Adams, Ryan P. Priors for diversity in
generative latent variable models. In Advances in Neural
Information Processing Systems, pp. 2996‚Äì3004, 2012.
Mayrink, Vinicius Diniz, Lucas, Joseph Edward, et al.
Sparse latent factor models with interactions: Analysis
of gene expression data. The Annals of Applied Statistics, 7(2):799‚Äì822, 2013.

Xie, Pengtao, Zhu, Jun, and Xing, Eric. Diversitypromoting bayesian learning of latent variable models.
In Proceedings of the 33st International Conference on
Machine Learning (ICML-16), 2016.

