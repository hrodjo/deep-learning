An Alternative Softmax Operator for Reinforcement Learning

Kavosh Asadi 1 Michael L. Littman 1

Abstract
A softmax operator applied to a set of values
acts somewhat like the maximization function
and somewhat like an average. In sequential
decision making, softmax is often used in
settings where it is necessary to maximize utility
but also to hedge against problems that arise
from putting all of one‚Äôs weight behind a single
maximum utility decision.
The Boltzmann
softmax operator is the most commonly used
softmax operator in this setting, but we show
that this operator is prone to misbehavior. In
this work, we study a differentiable softmax
operator that, among other properties, is a
non-expansion ensuring a convergent behavior in
learning and planning. We introduce a variant
of SARSA algorithm that, by utilizing the new
operator, computes a Boltzmann policy with
a state-dependent temperature parameter. We
show that the algorithm is convergent and that it
performs favorably in practice.

1. Introduction
There is a fundamental tension in decision making
between choosing the action that has highest expected
utility and avoiding ‚Äústarving‚Äù the other actions. The issue
arises in the context of the exploration‚Äìexploitation
dilemma (Thrun, 1992),
non-stationary decision
problems (Sutton, 1990), and when interpreting observed
decisions (Baker et al., 2007).
In reinforcement learning, an approach to addressing the
tension is the use of softmax operators for value-function
optimization, and softmax policies for action selection.
Examples include value-based methods such as SARSA
(Rummery & Niranjan, 1994) or expected SARSA (Sutton
& Barto, 1998; Van Seijen et al., 2009), and policy-search
methods such as REINFORCE (Williams, 1992).
1
Brown University, USA. Correspondence to: Kavosh Asadi
<kavosh@brown.edu>.

Proceedings of the 34 th International Conference on Machine
Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017
by the author(s).

An ideal softmax operator is a parameterized set of
operators that:
1. has parameter settings that allow it to approximate
maximization arbitrarily accurately to perform
reward-seeking behavior;
2. is a non-expansion for all parameter settings ensuring
convergence to a unique fixed point;
3. is differentiable to make it possible to improve via
gradient-based optimization; and
4. avoids the starvation of non-maximizing actions.
Let X = x1 , . . . , xn be a vector of values. We define the
following operators:
max(X) =

max

i‚àà{1,...,n}

mean(X) =

xi ,

n
1 X
xi ,
n i=1

eps (X) =  mean(X) + (1 ‚àí ) max(X) ,
Pn
Œ≤xi
i=1 xi e
boltzŒ≤ (X) = P
.
n
Œ≤xi
i=1 e

The first operator, max(X), is known to be a
non-expansion (Littman & SzepesvaÃÅri, 1996). However,
it is non-differentiable (Property 3), and ignores
non-maximizing selections (Property 4).
The next operator, mean(X), computes the average of its
inputs. It is differentiable and, like any operator that takes a
fixed convex combination of its inputs, is a non-expansion.
However, it does not allow for maximization (Property 1).
The third operator eps (X), commonly referred to as
epsilon greedy (Sutton & Barto, 1998), interpolates
between max and mean. The operator is a non-expansion,
because it is a convex combination of two non-expansion
operators. But it is non-differentiable (Property 3).
The Boltzmann operator boltzŒ≤ (X) is differentiable. It
also approximates max as Œ≤ ‚Üí ‚àû, and mean as Œ≤ ‚Üí
0. However, it is not a non-expansion (Property 2), and
therefore, prone to misbehavior as will be shown in the next
section.

An Alternative Softmax Operator for Reinforcement Learning

0.66

+0.122

0.34

a
S2

S1

b
0.99

+0.033

0.01

Figure 1. A simple MDP with two states, two actions, and
Œ≥ = 0.98 . The use of a Boltzmann softmax policy is not sound
in this simple domain.

In the following section, we provide a simple example
illustrating why the non-expansion property is important,
especially in the context of planning and on-policy
learning.
We then present a new softmax operator
that is similar to the Boltzmann operator yet is a
non-expansion. We prove several critical properties of this
new operator, introduce a new softmax policy, and present
empirical results.

2. Boltzmann Misbehaves
We first show that boltzŒ≤ can lead to problematic behavior.
To this end, we ran SARSA with Boltzmann softmax policy
(Algorithm 1) on the MDP shown in Figure 1. The edges
are labeled with a transition probability (unsigned) and a
reward number (signed). Also, state s2 is a terminal state,
so we only consider two action values, namely QÃÇ(s1 , a)
and QÃÇ(s2 , b). Recall that the Boltzmann softmax policy
assigns the following probability to each action:
eŒ≤ QÃÇ(s,a)
œÄ(a|s) = P
.
Œ≤ QÃÇ(s,a)
ae
Algorithm 1 SARSA with Boltzmann softmax policy
Input: initial QÃÇ(s, a) ‚àÄs ‚àà S ‚àÄa ‚àà A, Œ±, and Œ≤
for each episode do
Initialize s
a ‚àº Boltzmann with parameter Œ≤
repeat
Take action a, observe r, s0
0
a ‚àº Boltzmann with parameter
Œ≤
h
i
QÃÇ(s, a) ‚Üê QÃÇ(s, a) + Œ± r + Œ≥ QÃÇ(s0 , a0 ) ‚àí QÃÇ(s, a)
0

0

s ‚Üê s ,a ‚Üê a
until s is terminal
end for

In Figure 2, we plot state‚Äìaction value estimates at the end
of each episode of a single run (smoothed by averaging
over ten consecutive points). We set Œ± = .1 and Œ≤ = 16.55.
The value estimates are unstable.

episode number

Figure 2. Values estimated by SARSA with Boltzmann softmax.
The algorithm never achieves stable values.

SARSA is known to converge in the tabular setting using
-greedy exploration (Littman & SzepesvaÃÅri, 1996), under
decreasing exploration (Singh et al., 2000), and to a region
in the function-approximation setting (Gordon, 2001).
There are also variants of the SARSA update rule that
converge more generally (Perkins & Precup, 2002; Baird
& Moore, 1999; Van Seijen et al., 2009). However, this
example is the first, to our knowledge, to show that SARSA
fails to converge in the tabular setting with Boltzmann
policy. The next section provides background for our
analysis of the example.

3. Background
A Markov decision process (Puterman, 1994), or MDP,
is specified by the tuple hS, A, R, P, Œ≥i, where S is the
set of states and A is the set of actions. The functions
R : S √ó A ‚Üí R and P : S √ó A √ó S ‚Üí [0, 1] denote the
reward and transition dynamics of the MDP. Finally, Œ≥ ‚àà
[0, 1), the discount rate, determines the relative importance
of immediate reward as opposed to the rewards received in
the future.
A typical approach to finding a good policy is to estimate
how good it is to be in a particular state‚Äîthe state
value function. The value of a particular state s given
a policy œÄ and initial action a is written QœÄ (s, a). We
define the optimal value of a state‚Äìaction pair Q? (s, a) =
maxœÄ QœÄ (s, a). It is possible to define Q? (s, a) recursively
and as a function of the optimal value of the other
state‚Äìaction pairs:
Q? (s, a) = R(s, a) +

X

s0 ‚ààS

Œ≥ P(s, a, s0 ) max
Q? (s0 , a0 ) .
0
a

Bellman equations, such as the above, are at the core
of many reinforcement-learning algorithms such as Value
Iteration (Bellman, 1957). The algorithm computes the

An Alternative Softmax Operator for Reinforcement Learning

Ô£ø
5

5

max Q1 (s, a)
a

max Q2 (s, a) Ô£ø max Q1 (s, a)
a

a

Q2 (s, a)

Figure 4. Fixed points of GVI under boltzŒ≤ for varying Œ≤. Two
distinct fixed points (red and blue) co-exist for a range of Œ≤.

Figure 3. max is a non-expansion under the infinity norm.

value of the best policy in an iterative fashion:
X
QÃÇ(s, a) ‚Üê R(s, a) + Œ≥
P(s, a, s0 ) max
QÃÇ(s0 , a0 ).
0
a

s0 ‚ààS

Regardless of its initial value, QÃÇ will converge to Q‚àó .
Littman & SzepesvaÃÅri (1996) generalized this algorithmN
by
replacing the max operator by any arbitrary operator ,
resulting in the generalized value iteration (GVI) algorithm
with the following update rule:
X
O
QÃÇ(s, a) ‚Üê R(s, a)+Œ≥
Œ≥P(s, a, s0 )
QÃÇ(s0 , a0 ). (1)
a0

s0 ‚ààS

fixed point. However, the Boltzmann softmax operator,
boltzŒ≤ , is not a non-expansion (Littman, 1996). Note that
we can relate GVI to SARSA by observing that SARSA‚Äôs
update is a stochastic implementation of GVI‚Äôs update.
Under a Boltzmann softmax policy œÄ, the target of the
(expected) SARSA update is the following:
 

E r + Œ≥ QÃÇ(s0 , a0 )s, a =
œÄ
X
X
R(s, a) + Œ≥
P(s, a, s0 )
œÄ(a0 |s0 )QÃÇ(s0 , a0 ) .
s0 ‚ààS

a0 ‚ààA

{z

boltzŒ≤ QÃÇ(s0 ,¬∑)
N
This matches the GVI update (1) when
= boltzŒ≤ .
|

}

4. Boltzmann Has Multiple Fixed Points
Algorithm 2 GVI algorithm
Input: initial QÃÇ(s, a) ‚àÄs ‚àà S ‚àÄa ‚àà A and Œ¥ ‚àà R+
repeat
diff ‚Üê 0
for each s ‚àà S do
for each a ‚àà A do
Qcopy ‚Üê QÃÇ(s, a)
P
QÃÇ(s, a) ‚Üê s0 ‚ààS R(s, a, s0 )
N
0
0
+ Œ≥P(s,
 a, s ) QÃÇ(s , .)
	
diff ‚Üê max diff, |Qcopy ‚àí QÃÇ(s, a)|
end for
end for
until diff < Œ¥

Crucially, convergence
N of GVI to a unique fixed point
follows if operator
is a non-expansion with respect to
the infinity norm:
O



O




QÃÇ(s, a) ‚àí
QÃÇ0 (s, a) ‚â§ max QÃÇ(s, a) ‚àí QÃÇ0 (s, a),

a

a

a

for any QÃÇ, QÃÇ0 and s. As mentioned earlier, the max
operator is known to be a non-expansion, as illustrated in
Figure 3. mean and eps operators are also non-expansions.
N
Therefore, each of these operators can play the role of
in
GVI, resulting in convergence to the corresponding unique

Although it has been known for a long time that the
Boltzmann operator is not a non-expansion (Littman,
1996), we are not aware of a published example of an
MDP for which two distinct fixed points exist. The MDP
presented in Figure 1 is the first example where, as shown
in Figure 4, GVI under boltzŒ≤ has two distinct fixed points.
We also show, in Figure 5, a vector field visualizing
GVI updates under boltzŒ≤=16.55 . The updates can move
the current estimates farther from the fixed points. The
behavior of SARSA (Figure 2) results from the algorithm
stochastically bouncing back and forth between the two
fixed points. When the learning algorithm performs a
sequence of noisy updates, it moves from a fixed point to
the other. As we will show later, planning will also progress
extremely slowly near the fixed points. The lack of the
non-expansion property leads to multiple fixed points and
ultimately a misbehavior in learning and planning.

5. Mellowmax and its Properties
We advocate for an alternative softmax operator defined as
follows:
Pn
log( n1 i=1 eœâxi )
mmœâ (X) =
,
œâ
which can be viewed as a particular instantiation of the
quasi-arithmetic mean (Beliakov et al., 2016). It can also

An Alternative Softmax Operator for Reinforcement Learning

Pn


eœâ‚àÜi‚àó i=1 eœâyi

Pn œây
/œâ 
= log
i
i=1 e



 

œâ‚àÜi‚àó

)/œâ  = ‚àÜi‚àó  = max xi ‚àí yi  ,
= log(e
i

allowing us to conclude that mellowmax is a non-expansion
under the infinity norm.
5.2. Maximization

Figure 5. A vector field showing GVI updates under boltzŒ≤=16.55 .
Fixed points are marked in black. For some points, such as the
large blue point, updates can move the current estimates farther
from the fixed points. Also, for points that lie in between the two
fixed-points, progress is extremely slow.

be derived from information theoretical principles as a way
of regularizing policies with a cost function defined by KL
divergence (Todorov, 2006; Rubin et al., 2012; Fox et al.,
2016). Note that the operator has previously been utilized
in other areas, such as power engineering (Safak, 1993).
We show that mmœâ , which we refer to as mellowmax, has
the desired properties and that it compares quite favorably
to boltzŒ≤ in practice.

Mellowmax includes parameter settings that allow for
maximization (Property 1) as well as for minimization. In
particular, as œâ goes to infinity, mmœâ acts like max.
Let m = max(X) and let W = |{xi = m|i ‚àà
{1, . . . , n}}|. Note that W ‚â• 1 is the number of maximum
values (‚Äúwinners‚Äù) in X. Then:
Pn
log( n1 i=1 eœâxi )
lim mmœâ (X) = lim
œâ‚Üí‚àû
œâ‚Üí‚àû
œâ
Pn
log( n1 eœâm i=1 eœâ(xi ‚àím) )
= lim
œâ‚Üí‚àû
œâ
log( n1 eœâm W )
= lim
œâ‚Üí‚àû
œâ
log(eœâm ) ‚àí log(n) + log(W )
= lim
œâ‚Üí‚àû
œâ
‚àí log(n) + log(W )
= m + lim
œâ‚Üí‚àû
œâ
= m = max(X) .

5.1. Mellowmax is a Non-Expansion
We prove that mmœâ is a non-expansion (Property 2), and
therefore, GVI and SARSA under mmœâ are guaranteed to
converge to a unique fixed point.
Let X = x1 , . . . , xn and Y = y1 , . . . , yn be two vectors
of values. Let ‚àÜi = xi ‚àí yi for i ‚àà {1, . . . , n} be the
difference of the ith components of the two vectors. Also,
let i‚àó be the index with the maximum component-wise
difference, i‚àó = argmaxi ‚àÜi . For simplicity, we assume
that i‚àó is unique and œâ > 0. Also, without loss of
generality, we assume that xi‚àó ‚àí yi‚àó ‚â• 0. It follows that:


mmœâ (X) ‚àí mmœâ (Y)
n
n


1 X œâxi
1 X œâyi
=  log(
e )/œâ ‚àí log(
e )/œâ 
n i=1
n i=1
P
n
1


eœâxi

=  log n1 Pi=1
/œâ
n
œâyi
i=1 e
n

Pn œâ yi +‚àÜi


e
Pn œây
/œâ 
=  log i=1
i
i=1 e

Pn œâ yi +‚àÜi‚àó


e
Pn œây
‚â§  log i=1
/œâ 
i
i=1 e

That is, the operator acts more and more like pure
maximization as the value of œâ is increased. Conversely,
as œâ goes to ‚àí‚àû, the operator approaches the minimum.
5.3. Derivatives
We can take the derivative of mellowmax with respect to
each one of the arguments xi and for any non-zero œâ:
‚àÇmmœâ (X)
eœâxi
= Pn œâx ‚â• 0 .
i
‚àÇxi
i=1 e

Note that the operator is non-decreasing in each component
of X.
Moreover, we can take the derivative of mellowmax
with
Pn
respect to œâ. We define nœâ (X) = log( n1 i=1 eœâxi ) and
dœâ (X) = œâ. Then:
Pn
xi eœâxi
‚àÇnœâ (X)
‚àÇdœâ (X)
= Pi=1
and
=1,
n
œâxi
‚àÇœâ
‚àÇœâ
e
i=1
and so:

‚àÇmmœâ (X)
=
‚àÇœâ

‚àÇnœâ (X)
‚àÇœâ dœâ (X)

œâ (X)
‚àí nœâ (X) ‚àÇd‚àÇœâ
,
dœâ (X)2

ensuring differentiablity of the operator (Property 3).

An Alternative Softmax Operator for Reinforcement Learning

5.4. Averaging
Because of the division by œâ in the definition of mmœâ ,
the parameter œâ cannot be set to zero. However, we can
examine the behavior of mmœâ as œâ approaches zero and
show that the operator computes an average in the limit.

multipliers. Here, the Lagrangian is:
X

L(œÄ, Œª1 , Œª2 ) =
œÄ(a|s) log œÄ(a|s)
‚àíŒª1

Since both the numerator and denominator go to zero as œâ
goes to zero, we will use L‚ÄôHoÃÇpital‚Äôs rule and the derivative
given in the previous section to derive the value in the limit:

lim mmœâ (X)

=

œâ‚Üí0

L‚ÄôHoÃÇpital

=

lim

œâ‚Üí0

lim

œâ‚Üí0
n

=

log( n1

Pn

i=1

1X
xi = mean(X) .
n i=1

6. Maximum Entropy Mellowmax Policy
As described, mmœâ computes a value for a list of
numbers somewhere between its minimum and maximum.
However, it is often useful to actually provide a probability
distribution over the actions such that (1) a non-zero
probability mass is assigned to each action, and (2) the
resulting expected value equals the computed value. Such
a probability distribution can then be used for action
selection in algorithms such as SARSA.
In this section, we address the problem of identifying
such a probability distribution as a maximum entropy
problem‚Äîover all distributions that satisfy the properties
above, pick the one that maximizes information
entropy (Cover & Thomas, 2006; Peters et al., 2010).
We formally define the maximum entropy mellowmax
policy of a state s as:

œÄ

P

X

a‚ààA


œÄ(a|s) log œÄ(a|s)

a‚ààA


œÄ(a|s) ‚àí 1


œÄ(a|s)QÃÇ(s, a) ‚àí mmœâ QÃÇ(s, .) .


‚àÇL
= log œÄ(a|s) +1‚àíŒª1 ‚àíŒª2 QÃÇ(s, a) = 0 ‚àÄ a ‚àà A .
‚àÇœÄ(a|s)

That is, as œâ gets closer to zero, mmœâ (X) approaches the
mean of the values in X.

œÄmm (s) = argmin

a‚ààA

X

a‚ààA

Taking the partial derivative of the Lagrangian with respect
to each œÄ(a|s) and setting them to zero, we obtain:

eœâxi )

œâ
Pn
xi eœâxi
Pi=1
n
1
œâxi
i=1 e
n

1
n

‚àíŒª2

X

(2)

These |A| equations, together with the two linear
constraints in (2), form |A| + 2 equations to constrain the
|A| + 2 variables œÄ(a|s) ‚àÄa ‚àà A and the two Lagrangian
multipliers Œª1 and Œª2 .
Solving this system of equations, the probability of taking
an action under the maximum entropy mellowmax policy
has the form:
œÄmm (a|s) = P

eŒ≤ QÃÇ(s,a)

a‚ààA

eŒ≤ QÃÇ(s,a)

‚àÄa ‚àà A ,

where Œ≤ is a value for which:
X Œ≤ QÃÇ(s,a)‚àímm QÃÇ(s,.)

œâ
QÃÇ(s, a) ‚àí mmœâ QÃÇ(s, .) = 0 .
e
a‚ààA

The argument for the existence of a unique root is simple.
As Œ≤ ‚Üí ‚àû the term corresponding to the best action
dominates, and so, the function is positive. Conversely,
as Œ≤ ‚Üí ‚àí‚àû the term corresponding to the action with
lowest utility dominates, and so the function is negative.
Finally, by taking the derivative, it is clear that the function
is monotonically increasing, allowing us to conclude that
there exists only a single root. Therefore, we can find Œ≤
easily using any root-finding algorithm. In particular, we
use Brent‚Äôs method (Brent, 2013) available in the Numpy
library of Python.

Note that this optimization problem is convex and can be
solved reliably using any numerical convex optimization
library.

This policy has the same form as Boltzmann softmax, but
with a parameter Œ≤ whose value depends indirectly on
œâ. This mathematical form arose not from the structure
of mmœâ , but from maximizing the entropy. One way to
view the use of the mellowmax operator, then, is as a form
of Boltzmann policy with a temperature parameter chosen
adaptively in each state to ensure that the non-expansion
property holds.

One way of finding the solution, which leads to an
interesting policy form, is to use the method of Lagrange

Finally, note that the SARSA update under the maximum
entropy mellowmax policy could be thought of as a

subject to

n

œÄ(a|s)QÃÇ(s, a) = mmœâ (QÃÇ(s, .))
œÄ(a|s)
‚â•0
P
œÄ(a|s)
=1.
a‚ààA
a‚ààA

An Alternative Softmax Operator for Reinforcement Learning

Figure 7. Number of iterations before termination of GVI on the
example MDP. GVI under mmœâ outperforms the alternatives.
Figure 6. GVI updates under mmœâ=16.55 . The fixed point is
unique, and all updates move quickly toward the fixed point.

experiment is a policy gradient experiment where a deep
neural network, with a softmax output layer, is used to
directly represent the policy.

stochastic implementation of the GVI update under the
mmœâ operator:
7.1. Random MDPs



The example in Figure 1 was created carefully by hand. It
E r + Œ≥ QÃÇ(s0 , a0 )s, a =
œÄmm
X
X
 is interesting to know whether such examples are likely to
R(s, a, s0 ) + Œ≥P(s, a, s0 )
œÄmm (a0 |s0 )QÃÇ(s0 , a0 ) be encountered naturally. To this end, we constructed 200
s0 ‚ààS
a0 ‚ààA
MDPs as follows: We sampled |S| from {2, 3, ..., 10} and
{z
}
|

|A| from {2, 3, 4, 5} uniformly at random. We initialized
mmœâ QÃÇ(s0 ,.)
the transition probabilities by sampling uniformly from
[0, .01]. We then added to each entry, with probability 0.5,
due to the first constraint of the convex optimization
Gaussian noise with mean 1 and variance 0.1. We next
problem (2). Because mellowmax is a non-expansion,
added, with probability 0.1, Gaussian noise with mean 100
SARSA with the maximum entropy mellowmax policy is
and variance 1. Finally, we normalized the raw values to
guaranteed to converge to a unique fixed point. Note also
ensure that we get a transition matrix. We did a similar
that, similar to other variants of SARSA, the algorithm
process for rewards, with the difference that we divided
simply bootstraps using the value of the next state while
each entry by the maximum entry and multiplied by 0.5
implementing the new policy.
to ensure that Rmax = 0.5 .

7. Experiments on MDPs
We observed that in practice computing mellowmax can
yield overflow if the exponentiated values are large. In this
case, we can safely shift the values by a constant before
exponentiating them due to the following equality:
Pn
Pn
log( n1 i=1 eœâxi )
log( n1 i=1 eœâ(xi ‚àíc) )
=c+
.
œâ
œâ
A value of c = maxi xi usually avoids overflow.
We repeat the experiment from Figure 5 for mellowmax
with œâ = 16.55 to get a vector field. The result, presented
in Figure 6, show a rapid and steady convergence towards
the unique fixed point. As a result, GVI under mmœâ can
terminate significantly faster than GVI under boltzŒ≤ , as
illustrated in Figure 7.
We present three additional experiments.
The first
experiment investigates the behavior of GVI with the
softmax operators on randomly generated MDPs. The
second experiment evaluates the softmax policies when
used in SARSA with a tabular representation. The last

We measured the failure rate of GVI under boltzŒ≤ and
mmœâ by stopping GVI when it did not terminate in 1000
iterations. We also computed the average number of
iterations needed before termination. A summary of results
is presented in the table below. Mellowmax outperforms
Boltzmann based on the three measures provided below.

boltzŒ≤
mmœâ

MDPs, no
terminate
8 of 200
0

MDPs, > 1
fixed points
3 of 200
0

average
iterations
231.65
201.32

7.2. Multi-passenger Taxi Domain
We evaluated SARSA on the multi-passenger taxi domain
introduced by Dearden et al. (1998). (See Figure 8.)
One challenging aspect of this domain is that it admits
many locally optimal policies.
Exploration needs
to be set carefully to avoid either over-exploring
or under-exploring the state space.
Note also that
Boltzmann softmax performs remarkably well on
this domain, outperforming sophisticated Bayesian

An Alternative Softmax Operator for Reinforcement Learning
S

F

D

F
F

Figure 8. Multi-passenger taxi domain. The discount rate Œ≥ is
0.99. Reward is +1 for delivering one passenger, +3 for two
passengers, and +15 for three passengers. Reward is zero for all
the other transitions. Here F , S, and D denote passengers, start
state, and destination respectively.

reinforcement-learning algorithms (Dearden et al., 1998).
As shown in Figure 9, SARSA with the epsilon-greedy
policy performs poorly. In fact, in our experiment, the
algorithm rarely was able to deliver all the passengers.
However, SARSA with Boltzmann softmax and SARSA
with the maximum entropy mellowmax policy achieved
significantly higher average reward. Maximum entropy
mellowmax policy is no worse than Boltzmann softmax,
here, suggesting that the greater stability does not come at
the expense of less effective exploration.
7.3. Lunar Lander Domain
In this section, we evaluate the use of the maximum entropy
mellowmax policy in the context of a policy-gradient
algorithm. Specifically, we represent a policy by a
neural network (discussed below) that maps from states
to probabilities over actions. A common choice for the
activation function of the last layer is the Boltzmann
softmax policy. In contrast, we can use maximum entropy
mellowmax policy, presented in Section 6, by treating the
inputs of the activation function as QÃÇ values.
We used the lunar lander domain, from OpenAI Gym
(Brockman et al., 2016) as our benchmark. A screenshot
of the domain is presented in Figure 10. This domain has
a continuous state space with 8 dimensions, namely x-y
coordinates, x-y velocities, angle and angular velocities,
and leg-touchdown sensors. There are 4 discrete actions to
control 3 engines. The reward is +100 for a safe landing in
the designated area, and ‚àí100 for a crash. There is a small
shaping reward for approaching the landing area. Using the
engines results in a negative reward. An episode finishes
when the spacecraft crashes or lands. Solving the domain
is defined as maintaining mean episode return higher than
200 in 100 consecutive episodes.
The policy in our experiment is represented by a neural
network with a hidden layer comprised of 16 units with
RELU activation functions, followed by a second layer
with 16 units and softmax activation functions. We used
REINFORCE to train the network. A batch episode size

Figure 9. Comparison on the multi-passenger taxi domain.
Results are shown for different values of , Œ≤, and œâ. For each
setting, the learning rate is optimized. Results are averaged over
25 independent runs, each consisting of 300000 time steps.

Figure 10. A screenshot of the lunar lander domain.

of 10 was used, as we had stability issues with smaller
episode batch sizes. We used the Adam algorithm (Kingma
& Ba, 2014) with Œ± = 0.005 and the other parameters as
suggested by the paper. We used Keras (Chollet, 2015)
and Theano (Team et al., 2016) to implement the neural
network architecture. For each softmax policy, we present
in Figure 11 the learning curves for different values of
their free parameter. We further plot average return over
all 40000 episodes. Mellowmax outperforms Boltzmann at
its peak.

8. Related Work
Softmax operators play an important role in sequential
decision-making algorithms.
In model-free reinforcement learning, they can help strike

An Alternative Softmax Operator for Reinforcement Learning

Algorithms for inverse reinforcement learning (IRL), the
problem of inferring reward functions from observed
behavior (Ng & Russell, 2000), frequently use a
Boltzmann operator to avoid assigning zero probability
to non-optimal actions and hence assessing an observed
sequence as impossible. Such methods include Bayesian
IRL (Ramachandran & Amir, 2007), natural gradient
IRL (Neu & SzepesvaÃÅri, 2007), and maximum likelihood
IRL (Babes et al., 2011). Given the recursive nature of
value defined in these problems, mellowmax could be a
more stable and efficient choice.
In linearly solvable MDPs (Todorov, 2006), an operator
similar to mellowmax emerges when using an alternative
characterization for cost of action selection in MDPs.
Inspired by this work Fox et al. (2016) introduced an
off-policy G-learning algorithm that uses the operator to
perform value-function updates. Instead of performing
off-policy updates, we introduced a convergent variant
of SARSA with Boltzmann policy and a state-dependent
temperature parameter. This is in contrast to Fox et al.
(2016) where an epsilon greedy behavior policy is used.

Figure 11. Comparison of Boltzmann (top) and maximum
entropy mellowmax (middle) in Lunar Lander. Mean return over
all episodes (bottom). Results are 400-run averages.

a balance between exploration (mean) and exploitation
(max). Decision rules based on epsilon-greedy and
Boltzmann softmax, while very simple, often perform
surprisingly well in practice, even outperforming more
advanced exploration techniques (Kuleshov & Precup,
2014) that require significant approximation for complex
domains.
When learning ‚Äúon policy‚Äù, exploration
steps can (Rummery & Niranjan, 1994) and perhaps
should (John, 1994) become part of the value-estimation
process itself. On-policy algorithms like SARSA can be
made to converge to optimal behavior in the limit when the
exploration rate and the update operator is gradually moved
toward max (Singh et al., 2000). Our use of softmax in
learning updates reflects this point of view and shows that
the value-sensitive behavior of Boltzmann exploration can
be maintained even as updates are made stable.
Analyses of the behavior of human subjects in choice
experiments very frequently use softmax. Sometimes
referred to in the literature as logit choice (Stahl &
Wilson, 1994), it forms an important part of the most
accurate predictor of human decisions in normal-form
games (Wright & Leyton-Brown, 2010), quantal level-k
reasoning (QLk). Softmax-based fixed points play a crucial
role in this work. As such, mellowmax could potentially
make a good replacement.

9. Conclusion and Future Work
We proposed the mellowmax operator as an alternative
to the Boltzmann softmax operator. We showed that
mellowmax has several desirable properties and that it
works favorably in practice.
Arguably, mellowmax
could be used in place of Boltzmann throughout
reinforcement-learning research.
A future direction is to analyze the fixed point
of planning, reinforcement-learning, and game-playing
algorithms when using the mellowmax operators. In
particular, an interesting analysis could be one that bounds
the sub-optimality of the fixed points found by GVI.
An important future work is to expand the scope of our
theoretical understanding to the more general function
approximation setting, in which the state space or the
action space is large and abstraction techniques are used.
Note that the importance of non-expansion in the function
approximation case is well-established. (Gordon, 1995)
Finally, due to the convexity of mellowmax (Boyd &
Vandenberghe, 2004), it is compelling to use it in a
gradient-based algorithm in the context of sequential
decision making. IRL is a natural candidate given the
popularity of softmax in this setting.

10. Acknowledgments
The authors gratefully acknowledge the assistance of
George D. Konidaris, as well as anonymous ICML
reviewers for their outstanding feedback.

An Alternative Softmax Operator for Reinforcement Learning

References
Babes, Monica, Marivate, Vukosi N., Littman, Michael L.,
and Subramanian, Kaushik. Apprenticeship learning
about multiple intentions. In International Conference
on Machine Learning, pp. 897‚Äì904, 2011.
Baird, Leemon and Moore, Andrew W. Gradient descent
for general reinforcement learning. In Advances in
Neural Information Processing Systems, pp. 968‚Äì974,
1999.
Baker, Chris L, Tenenbaum, Joshua B, and Saxe,
Rebecca R. Goal inference as inverse planning. In
Proceedings of the 29th Annual Meeting of the Cognitive
Science Society, 2007.
Beliakov, Gleb, Sola, Humberto Bustince, and SaÃÅnchez,
Tomasa Calvo.
A Practical Guide to Averaging
Functions. Springer, 2016.
Bellman, Richard. A Markovian decision process. Journal
of Mathematics and Mechanics, 6(5):679‚Äì684, 1957.
Boyd, S.P. and Vandenberghe, L. Convex optimization.
Cambridge University Press, 2004.
Brent, Richard P. Algorithms for minimization without
derivatives. Courier Corporation, 2013.
Brockman, Greg, Cheung, Vicki, Pettersson, Ludwig,
Schneider, Jonas, Schulman, John, Tang, Jie, and
Zaremba, Wojciech. Openai gym, 2016.
Chollet, FrancÃßois. Keras. https://github.com/
fchollet/keras, 2015.
Cover, T.M. and Thomas, J.A. Elements of Information
Theory. John Wiley and Sons, 2006.
Dearden, Richard, Friedman, Nir, and Russell, Stuart.
Bayesian Q-learning. In Fifteenth National Conference
on Artificial Intelligence (AAAI), pp. 761‚Äì768, 1998.
Fox, Roy, Pakman, Ari, and Tishby, Naftali. Taming
the noise in reinforcement learning via soft updates.
In Proceedings of the Thirty-Second Conference on
Uncertainty in Artificial Intelligence, pp. 202‚Äì211.
AUAI Press, 2016.
Gordon, Geoffrey J.
Stable function approximation
in dynamic programming.
In Proceedings of the
twelfth international conference on machine learning,
pp. 261‚Äì268, 1995.
Gordon, Geoffrey J.
Reinforcement learning with
function approximation converges to a region, 2001.
Unpublished.

John, George H. When the best move isn‚Äôt optimal:
Q-learning with exploration. In Proceedings of the
Twelfth National Conference on Artificial Intelligence,
pp. 1464, Seattle, WA, 1994.
Kingma, Diederik and Ba, Jimmy.
method for stochastic optimization.
arXiv:1412.6980, 2014.

Adam: A
arXiv preprint

Kuleshov, Volodymyr and Precup, Doina. Algorithms
for multi-armed bandit problems.
arXiv preprint
arXiv:1402.6028, 2014.
Littman, Michael L. and SzepesvaÃÅri, Csaba.
A
generalized reinforcement-learning model: Convergence
and applications. In Saitta, Lorenza (ed.), Proceedings
of the Thirteenth International Conference on Machine
Learning, pp. 310‚Äì318, 1996.
Littman, Michael Lederman. Algorithms for Sequential
Decision Making. PhD thesis, Department of Computer
Science, Brown University, February 1996.
Also
Technical Report CS-96-09.
Neu, Gergely and SzepesvaÃÅri, Csaba. Apprenticeship
learning using inverse reinforcement learning and
gradient methods. In UAI, 2007.
Ng, Andrew Y. and Russell, Stuart. Algorithms for inverse
reinforcement learning. In International Conference on
Machine Learning, pp. 663‚Äì670, 2000.
Perkins, Theodore J and Precup, Doina. A convergent form
of approximate policy iteration. In Advances in Neural
Information Processing Systems, pp. 1595‚Äì1602, 2002.
Peters, Jan, MuÃàlling, Katharina, and Altun, Yasemin.
Relative entropy policy search. In AAAI. Atlanta, 2010.
Puterman,
Martin
L.
Markov
Decision
Processes‚ÄîDiscrete Stochastic Dynamic Programming.
John Wiley & Sons, Inc., New York, NY, 1994.
Ramachandran, Deepak and Amir, Eyal. Bayesian inverse
reinforcement learning. In IJCAI, 2007.
Rubin, Jonathan, Shamir, Ohad, and Tishby, Naftali.
Trading value and information in mdps. In Decision
Making with Imperfect Decision Makers, pp. 57‚Äì74.
Springer, 2012.
Rummery, G. A. and Niranjan, M. On-line Q-learning
using connectionist systems.
Technical Report
CUED/F-INFENG/TR 166, Cambridge University
Engineering Department, 1994.
Safak, Aysel. Statistical analysis of the power sum
of multiple correlated log-normal components. IEEE
Transactions on Vehicular Technology, 42(1):58‚Äì61,
1993.

An Alternative Softmax Operator for Reinforcement Learning

Singh, Satinder, Jaakkola, Tommi, Littman, Michael L.,
and SzepesvaÃÅri, Csaba.
Convergence results for
single-step on-policy reinforcement-learning algorithms.
Machine Learning, 39:287‚Äì308, 2000.
Stahl, Dale O. and Wilson, Paul W.
Experimental
evidence on players‚Äô models of other players. Journal of
Economic Behavior and Organization, 25(3):309‚Äì327,
1994.
Sutton, Richard S. Integrated architectures for learning,
planning, and reacting based on approximating dynamic
programming.
In Proceedings of the Seventh
International Conference on Machine Learning, pp.
216‚Äì224, Austin, TX, 1990. Morgan Kaufmann.
Sutton, Richard S. and Barto, Andrew G. Reinforcement
Learning: An Introduction. The MIT Press, 1998.
Team, The Theano Development, Al-Rfou, Rami, Alain,
Guillaume, Almahairi, Amjad, Angermueller, Christof,
Bahdanau, Dzmitry, Ballas, Nicolas, Bastien, FreÃÅdeÃÅric,
Bayer, Justin, Belikov, Anatoly, et al. Theano: A
python framework for fast computation of mathematical
expressions. arXiv preprint arXiv:1605.02688, 2016.
Thrun, Sebastian B. The role of exploration in learning
control. In White, David A. and Sofge, Donald A.
(eds.), Handbook of Intelligent Control: Neural, Fuzzy,
and Adaptive Approaches, pp. 527‚Äì559. Van Nostrand
Reinhold, New York, NY, 1992.
Todorov, Emanuel. Linearly-solvable markov decision
problems. In NIPS, pp. 1369‚Äì1376, 2006.
Van Seijen, Harm, Van Hasselt, Hado, Whiteson, Shimon,
and Wiering, Marco. A theoretical and empirical
analysis of Expected Sarsa. In 2009 IEEE Symposium
on Adaptive Dynamic Programming and Reinforcement
Learning, pp. 177‚Äì184. IEEE, 2009.
Williams, Ronald J. Simple statistical gradient-following
algorithms for connectionist reinforcement learning.
Machine Learning, 8(3):229‚Äì256, 1992.
Wright, James R. and Leyton-Brown, Kevin. Beyond
equilibrium: Predicting human behavior in normal-form
games. In AAAI, 2010.

