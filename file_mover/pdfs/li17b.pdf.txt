Provable Alternating Gradient Descent for Non-negative Matrix Factorization
with Strong Correlations

Yuanzhi Li 1 Yingyu Liang 1

Abstract
Non-negative matrix factorization is a basic tool
for decomposing data into the feature and weight
matrices under non-negativity constraints, and in
practice is often solved in the alternating minimization framework. However, it is unclear
whether such algorithms can recover the groundtruth feature matrix when the weights for different features are highly correlated, which is common in applications. This paper proposes a simple and natural alternating gradient descent based
algorithm, and shows that with a mild initialization it provably recovers the ground-truth in the
presence of strong correlations. In most interesting cases, the correlation can be in the same order
as the highest possible. Our analysis also reveals
its several favorable features including robustness to noise. We complement our theoretical
results with empirical studies on semi-synthetic
datasets, demonstrating its advantage over several popular methods in recovering the groundtruth.

1. Introduction
Non-negative matrix factorization (NMF) is an important
tool in data analysis and is widely used in image processing, text mining, and hyperspectral imaging (e.g., (Lee &
Seung, 1997; Blei et al., 2003; Yang & Leskovec, 2013)).
Given a set of observations Y = {y (1) , y (2) , . . . , y (n) },
the goal of NMF is to find a feature matrix A =
{a1 , a2 , . . . , aD } and a non-negative weight matrix X =
{x(1) , x(2) , . . . , x(n) } such that y (i) ≈ Ax(i) for any i, or
Y ≈ AX for short. The intuition of NMF is to write each
data point as a non-negative combination of the features.
1
Authors listed in alphabetic order.
Princeton University,
Princeton,
NJ, USA. Correspondence to:
Yuanzhi Li <yuanzhil@cs.princeton.edu>, Yingyu Liang
<yingyul@cs.princeton.edu>.

Proceedings of the 34 th International Conference on Machine
Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017
by the author(s).

By doing so, one can avoid cancellation of different features and improve interpretability by thinking of each x(i)
as a (unnormalized) probability distribution over the features. It is also observed empirically that the non-negativity
constraint on the coefficients can lead to better features and
improved downstream performance of the learned features.
Unlike the counterpart which factorizes Y ≈ AX without assuming non-negativity of X, NMF is usually much
harder to solve, and can even by NP-hard in the worse
case (Arora et al., 2012b). This explains why, despite all
the practical success, NMF largely remains a mystery in
theory. Moreover, many of the theoretical results for NMF
were based on very technical tools such has algebraic geometry (e.g., (Arora et al., 2012b)) or tensor decomposition (e.g. (Anandkumar et al., 2012)), which undermine
their applicability in practice. Arguably, the most widely
used algorithms for NMF use the alternative minimization
scheme: In each iteration, the algorithm alternatively keeps
A or X as fixed and tries to minimize some distance between Y and AX. Algorithms in this framework, such
as multiplicative update (Lee & Seung, 2001) and alternative non-negative least square (Kim & Park, 2008), usually
perform well on real world data. However, alternative minimization algorithms are usually notoriously difficult to analyze. This problem is poorly understood, with only a few
provable guarantees known (Awasthi & Risteski, 2015; Li
et al., 2016). Most importantly, these results are only for
the case when the coordinates of the weights are from essentially independent distributions, while in practice they
are known to be correlated, for example, in correlated topic
models (Blei & Lafferty, 2006). As far as we know, there
exists no rigorous analysis of practical algorithms for the
case with strong correlations.
In this paper, we provide a theoretical analysis of a natural algorithm AND (Alternative Non-negative gradient
Descent) that belongs to the practical framework, and show
that it probably recovers the ground-truth given a mild initialization. It works under general conditions on the feature
matrix and the weights, in particular, allowing strong correlations. It also has multiple favorable features that are
unique to its success. We further complement our theoretical analysis by experiments on semi-synthetic data, demon-

Provable Alternating Gradient Descent for Non-negative Matrix Factorization with Strong Correlations

strating that the algorithm converges faster to the groundtruth than several existing practical algorithms, and providing positive support for some of the unique features of our
algorithm. Our contributions are detailed below.
1.1. Contributions
In this paper, we assume a generative model of the data
points, given the ground-truth feature matrix A∗ . In each
round, we are given y = A∗ x,1 where x is sampled i.i.d.
from some unknown distribution µ and the goal is to recover the ground-truth feature matrix A∗ . We give an algorithm named AND that starts from a mild initialization
matrix and provably converges to A∗ in polynomial time.
We also justify the convergence through a sequence of experiments. Our algorithm has the following favorable characteristics.
1.1.1. S IMPLE G RADIENT D ESCENT A LGORITHM
The algorithm AND runs in stages and keeps a working
matrix A(t) in each stage. At the t-th iteration in a stage,
after getting one sample y, it performs the following:


(Decode) z = φα (A(0) )† y ,


(Update) A(t+1) = A(t) + η yz > − A(t) zz > ,
where α is a threshold parameter,

x if x ≥ α,
φα (x) =
0 otherwise,
(0) †

(0)

(A ) is the Moore-Penrose pesudo-inverse of A , and
η is the update step size. The decode step aims at recovering the corresponding weight for the data point, and the
update step uses the decoded weight to update the feature
matrix. The final working matrix at one stage will be used
as the A(0) in the next stage. See Algorithm 1 for the details.
At a high level, our update step to the feature matrix can be
thought of as a gradient descent version of alternative nonnegative least square (Kim & Park, 2008), which at each
iteration alternatively minimizes L(A, Z) = kY − AZk2F
by fixing A or Z. Our algorithm, instead of performing an complete minimization, performs only a stochastic gradient descent step on the feature matrix. To see
this, consider one data point y and consider minimizing
L(A, z) = ky − Azk2F with z fixed. Then the gradient
of A is just −∇L(A) = (y − Az)z > , which is exactly the
update of our feature matrix in each iteration.
As to the decode step, when α = 0, our decoding can be
regarded as a one-shot approach minimizing kY − AZk2F
1

We also consider the noisy case; see 1.1.5.

restricted to Z ≥ 0. Indeed, if for example projected gradient descent is used to minimize kY − AZk2F , then the
projection step is exactly applying φα to Z with α = 0. A
key ingredient of our algorithm is choosing α to be larger
than zero and then decreasing it, which allows us to outperform the standard algorithms.
Perhaps worth noting, our decoding only uses A(0) . Ideally, we would like to use (A(t) )† as the decoding matrix
in each iteration. However, such decoding method requires
computing the pseudo-inverse of A(t) at every step, which
is extremely slow. Instead, we divide the algorithm into
stages and in each stage, we only use the starting matrix
in the decoding, thus the pseudo-inverse only needs to be
computed once per stage and can be used across all iterations inside. We can show that our algorithm converges in
polylogarithmic many stages, thus gives us to a much better running time. These are made clear when we formally
present the algorithm in Section 4 and the theorems in Section 5 and 6.
1.1.2. H ANDLING STRONG CORRELATIONS
The most notable property of AND is that it can provably
deal with highly correlated distribution µ on the weight x,
meaning that the coordinates of x can have very strong
correlations with each other. This is important since such
correlated x naturally shows up in practice. For example,
when a document contains the topic “machine learning”, it
is more likely to contain the topic “computer science” than
“geography” (Blei & Lafferty, 2006).
Most of the previous theoretical approaches for analyzing alternating between decoding and encoding, such
as (Awasthi & Risteski, 2015; Li et al., 2016; Arora
et al., 2015), require the coordinates of x to be pairwiseindependent, or almost pairwise-independent (meaning
Eµ [xi xj ] ≈ Eµ [xi ]Eµ [xj ]). In this paper, we show that algorithm AND can recover A∗ even when the coordinates
are highly correlated. As one implication of our result,
when the sparsity of x is O(1) and each entry of x is in
{0, 1}, AND can recover A∗ even if each Eµ [xi xj ] =
Ω(min{Eµ [xi ], Eµ [xj ]}), matching (up to constant) the
highest correlation possible. Moreover, we do not assume
any prior knowledge about the distribution µ, and the result
also extends to general sparsities as well.
1.1.3. P SEUDO - INVERSE DECODING
One of the feature of our algorithm is to use Moore-Penrose
pesudo-inverse in decoding. Inverse decoding was also
used in (Li et al., 2016; Arora et al., 2015; 2016). However, their algorithms require carefully finding an inverse
such that certain norm is minimized, which is not as efficient as the vanilla Moore-Penrose pesudo-inverse. It was
also observed in (Arora et al., 2016) that Moore-Penrose

Provable Alternating Gradient Descent for Non-negative Matrix Factorization with Strong Correlations

pesudo-inverse works equally well in practice, but the experiment was done only when A = A∗ . In this paper, we
show that Moore-Penrose pesudo-inverse also works well
when A 6= A∗ , both theoretically and empirically.
1.1.4. T HRESHOLDING AT DIFFERENT α
Thresholding at a value α > 0 is a common trick used in
many algorithms. However, many of them still only consider a fixed α throughout the entire algorithm. Our contribution is a new method of thresholding that first sets α to
be high, and gradually decreases α as the algorithm goes.
Our analysis naturally provides the explicit rate at which
we decrease α, and shows that our algorithm, following this
scheme, can provably converge to the ground-truth A∗ in
polynomial time. Moreover, we also provide experimental
support for these choices.
1.1.5. ROBUSTNESS TO NOISE
We further show that the algorithm is robust to noise. In
particular, we consider the model y = A∗ x + ζ, where ζ
is the noise. The algorithm can tolerate a general family of
noise with bounded moments; we present in the main body
the result for a simplified case with Gaussian noise and provide the general result in the appendix. The algorithm can
recover the ground-truth matrix up to a small blow-up factor times the noise level in each example, when the groundtruth has a good condition number. This robustness is also
supported by our experiments.

2. Related Work
Practical algorithms. Non-negative matrix factorization
has a rich empirical history, starting with the practical algorithms of (Lee & Seung, 1997; 1999; 2001). It has been
widely used in applications and there exist various methods
for NMF, e.g., (Kim & Park, 2008; Lee & Seung, 2001; Cichocki et al., 2007; Ding et al., 2013; 2014). However, they
do not have provable recovery guarantees.
Theoretical analysis. For theoretical analysis, (Arora
et al., 2012b) provided a fixed-parameter tractable algorithm for NMF using algebraic equations. They also provided matching hardness results: namely they show there is
no algorithm running in time (mW )o(D) unless there is a
sub-exponential running time algorithm for 3-SAT. (Arora
et al., 2012b) also studied NMF under separability assumptions about the features, and (Bhattacharyya et al., 2016)
studied NMF under related assumptions. The most related work is (Li et al., 2016), which analyzed an alternating minimization type algorithm. However, the result
only holds with strong assumptions about the distribution
of the weight x, in particular, with the assumption that the
coordinates of x are independent.

Topic modeling. Topic modeling is a popular generative
model for text data (Blei et al., 2003; Blei, 2012). Usually, the model results in NMF type optimization problems
with kxk1 = 1, and a popular heuristic is variational inference, which can be regarded as alternating minimization in KL-divergence. Recently, there is a line of theoretical work analyzing tensor decomposition (Arora et al.,
2012a; 2013; Anandkumar et al., 2013) or combinatorial
methods (Awasthi & Risteski, 2015). These either need
strong structural assumptions on the word-topic matrix A∗ ,
or need to know the distribution of the weight x, which is
usually infeasible in applications.

3. Problem and Definitions
We use kMk2 to denote the 2-norm of a matrix M. kxk1
is the 1-norm of a vector x. We use [M]i to denote the ith row and [M]i to denote the i-th column of a matrix M.
σmax (M)(σmin (M)) stands for the maximum (minimal)
singular value of M, respectively. We consider a generative
model for non-negative matrix factorization, where the data
y is generated from2
y = A∗ x,

A∗ ∈ RW ×D

where A∗ is the ground-truth feature matrix, and x is a nonnegative random vector drawn from an unknown distribution µ. The goal is to recover the ground-truth A∗ from
i.i.d. samples of the observation y.
Since the general non-negative matrix factorization is NPhard (Arora et al., 2012b), some assumptions on the distribution of x need to be made. In this paper, we would like to
allow distributions as general as possible, especially those
with strong correlations. Therefore, we introduce the following notion called (r, k, m, λ)-general correlation conditions (GCC) for the distribution of x.
Definition 1 (General Correlation Conditions, GCC). Let
∆ := E[xx> ] denote the second moment matrix.
1. kxk1 ≤ r and xi ∈ [0, 1], ∀i ∈ [D].
2. ∆i,i ≤

2k
D , ∀i

3. ∆i,j ≤

m
D 2 , ∀i

4. ∆ 

∈ [D].
6= j ∈ [D].

k
D λI.

The first condition regularizes the sparsity of x.3 The second condition regularizes each coordinate of xi so that
there is no xi being large too often. The third condition
2

Section 6.2 considers the noisy case.
Throughout this paper, the sparsity of x refers to the `1 norm,
which is much weaker than the `0 norm (the support sparsity). For
example, in LDA, the `1 norm of x is always 1.
3

Provable Alternating Gradient Descent for Non-negative Matrix Factorization with Strong Correlations

regularizes the maximum pairwise correlation between xi
and xj . The fourth condition always holds for λ = 0 since
E[xx> ] is a PSD matrix. Later we will assume this condition holds for some λ > 0 to avoid degenerate cases. Note
that we put the weight k/D before λ such that λ defined
in this way will be a positive constant in many interesting
examples discussed below.
To get a sense of what are the ranges of k, m, and λ given
sparsity r, we consider the following most commonly studied non-negative random variables.
Proposition 1 (Examples of GCC).
1. If x is chosen uniformly over s-sparse random vectors
with {0, 1} entries, then k = r = s, m = s2 and
λ = 1 − 1s .
2. If x is uniformly chosen from Dirichlet distribution
1
s
, then r = k = 1 and m = sD
with parameter αi = D
1
with λ = 1 − s .
For these examples, the result in this paper shows that we
can recover A∗ for aforementioned random variables x as
long as s = O(D1/6 ). In general, there is a wide range
of parameters (r, k, m, λ) such that learning A∗ is doable
with polynomially many samples of y and in polynomial
time.
However, just the GCC condition is not enough for recovering A∗ . We will also need a mild initialization.
Definition 2 (`-initialization). The initial matrix A0 satisfies for some ` ∈ [0, 1),
1. A0 = A∗ (Σ + E), for some diagonal matrix Σ and
off-diagonal matrix E.
2. kEk2 ≤ `, kΣ − Ik2 ≤ 14 .
The condition means that the initialization is not too far
away from the ground-truth A∗ . P
For any i ∈ [D], the ith column [A0 ]i = Σi,i [A∗ ]i + j6=i Ej,i [A∗ ]j . So the
condition means that each feature [A0 ]i has a large fraction of the ground-truth feature [A∗ ]i and a small fraction
of the other features. Σ can be regarded as the magnitude
of the component from the ground-truth in the initialization, while E can be regarded as the magnitude of the error
terms. In particular, when Σ = I and E = 0, we have
A0 = A∗ . The initialization allows Σ to be a constant
away from I, and the error term E to be ` (in our theorems
` can be as large as a constant).
In practice, such an initialization is typically achieved by
setting the columns of A0 to reasonable “pure” data points
that contain one major feature and a small fraction of some
others (e.g. (lda, 2016; Awasthi & Risteski, 2015)).

Algorithm 1 Alternating Non-negative gradient Descent
(AND)
Input: Threshold values {α0 , α1 , . . . , αs }, T , A0
1: A(0) ← A0
2: for j = 0, 1, . . . , s do
3:
for t = 0, 1, . . . , T do
4:
On getting sample y (t) , do:

5:
z (t) ← φαj (A(0) )† y (t)

6:
A(t+1) ← A(t) + η y (t) − A(t) z (t) (z (t) )>
7:
end for
8:
A(0) ← A(T +1)
9: end for
Output: A ← A(T +1)

4. Algorithm
The algorithm is formally describe in Algorithm 1. It runs
in s stages, and in the j-th stage, uses the same threshold
αj and the same matrix A(0) for decoding, where A(0) is
either the input initialization matrix or the working matrix
obtained at the end of the last stage. Each stage consists
of T iterations, and each iteration decodes one data point
and uses the decoded result to update the working matrix.
It can use a batch of data points instead of one data point,
and our analysis still holds.
By running in stages, we save most of the cost of computing (A(0) )† , as our results show that only polylogarithmic
stages are needed. For the simple case where x ∈ {0, 1}D ,
the algorithm can use the same threshold value α = 1/4
for all stages (see Theorem 1), while for the general case,
it needs decreasing threshold values across the stages (see
Theorem 4). Our analysis provides the hint for setting the
threshold; see the discussion after Theorem 4, and Section 7 for how to set the threshold in practice.

5. Result for A Simplified Case
In this section, we consider the following simplified case:
y = A∗ x, x ∈ {0, 1}D .

(5.1)

That is, the weight coordinates xi ’s are binary.
Theorem 1 (Main, binary). For the generative model (5.1),
there exists ` = Ω(1) such that for every (r, k, m, λ)GCC x and every  > 0, Algorithm AND with T =
1
1 s
s
poly(D, 1 ), η = poly(D,
1 , {αi }i=1 = { 4 }i=1 for s =
)


polylog(D, 1 ) and an ` initialization matrix A0 , outputs a
matrix A such that there exists a diagonal matrix Σ  12 I
with kA − A∗ Σk2 ≤  using poly(D, 1 ) samples and iterations, as long as


kDλ4
m=O
.
r5

Provable Alternating Gradient Descent for Non-negative Matrix Factorization with Strong Correlations

Therefore, our algorithm recovers the ground-truth A∗ up
to scaling. The scaling in unavoidable since there is no assumption on A∗ , so we cannot, for example, distinguish
A∗ from 2A∗ . Indeed, if we in addition assume each column of A∗ has norm 1 as typical in applications, then
we can recover A∗ directly. In particular, by normalizing
each column of A to have norm 1, we can guarantee that
kA − A∗ k2 ≤ O().
In many interesting applications (for example, those in
Proposition 1), k, r, λ are constants. The theorem implies
that the algorithm can recover A∗ even when m = O(D).
In this case, Eµ [xi xj ] can be as large as O(1/D), the same
order as min{Eµ [xi ], Eµ [xj ]}, which is the highest possible correlation.
5.1. Intuition
The intuition comes from assuming that we have the “correct decoding”, that is, suppose magically for every y (t) ,
our decoding z (t) = φαj (A† y (t) ) = x(t) . Here and in this
subsection, A is a shorthand for A(0) . The gradient descent is then A(t+1) = A(t) + η(y (t) − A(t) x(t) )(x(t) )> .
Subtracting A∗ on both side, we will get
(A(t+1) − A∗ ) = (A(t) − A∗ )(I − ηx(t) (x(t) )> )
Since x(t) (x(t) )> is positive semidefinite, as long as
E[x(t) (x(t) )> ]  0 and η is sufficiently small, A(t) will
converge to A∗ eventually.
However, this simple argument does not work when A 6=
A∗ and thus we do not have the correct decoding. For example, if we just let the decoding be z̃ (t) = A† y (t) , we will
have y (t) − Az̃ (t) = y (t) − A† Ay (t) = (I − A† A)A∗ x(t) .
Thus, using this decoding, the algorithm can never make
any progress once A and A∗ are in the same subspace.
The most important piece of our proof is to show that after thresholding, z (t) = φα (A† y (t) ) is much closer to x(t)
than z̃ (t) . Since A and A∗ are in the same subspace, inspired by (Li et al., 2016) we can write A∗ as A(Σ + E)
for a diagonal matrix Σ and an off-diagonal matrix E, and
thus the decoding becomes z (t) = φα (Σx(t) + Ex(t) ).
(t)
Let us focus on one coordinate of z (t) , that is, zi =
(t)
φα (Σi,i xi + Ei x(t) ), where Ei is the i-th row of Ei . The
(t)
term Σi,i xi is a nice term since it is just a rescaling of
(t)
xi , while Ei x(t) mixes different coordinates of x(t) . For
(t)
simplicity, we just assume for now that xi ∈ {0, 1} and
Σi,i = 1. In our proof, we will show that the threshold will
(t)
remove a large fraction of Ei x(t) when xi = 0, and keep a
(t)
(t)
large fraction of Σi,i xi when xi = 1. Thus, our decoding is much more accurate than without thresholding. To
show this, we maintain a crucial property that for our decoding matrix, we always have kEi k2 = O(1). Assuming

this, we first consider two extreme cases of Ei .
1. Ultra dense: all coordinates of Ei are in the order of
√1 . Since the sparsity of x(t) is r, as long as r =
d
√
(t)
o( d)α, Ei x(t) will not pass α and thus zi will be
(t)
decoded to zero when xi = 0.
2. Ultra sparse: Ei only has few coordinate equal to Ω(1)
and the rest are zero. Unless x(t) has those exact coordinates equal to 1 (which happens not so often), then
(t)
(t)
zi will still be zero when xi = 0.
Of course, the real Ei can be anywhere in between these
two extremes, and thus we need more delicate decoding
lemmas, as shown in the complete proof.
(t)

Furthermore, more complication arises when each xi is
not just in {0, 1} but can take fractional values. To handle this case, we will set our threshold α to be large at the
beginning and then keep shrinking after each stage. The intuition here is that we first decode the coordinates that we
(t)
are most confident in, so we do not decode zi to be non(t)
zero when xi = 0. Thus, we will still be able to remove a
large fraction of error caused by Ei x(t) . However, by setting the threshold α so high, we may introduce more errors
(t)
(t)
to the nice term Σi,i xi as well, since Σi,i xi might not
(t)
be larger than α when xi 6= 0. Our main contribution is to
show that there is a nice trade-off between the errors in Ei
terms and those in Σi,i terms such that as we gradually decreases α, the algorithm can converge to the ground-truth.
5.2. Proof Sketch
For simplicity, we only focus on one stage and the expected
update. The expected update of A(t) is given by
A(t+1) = A(t) + η(E[yz > ] − A(t) E[zz > ]).
Let us write A(0) = A∗ (Σ0 + E0 ) where Σ0 is diagonal
and E0 is off-diagonal. Then the decoding is given by
z = φα ((A(0) )† y) = φα ((Σ0 + E0 )−1 x).
Let Σ, E be the diagonal part and the off-diagonal part of
(Σ0 + E0 )−1 .
The key lemma for decoding says that under suitable conditions, z will be close to Σx in the following sense.
Lemma 2 (Decoding, informal). Suppose E is small and
Σ ≈ I. Then with a proper threshold value α, we have
E[Σxx> ] ≈ E[zx> ], E[Σxz > ] ≈ E[zz > ].
Now, let us write A(t) = A∗ (Σt + Et ). Then applying the
above decoding lemma, the expected update of Σt + Et is
Σt+1 +Et+1 = (Σt +Et )(I−Σ∆Σ)+Σ−1 (Σ∆Σ)+Rt

Provable Alternating Gradient Descent for Non-negative Matrix Factorization with Strong Correlations

where ∆ = E[xx> ] and Rt is a small error term.
Our second key lemma is about this update.
Lemma 3 (Update, informal). Suppose the update rule is
Σt+1 + Et+1 = (Σt + Et )(1 − ηΛ) + ηQΛ + ηRt
for some PSD matrix Λ and kRt k2 ≤ C 00 . Then
kΣt + Et − Qk2 ≤ kΣ0 + E0 − Qk2 (1 − ηλmin (Λ))t
+

C 00
.
λmin (Λ)

Applying this on our update rule with Q = Σ−1 and
Λ = Σ∆Σ, we know that when the error term is sufficiently small, we can make progress on kΣt +Et −Σ−1 k2 .
Furthermore, by using the fact that Σ0 ≈ I and E0 is small,
and the fact that Σ is the diagonal part of (Σ0 + E0 )−1 , we
can show that after sufficiently many iterations, kΣt − Ik2
blows up slightly, while kEt k2 is reduced significantly. Repeating this for multiple stages completes the proof.
We note that most technical details are hidden, especially
for the proofs of the decoding lemma, which need to show
that the error term Rt is small. This crucially relies on
the choice of α, and relies on bounding the effect of the
correlation. These then give the setting of α and the bound
on the parameter m in the final theorem.

6. More General Results
6.1. Result for General x
This subsection considers the general case where x ∈
[0, 1]D . Then the GCC condition is not enough for recovery, even for k, r, m = O(1) and λ = Ω(1). For example,
GCC does not rule out the case that x is drawn uniformly
1
over (r − 1)-sparse random vectors with { D
, 1} entries,
when one cannot recover even a reasonable
approximation
P ∗i
1
of A∗ since a common vector D
i [A ] shows up in all
the samples. This example shows that the difficulty arises
if each xi constantly shows up with a small value. To avoid
this, a general and natural way is to assume that each xi ,
once being non-zero, has to take a large value with sufficient probability. This is formalized as follows.
Definition 3 (Decay condition). A distribution of x satisfies
the order-q decay condition for some constant q ≥ 1, if for
all i ∈ [D], xi satisfies that for every α > 0,
Pr[xi ≤ α | xi 6= 0] ≤ αq .
When q = 1, each xi , once being non-zero, is uniformly
distributed in the interval [0, 1]. When q gets larger, each
xi , once being non-zero, will be more likely to take larger

values. We will show that our algorithm has a better guarantee for larger q. In the extreme case when q = ∞, xi will
only take {0, 1} values, which reduces to the binary case.
In this paper, we show that this simple decay condition,
combined with the GCC conditions and an initialization
with constant error, is sufficient for recovering A∗ .
Theorem 4 (Main). There exists ` = Ω(1) such that for
every (r, k, m, λ)-GCC x satisfying the order-q condition,
every  > 0, there exists T, η and a sequence of {αi } 4
such that Algorithm AND, with `-initialization matrix A0 ,
outputs a matrix A such that there exists a diagonal matrix
Σ  21 I with kA − A∗ Σk2 ≤  with poly(D, 1 ) samples
and iterations, as long as
!
1
4
kD1− q λ4+ q
m=O
.
6
r5+ q+1
As mentioned, in many interesting applications, k = r =
λ = Θ(1), where our algorithm can recover A∗ as long as
1
1
m = O(D1− q+1 ). This means Eµ [xi xj ] = O(D−1− q+1 ),
1
a factor of D− q+1 away from the highest possible correlation min{Eµ [xi ], Eµ [xj ]} = O(1/D). Then, the larger q,
the higher correlation it can tolerate. As q goes to infinity,
we recover the result for the case x ∈ {0, 1}D , allowing
the highest order correlation.
The analysis also shows that the decoding threshold should
2

 q+1
be α = λkEr0 k2
where E0 is the error matrix at the
beginning of the stage. Since the error decreases exponentially with stages, this suggests to decrease α exponentially
with stages. This is crucial for AND to recover the groundtruth; see Section 7 for the experimental results.
6.2. Robustness to Noise
We now consider the case when the data is generated from
y = A∗ x + ζ, where ζ is the noise. For the sake of demonstration, we will just focus on the case when xi ∈ {0, 1}
1
I . 5 A
and ζ is random Gaussian noise ζ ∼ γN 0, W
more general theorem can be found in the appendix.
Definition 4 ((`, ρ)-initialization). The initial matrix A0
satisfies for some `, ρ ∈ [0, 1),
1. A0 = A∗ (Σ + E) + N, for some diagonal matrix Σ
and off-diagonal matrix E.
2. kEk2 ≤ `, kΣ − Ik2 ≤ 41 , kNk2 ≤ ρ.
Theorem 5 (Noise, binary). Suppose each xi ∈ {0, 1}.
There exists ` = Ω(1) such that for every (r, k, m, λ)-GCC
x, every  > 0, Algorithm AND with T = poly(D, 1 ), η =
4
5

In fact, we will make the choice explicit in the proof.
we make this scaling so kζk2 ≈ γ.

Provable Alternating Gradient Descent for Non-negative Matrix Factorization with Strong Correlations

{αi }si=1 = { 41 }4i=1 and an (`, ρ)-initialization
A0 for ρ = O(σmin (A∗ )), outputs A such that there exists
a diagonal matrix Σ  12 I with


σmax (A∗ )
kA − A∗ Σk2 ≤ O  + r
γ
σmin (A∗ )λ


4
.
using poly(D, 1 ) iterations, as long as m = O kDλ
5
r
1
,
poly(D, 1 )

The theorem implies that the algorithm can recover the
∗
max (A )
ground-truth up to r σσmin
(A∗ )λ times γ, the noise level in
each sample. Although stated here for Gaussian noise for
simplicity, the analysis applies to a much larger class of
noises, including adversarial ones. In particular, we only
need to the noise ζ have sufficiently bounded kE[ζζ > ]k2 ;
see the appendix for the details. For the special case of
Gaussian noise, by exploiting its properties, it is possible
to improve the error term with a more careful calculation,
though not done here.

7. Experiments
To demonstrate the advantage of AND, we complement the
theoretical analysis with empirical study on semi-synthetic
datasets, where we have ground-truth feature matrices and
can thus verify the convergence. We then provide support
for the benefit of using decreasing thresholds, and test its
robustness to noise. In the appendix, we further test its
robust to initialization and sparsity of x, and provide qualitative results in some real world applications. 6
Setup. Our work focuses on convergence of the solution to the ground-truth feature matrix. However, realworld datasets in general do not have ground-truth. So we
construct semi-synthetic datasets in topic modeling: first
take the word-topic matrix learned by some topic modeling method as the ground-truth A∗ , and then draw x from
some specific distribution µ. For fair comparison, we use
one not learned by any algorithm evaluated here. In particular, we used the matrix with 100 topics computed by the
algorithm in (Arora et al., 2013) on the NIPS papers dataset
(about 1500 documents, average length about 1000). Based
on this we build two semi-synthetic datasets:
1. DIR. Construct a 100 × 5000 matrix X, whose
columns are from a Dirichlet distribution with parameters (0.05, 0.05, . . . , 0.05). Then the dataset is
Y = A∗ X.
2. CTM. The matrix X is of the same size as above,
while each column is drawn from the logistic normal
prior in the correlated topic model (Blei & Lafferty,
2006). This leads to a dataset with strong correlations.
6
The code is public on
PrincetonML/AND4NMF.

https://github.com/

Note that the word-topic matrix is non-negative. While
some competitor algorithms require a non-negative feature
matrix, AND does not need such a condition. To demonstrate this, we generate the following synthetic data:
3. NEG. The entries of the matrix A∗ are i.i.d. samples
from the uniform distribution on [−0.5, 0.5). The matrix X is the same as in CTM.
Finally, the following dataset is for testing the robustness
of AND to the noise:
4. NOISE. A∗ and X are the same as in CTM, but Y =
A∗ X + N where N is the
 noise matrix with columns
1
I with the noise level γ.
drawn from γN 0, W
Competitors. We compare the algorithm AND to the following popular methods: Alternating Non-negative Least
Square (ANLS (Kim & Park, 2008)), multiplicative update
(MU (Lee & Seung, 2001)), LDA (online version (Hoffman
et al., 2010)),7 and Hierarchical Alternating Least Square
(HALS (Cichocki et al., 2007)).
Evaluation criterion. Given the output matrix A and the
ground truth matrix A∗ , the correlation error of the i-th
column is given by
εi (A, A∗ ) =

min
j∈[D],σ∈R

{k[A∗ ]i − σ[A]j k2 }.

Thus, the error measures how well the i-th column of A∗
is covered by the best column of A up to scaling. We find
the best column since in some competitor algorithms, the
columns of the solution A may only correspond to a permutation of the columns of A∗ .8
We also define the total correlation error as
ε(A, A∗ ) =

D
X

εi (A, A∗ ).

i=1

We report the total correlation error in all the experiments.
Initialization. In all the experiments, the initialization
matrix A0 is set to A0 = A∗ (I + U) where I is the
identity matrix and U is a matrix whose entries are i.i.d.
samples from the uniform distribution on [−0.05, 0.05).
Note that this is a very
since [A0 ]i =
P weak initialization,
∗ i
∗ j
(1 + Ui,i )[A ] + j6=i Uj,i [A ] and the magnitude of
P
the noise component j6=i Uj,i [A∗ ]j can be larger than
the signal part (1 + Ui,i )[A∗ ]i .
7
We use the implementation in the sklearn package (http:
//scikit-learn.org/)
8
In the Algorithm AND, the columns of A correspond to the
columns of A∗ without permutation.

Provable Alternating Gradient Descent for Non-negative Matrix Factorization with Strong Correlations

10

10

0

0

−10

−10

10

0

−20

−20

−20

AND
ANLS
MU
LDA
HALS

−30

−40

log(Error)

log(Error)

log(Error)

−10

0

500

1000

1500
2000
2500
Time in seconds

3000

3500

−40

4000

−30

AND
ANLS
MU
LDA
HALS

−30

0

500

(a) on DIR dataset

AND
ANLS
MU
LDA
HALS

−40

1000

1500
2000
2500
Time in seconds

3000

3500

−50

4000

0

(b) on CTM dataset

200

400

600
800
1000
Time in seconds

1200

1400

(c) on NEG dataset

Figure 1. The performance of different algorithms on the three datasets. The x-axis is the running time (in seconds), the y-axis is the
logarithm of the total correlation error.

10

10

0

0

−10

−10

noise
noise
noise
noise
noise
noise

4

2

−20

log(Error)

log(Error)

log(Error)

0

−20

level
level
level
level
level
level

0.1
0.05
0.01
0.005
0.001
0.0005

−2

−4

−6
−30

−40

−30

Decreasing threshold
Constant threshold 0.0001
Constant threshold 0.1
0

500

1000

1500
2000
2500
Time in seconds

3000

3500

4000

(a) different thresholds on DIR

−40

Decreasing threshold
Constant threshold 0.0001
Constant threshold 0.1
0

500

1000

−8

1500
2000
2500
Time in seconds

3000

3500

4000

−10

0

(b) different thresholds on CTM

50

100
Time in seconds

150

200

(c) robustness to noise

Figure 2. The performance of the algorithm AND with different thresholding schemes, and its robustness to noise. The x-axis is the
running time (in seconds), the y-axis is the logarithm of the total correlation error. (a)(b) Using different thresholding schemes on the
DIR/CTM dataset. “Decreasing thresold” refers to the scheme used in the original AND, “Constant threshold c” refers to using the
threshold value c throughout all iterations. (c) The performance in the presence of noises of various levels.

Hyperparameters and Implementations. For most experiments of AND, we used T = 50 iterations for each
stage, and thresholds αi = 0.1/(1.1)i−1 . For experiments
on the robustness to noise, we found T = 100 leads to
better performance. Furthermore, for all the experiments,
instead of using one data point at each step, we used the
whole dataset for update.
7.1. Convergence to the Ground-Truth
Figure 1 shows the convergence rate of the algorithms on
the three datasets. AND converges in linear rate on all three
datasets (note that the y-axis is in log-scale). HALS converges on the DIR and CTM datasets, but the convergence
is in slower rates. Also, on CTM, the error oscillates. Furthermore, it doesn’t converge on NEG where the groundtruth matrix has negative entries. ANLS converges on DIR
and CTM at a very slow speed due to the non-negative least
square computation in each iteration. 9 All the other algo9

We also note that even the thresholding of HALS and ALNS
designed for non-negative feature matrices is removed, they still

rithms do not converge to the ground-truth, suggesting that
they do not have recovery guarantees.
7.2. The Threshold Schemes
Figure 2(a) shows the results of using different thresholding
schemes on DIR, while Figure 2(b) shows that those on
CTM. When using a constant threshold for all iterations,
the error only decreases for the first few steps and then stop
decreasing. This aligns with our analysis and is in strong
contrast to the case with decreasing thresholds.
7.3. Robustness to Noise
Figure 2(c) shows the performance of AND on the NOISE
dataset with various noise levels γ. The error drops at the
first few steps, but then stabilizes around a constant related
to the noise level, as predicted by our analysis. This shows
that it can recover the ground-truth to good accuracy, even
when the data have a significant amount of noise.
do not converge on NEG.

Provable Alternating Gradient Descent for Non-negative Matrix Factorization with Strong Correlations

Acknowledgements
This work was supported in part by NSF grants CCF1527371, DMS-1317308, Simons Investigator Award, Simons Collaboration Grant, and ONR-N00014-16-1-2329.
This work was done when Yingyu Liang was visiting the
Simons Institute.

References
Lda-c software. https://github.com/blei-lab/
lda-c/blob/master/readme.txt, 2016. Accessed: 2016-05-19.
Anandkumar, A., Kakade, S., Foster, D., Liu, Y., and Hsu,
D. Two svds suffice: Spectral decompositions for probabilistic topic modeling and latent dirichlet allocation.
Technical report, 2012.
Anandkumar, A., Hsu, D., Javanmard, A., and Kakade, S.
Learning latent bayesian networks and topic models under expansion constraints. In ICML, 2013.

Blei, David M, Ng, Andrew Y, and Jordan, Michael I. Latent dirichlet allocation. JMLR, 3:993–1022, 2003.
Cichocki, Andrzej, Zdunek, Rafal, and Amari, Shun-ichi.
Hierarchical als algorithms for nonnegative matrix and
3d tensor factorization. In International Conference on
Independent Component Analysis and Signal Separation, pp. 169–176. Springer, 2007.
Ding, W., Rohban, M.H., Ishwar, P., and Saligrama, V.
Topic discovery through data dependent and random
projections. arXiv preprint arXiv:1303.3664, 2013.
Ding, W., Rohban, M.H., Ishwar, P., and Saligrama, V. Efficient distributed topic modeling with provable guarantees. In AISTAT, pp. 167–175, 2014.
Hoffman, Matthew, Bach, Francis R, and Blei, David M.
Online learning for latent dirichlet allocation. In advances in neural information processing systems, pp.
856–864, 2010.

Arora, S., Ge, R., and Moitra, A. Learning topic models –
going beyond svd. In FOCS, 2012a.

Kim, Hyunsoo and Park, Haesun. Nonnegative matrix factorization based on alternating nonnegativity constrained
least squares and active set method. SIAM journal on
matrix analysis and applications, 30(2):713–730, 2008.

Arora, S., Ge, R., Halpern, Y., Mimno, D., Moitra, A.,
Sontag, D., Wu, Y., and Zhu, M. A practical algorithm
for topic modeling with provable guarantees. In ICML,
2013.

Lee, Daniel D and Seung, H Sebastian. Unsupervised
learning by convex and conic coding. NIPS, pp. 515–
521, 1997.

Arora, S., Ge, R., Ma, T., and Moitra, A. Simple, efficient,
and neural algorithms for sparse coding. In COLT, 2015.

Lee, Daniel D and Seung, H Sebastian. Learning the parts
of objects by non-negative matrix factorization. Nature,
401(6755):788–791, 1999.

Arora, Sanjeev, Ge, Rong, Kannan, Ravindran, and Moitra,
Ankur. Computing a nonnegative matrix factorization–
provably. In STOC, pp. 145–162. ACM, 2012b.
Arora, Sanjeev, Ge, Rong, Koehler, Frederic, Ma, Tengyu,
and Moitra, Ankur. Provable algorithms for inference in
topic models. In Proceedings of The 33rd International
Conference on Machine Learning, pp. 2859–2867, 2016.
Awasthi, Pranjal and Risteski, Andrej. On some provably
correct cases of variational inference for topic models.
In NIPS, pp. 2089–2097, 2015.
Bhattacharyya, Chiranjib, Goyal, Navin, Kannan, Ravindran, and Pani, Jagdeep. Non-negative matrix factorization under heavy noise. In Proceedings of the 33nd
International Conference on Machine Learning, 2016.
Blei, David and Lafferty, John. Correlated topic models.
Advances in neural information processing systems, 18:
147, 2006.
Blei, David M. Probabilistic topic models. Communications of the ACM, 2012.

Lee, Daniel D and Seung, H Sebastian. Algorithms for
non-negative matrix factorization. In NIPS, pp. 556–562,
2001.
Li, Yuanzhi, Liang, Yingyu, and Risteski, Andrej. Recovery guarantee of non-negative matrix factorization via alternating updates. Advances in neural information processing systems, 2016.
Yang, Jaewon and Leskovec, Jure. Overlapping community
detection at scale: a nonnegative matrix factorization approach. In Proceedings of the sixth ACM international
conference on Web search and data mining, pp. 587–596.
ACM, 2013.

