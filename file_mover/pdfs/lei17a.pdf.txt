Deriving Neural Architectures from Sequence and Graph Kernels
Tao Lei* 1 Wengong Jin* 1 Regina Barzilay 1 Tommi Jaakkola 1

Abstract
The design of neural architectures for structured
objects is typically guided by experimental insights rather than a formal process. In this work,
we appeal to kernels over combinatorial structures, such as sequences and graphs, to derive
appropriate neural operations. We introduce a
class of deep recurrent neural operations and formally characterize their associated kernel spaces.
Our recurrent modules compare the input to virtual reference objects (cf. filters in CNN) via the
kernels. Similar to traditional neural operations,
these reference objects are parameterized and directly optimized in end-to-end training. We empirically evaluate the proposed class of neural architectures on standard applications such as language modeling and molecular graph regression,
achieving state-of-the-art results across these applications.

1. Introduction
Many recent studies focus on designing novel neural architectures for structured data such as sequences or annotated graphs. For instance, LSTM (Hochreiter & Schmidhuber, 1997), GRU (Chung et al., 2014) and other complex
recurrent units (Zoph & Le, 2016) can be easily adapted
to embed structured objects such as sentences (Tai et al.,
2015) or molecules (Li et al., 2015; Dai et al., 2016) into
vector spaces suitable for later processing by standard predictive methods. The embedding algorithms are typically
integrated into an end-to-end trainable architecture so as to
tailor the learnable embeddings directly to the task at hand.
The embedding process itself is characterized by a sequence operations summarized in a structure known as
the computational graph. Each node in the computational
*
1
Equal contribution
MIT Computer Science & Artificial Intelligence Laboratory.
Correspondence to:
Tao Lei <taolei@csail.mit.edu>, Wengong Jin <wengong@csail.mit.edu>.

Proceedings of the 34 th International Conference on Machine
Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017
by the author(s).

graph identifies the unit/mapping applied while the arcs
specify the relative arrangement/order of operations. The
process of designing such computational graphs or associated operations for classes of objects is often guided by
insights and expertise rather than a formal process.
Recent work has substantially narrowed the gap between
desirable computational operations associated with objects
and how their representations are acquired. For example,
value iteration calculations can be folded into convolutional
architectures so as to optimize the representations to facilitate planning (Tamar et al., 2016). Similarly, inference
calculations in graphical models about latent states of variables such as atom characteristics can be directly associated
with embedding operations (Dai et al., 2016).
We appeal to kernels over combinatorial structures to define the appropriate computational operations. Kernels give
rise to well-defined function spaces and possess rules of
composition that guide how they can be built from simpler
ones. The comparison of objects inherent in kernels is often broken down to elementary relations such as counting
of common sub-structures as in
X
K( , 0 ) =
1[s 2 ]1[s 2 0 ]
(1)
s2S

where S is the set of possible substructures. For example, in a string kernel (Lodhi et al., 2002), S may refer
to all possible subsequences while a graph kernel (Vishwanathan et al., 2010) would deal with possible paths
in the graph. Several studies have highlighted the relation between feed-forward neural architectures and kernels (Hazan & Jaakkola, 2015; Zhang et al., 2016) but we
are unaware of any prior work pertaining to kernels associated with neural architectures for structured objects.
In this paper, we introduce a class of deep recurrent neural
embedding operations and formally characterize their associated kernel spaces. The resulting kernels are parameterized in the sense that the neural operations relate objects of
interest to virtual reference objects through kernels. These
reference objects are parameterized and readily optimized
for end-to-end performance.
To summarize, the proposed neural architectures, or Kernel
Neural Networks 1 , enjoy the following advantages:
1

Code available at https://github.com/taolei87/icml17 knn

Deriving Neural Architectures from Sequence and Graph Kernels

• The architecture design is grounded in kernel computations.
• Our neural models remain end-to-end trainable to the
task at hand.
• Resulting architectures demonstrate state-of-the-art
performance against strong baselines.
In the following sections, we will introduce these neural
components derived from string and graph kernels, as well
as their deep versions. Due to space limitations, we defer
proofs to supplementary material.2

2. From String Kernels to Sequence NNs
Notations We define a sequence (or a string) of tokens
d
(e.g. a sentence) as x1:L = {xi }L
i=1 where xi 2 R repreth
sents its i element and |x| = L denotes the length. Whenever it is clear from the context, we will omit the subscript
and directly use x (and y) to denote a sequence. For
P a pair
of vectors (or matrices) u, v, we denote hu, vi = k uk vk
as their inner product. For a kernel function Ki (·, ·) with
subscript i, we use i (·) to denote its underlying mapping,
i.e. Ki (x, y) = h i (x), i (y)i = i (x)> i (y).

String Kernel String kernel measures the similarity between two sequences by counting shared subsequences
(see Lodhi et al. (2002)). For example, let x and y be two
strings, a bi-gram string kernel K2 (x, y) counts the number of bi-grams (xi , xj ) and (yk , yl ) such that (xi , xj ) =
(yk , yl )3 ,
X
K2 (x, y) =
x,i,j y,k,l (xi , yk ) · (xj , yl )
1i<j|x|
1k<l|y|

(2)
where x,i,j , y,k,l 2 [0, 1) are context-dependent weights
and (x, y) is an indicator that returns 1 only when x = y.
The weight factors can be realized in various ways. For
instance, in temporal predictions such as language modeling, substrings (i.e. patterns) which appear later may have
higher impact for prediction. Thus a realization x,i,j =
|x| i 1
and y,k,l = |y| k 1 (penalizing substrings far
from the end) can be used to determine weights given a
constant decay factor 2 (0, 1).
In our case, each token in the sequence is a vector (such as
one-hot encoding of a word or a feature vector). We shall
replace the exact match (u, v) by the inner product hu, vi.
To this end, the kernel function (2) can be rewritten as,
X
X
x,i,j y,k,l hxi , yk i · hxj , yl i
1i<j|x| 1k<l|y|

2
An extended version with supplementary material is available
at https://arxiv.org/abs/1705.09037
3
We define n-gram as a subsequence of original string (not
necessarily consecutive).

Figure 1. An unrolled view of the derived recurrent module for
K2 (). Horizontal lines denote decayed propagation from c[t 1]
to c[t], while vertical lines represent a linear mapping Wxt that
is propagated to the internal states c[t].

=

X

X

x,i,j

y,k,l

1i<j|x| 1k<l|y|

=

*

X

|x| i 1

i<j

xi ⌦ xj ,

X
k<l

hxi ⌦ xj , yk ⌦ yl i

|y| k 1

yk ⌦ yl

+
(3)

where xi ⌦ xj 2 Rd⇥d (and similarly yk ⌦ yl ) is the outerproduct. In other words, the underlying
mapping of kernel
P
K2 () defined above is 2 (x) = 1i<j|x| |x| i 1 xi ⌦
xj . Note we could alternatively use a partial additive scoring hxi , yk i + hxj , yl i, and the kernel function can be generalized to n-grams when n 6= 2. Again, we commit to one
realization in this section.
String Kernel NNs We introduce a class of recurrent modules whose internal feature states embed the computation of
string kernels. The modules project kernel mapping (x)
into multi-dimensional vector space (i.e. internal states of
recurrent nets). Owing to the combinatorial structure of
(x), such projection can be realized and factorized via
efficient computation. For the example kernel discussed
above, the corresponding neural component is realized as,
⇣
⌘
c1 [t] = · c1 [t 1] + W(1) xt
⇣
⌘
cj [t] = · cj [t 1] + cj 1 [t 1] W(j) xt
1<jn

h[t] = (cn [t]),

(4)

where cj [t] are the pre-activation cell states at word xt , and
h[t] is the (post-activation) hidden vector. cj [0] is initialized with a zero vector. W(1) , .., W(n) are weight matrices
to be learned from training examples.
The network operates like other RNNs by processing each
input token and updating the internal states. The elementwise multiplication can be replaced by addition + (corresponding to the partial additive scoring above). As a special case, the additive variant becomes a word-level convolutional neural net (Kim, 2014) when = 0.4
4

h[t] = (W(1) xt

n+1

+ · · · + W(n) xt ) when

= 0.

Deriving Neural Architectures from Sequence and Graph Kernels

2.1. Single Layer as Kernel Computation
Now we state how the proposed class embeds string kernel
computation. For j 2 {1, .., n}, let cj [t][i] be the i-th entry
(j)
of state vector cj [t], wi represents the i-th row of ma(1)
(2)
(j)
trix W(j) . Define wi,j = {wi , wi , ..., wi } as a “reference sequence” constructed by taking the i-th row from
each matrix W(1) , .., W(j) .
Theorem 1. Let x1:t be the prefix of x consisting of first
t tokens, and Kj be the string kernel of j-gram shown in
Eq.(3). Then cj [t][i] evaluates kernel function,
cj [t][i] = Kj (x1:t , wi,j ) = h

j (x1:t ),

j (wi,j )i

for any j 2 {1, .., n}, t 2 {1, .., |x|}.
In other words, the network embeds sequence similarity
computation by assessing the similarity between the input
sequence x1:t and the reference sequence wi,j . This interpretation is similar to that of CNNs, where each filter
is a “reference pattern” to search in the input. String kernel NN further takes non-consecutive n-gram patterns into
consideration (seen from the summation over all n-grams
in Eq.(3)).
Applying Non-linear Activation In practice, a non-linear
activation function such as polynomial or sigmoid-like activation is added to the internal states to produce the final output state h[t]. It turns out that many activations
are also functions in the reproducing kernel Hilbert space
(RKHS) of certain kernel functions (see Shalev-Shwartz
et al. (2011); Zhang et al. (2016)). When this is true, the
underlying kernel of h[t] is the composition of string kernel and the kernel containing the activation. We give the
formal statements below.
Lemma 1. Let x and w be multi-dimensional vectors with
finite norm. Consider the function f (x) := (w> x) with
non-linear activation (·). For functions such as polynomials and sigmoid function, there exists kernel functions
K (·, ·) and the underlying mapping (·) such that f (x)
is in the reproducing kernel Hilbert space of K (·, ·), i.e.,
f (x) = (w> x) = h

(x), (w)i

for some mapping (w) constructed from w. In particular,
1
K (x, y) can be the inverse-polynomial kernel 2 hx,yi
for
the above activations.
Proposition 1. For one layer string kernel NN with nonlinear activation (·) discussed in Lemma 1, h[t][i] as a
function of input x belongs to the RKHS introduced by the
composition of K (·, ·) and string kernel Kn (·, ·). Here a
kernel composition K ,n (x, y) is defined with the underlying mapping x 7!
( n (x)), and hence K ,n (x, y) =
( n (x))> ( n (y)).

Proposition 1 is the corollary of Lemma 1 and Theorem 1, since h[t][i] = (cn [t][i]) = (Kn (x1:t , wi,j )) =
h ( n (x1:t )), w̃i,j i and ( n (·)) is the mapping for the
composed kernel. The same proof applies when h[t] is a
linear combination of all ci [t] since kernel functions are
closed under addition.
2.2. Deep Networks as Deep Kernel Construction
We now address the case when multiple layers of the same
module are stacked to construct deeper networks. That is,
the output states h(l) [t] of the l-th layer are fed to the (l+1)th layer as the input sequence. We show that layer stacking
corresponds to recursive kernel construction (i.e. (l + 1)th kernel is defined on top of l-th kernel), which has been
proven for feed-forward networks (Zhang et al., 2016).
We first generalize the sequence kernel definition to enable
recursive construction. Notice that the definition in Eq.(3)
uses the linear kernel (inner product) hxi , yk i as a “subroutine” to measure the similarity between substructures (e.g.
tokens) within the sequences. We can therefore replace it
with other similarity measures introduced by other “base
kernels”. In particular, let K(1) (·, ·) be the string kernel
(associated with a single layer). The generalized sequence
kernel K(l+1) (x, y) can be recursively defined as,
X
(l)
(l)
x,i,j y,k,l K (x1:i , y1:k ) K (x1:j , y1:l ) =
i<j
k<l

*

X

(l)

i<j

(x1:i ) ⌦

(l)

(x1:j ),

X
k<l

(l)

(l)

(y1:k ) ⌦

(y1:l )

+

where (l) (·) denotes the pre-activation mapping of the l(l)
th kernel,
(·) =
( (l) (·)) denotes the underlying
(post-activation) mapping for non-linear activation (·),
(l)
and K (·, ·) is the l-th post-activation kernel. Based on
this definition, a deeper model can also be interpreted as a
kernel computation.
Theorem 2. Consider a deep string kernel NN with L
layers and activation function (·). Let the final output
(L)
state h(L) [t] = (cn [t]) (or any linear combination of
(l)
{ci [t]}, i = 1, .., n). For l = 1, · · · , L,
(l)

(i) cn [t][i] as a function of input x belongs to the RKHS
of kernel K(l) (·, ·);
(l)

(ii) h(l) [t][i] belongs to the RKHS of kernel K (·, ·).

3. From Graph Kernels to Graph NNs
In the previous section, we encode sequence kernel computation into neural modules and demonstrate possible extensions using different base kernels. The same ideas apply

Deriving Neural Architectures from Sequence and Graph Kernels

to other types of kernels and data. Specifically, we derive
neural components for graphs in this section.

3.2. Unified View of Graph Kernels

Notations A graph is defined as G = (V, E), with each
vertex v 2 V associated with feature vector fv . The neighbor of node v is denoted as N (v). Following previous
notations, for any kernel function K⇤ (·, ·) with underlying mapping ⇤ (·), we use K⇤, (·, ·) to denote the postactivation kernel induced from the composed underlying
mapping ⇤, = ( ⇤ (·)).

The derivation of the above neural module could be extended to other classes of graph kernels, such as subtree
kernels (cf. (Ramon & Gärtner, 2003; Vishwanathan et al.,
2010)). Generally speaking, most of these kernel functions
factorize graphs into local sub-structures, i.e.
XX
K(G, G0 ) =
Kloc (v, v 0 )
(7)

3.1. Random Walk Kernel NNs

where Kloc (v, v 0 ) measures the similarity between local
sub-structures centered at node v and v 0 .

We start from random walk graph kernels (Gärtner et al.,
2003), which count common walks in two graphs. Formally, let Pn (G) be the set of walks x = x1 · · · xn , where
8i : (xi , xi+1 ) 2 E.5 Given two graphs G and G0 , an n-th
order random walk graph kernel is defined as:
n
KW
(G, G0 )

X

n 1

=

X

n
Y

x2Pn (G) y2Pn (G0 ) i=1

hfxi , fyi i (5)

Now we show how to realize the above graph kernel with
a neural module. Given a graph G, the proposed neural
module is:
=

cj [v]

=

W(1) fv
X

=

(

X
v

cj

1 [u]

W(j) fv

(6)

cn [v])

1<jn

where again c⇤ [v] is the cell state vector of node v, and hG
is the representation of graph G aggregated from node vectors. hG could then be used for classification or regression.
Now we show the proposed model embeds the random
walk kernel. To show this, construct Ln,k as a “refer(1)
(n)
ence walk” consisting of the row vectors {wk , · · · , wk }
from the parameter matrices. Here Ln,k = (LV , LE ),
where LV = {v0 , v1 , · · · , vn }, LE = {(vi , vi+1 )} and vi ’s
(i)
feature vector is wk . We have the following theorem:
Theorem 3. For any n
1, the state value cn [v][k] (the
k-th coordinate of cn [v]) satisfies:
X
v

Other kernels like subtree kernels could be recursively defined similarly. Therefore, we adopt this unified view of
graph kernels for the rest of this paper.
In addition, this definition of random walk kernel could be
further generalized and enhanced by aggregating neighbor
features non-linearly:
X
X
n 1
n
Kloc
(v, v 0 ) = hfv , fv0 i
Kloc,
(u, u0 )
where could be either multiplication or addition. (·)
n 1
denotes a non-linear activation and Kloc,
(·, ·) denotes the
post-activation kernel when (·) is involved. The generalized kernel could be realized by modifying Eq.(6) into:
X
cj [v] = W(j) fv
(cj 1 [u])
(8)
u2N (v)

where could be either + or

n
cn [v][k] = KW
(G, Ln,k )

A single node could appear multiple times in a walk.

operation.

3.3. Deep Graph Kernels and NNs
Following Section 2, we could stack multiple graph kernel
NNs to form a deep network. That is:
(l)

1)

[v]

(l)

1)

[v]

c1 [v] = W(l,1) h(l
cj [v] = W(l,j) h(l

X

u2N (v)
(l)

P
n
thus v cn [v] lies in the RKHS of kernel KW
. As a coroln
lary, hG lies in the RKHS of kernel KW, ().
5

n
For example, the random walk kernel KW
can be equivan
0
lently defined with Kloc (v, v ) =
8
if n = 1
< hfv , fv0 i
P
P
n 1
0
Kloc (u, u ) if n > 1
: hfv , fv0 i ·

u2N (v) u0 2N (v 0 )

u2N (v)

hG

v0

u2N (v) u0 2N (v 0 )

where fxi 2 Rd is the feature vector of node xi in the walk.

c1 [v]

v

h [v] =

(U(l) c(l)
n [v])

⇣

(l)

cj

1 [u]

⌘

1  l  L, 1 < j  n

The local kernel function is recursively defined in
two dimensions: depth (term h(l) ) and width (term
cj ). Let the pre-activation kernel in the l-th layer be
(l)
(l,n)
Kloc (v, v 0 ) = Kloc (v, v 0 ), and the post-activation ker(l)
(l,n)
nel be Kloc, (v, v 0 ) = Kloc, (v, v 0 ). We recursively define

Deriving Neural Architectures from Sequence and Graph Kernels
(l,j)

Kloc (v, v 0 ) =
8 (l 1)
< Kloc, (v, v 0 )
:

(l 1)
Kloc, (v, v 0 )

P

P

u2N (v) u0 2N (v 0 )

if j = 1
(l,j 1)
Kloc, (u, u0 )

if j > 1

for j = 1, · · · , n.
Finally, the graph kernel is
P
(L,n)
0
K(L,n) (G, G0 ) =
K
0
v,v
loc (v, v ). Similar to Theorem 2, we have
Theorem 4. Consider a deep graph kernel NN with L layers andPactivation function (·). Let the final output state
hG = v h(L) [v]. For l = 1, · · · , L; j = 1, · · · , n:
(l)

(i) cj [v][i] as a function of input v and graph G belongs
(l,j)

to the RKHS of kernel Kloc (·, ·);

(ii) h [v][i] belongs to the RKHS of kernel
(l)

(l,n)
Kloc, (·, ·).

(iii) hG [i] belongs to the RKHS of kernel K(L,n) (·, ·).
3.4. Connection to Weisfeiler-Lehman Kernel

We derived the above deep kernel NN for the purpose of
generality. This model could be simplified by setting n =
2, without losing representational power (as non-linearity
is already involved in depth dimension). In this case, we
rewrite the network by reparametrization:
0
1
⇣
⌘
X
(l)
(l 1)
1) A
@U(l)
h(l)
U2
V(l) h(l
v =
u
1 hv
u2N (v)

(9)
In this section, we further show that this model could be enhanced by sharing weight matrices U and V across layers.
This parameter tying mechanism allows our model to embed Weisfeiler-Lehman kernel (Shervashidze et al., 2011).
For clarity, we briefly review basic concepts of WeisfeilerLehman kernel below.
Weisfeiler-Lehman Graph Relabeling
WeisfeilerLehman kernel borrows concepts from the WeisfeilerLehman isomorphism test for labeled graphs. The key idea
of the algorithm is to augment the node labels by the sorted
set of node labels of neighbor nodes, and compress these
augmented labels into new, short labels (Figure 2). Such
relabeling process is repeated T times. In the i-th iteration,
it generates a new labeling li (v) for all nodes v in graph G,
with initial labeling l0 .

Generalized Graph Relabeling The key observation here
is that graph relabeling operation could be viewed as neighbor feature aggregation. As a result, the relabeling process
naturally generalizes to the case where nodes are associated
with continuous feature vectors. In particular, let r be the
relabeling function. For a node v 2 G:
X
r(v) = (U1 fv + U2
(Vfu ))
(10)
u2N (v)

Figure 2. Node relabeling in Weisfeiler-Lehman isomorphism test

Note that our definition of r(v) is exactly the same as hv in
Equation 9, with being additive composition.
Weisfeiler-Lehman Kernel Let K be any graph kernel (called base kernel). Given a relabeling function r,
Weisfeiler-Lehman kernel with base kernel K and depth L
is defined as
(L)

KW L (G, G0 ) =

L
X
i=0

K(ri (G), ri (G0 ))

(11)

where r0 (G) = G and ri (G), ri (G0 ) are the i-th relabeled
graph of G and G0 respectively.
Weisfeiler-Lehman Kernel NN Now with the above kernel definition, and random walk kernel as the base kernel,
we propose the following recurrent module:
(l)

=

(l)

=

c0 [v]
cj [v]

1)
W(l,0) h(l
v
X (l)
cj 1 [u]

W(l,j) h(l
v

1)

u2N (v)

h(l)
v
(l)
hG

=
=

0

@U1 h(l
v

X
v

(0)

c(l)
n [v]

1)

+ U2

X

u2N (v)

(Vh(l
u

1)

1

)A

1  l  L, 1 < j  n

where hv = fv and U1 , U2 , V are shared across layers.
PL
(l)
The final output of this network is hG = l=1 hG .
The above recurrent module is still an instance of deep kernel, even though some parameters are shared. A minor difference here is that there is an additional random walk kernel NN that connects i-th layer and the output layer. But
this is just a linear combination of L deep random walk
kernels (of different depth). Therefore, as an corollary of
Theorem 4, we have:
Proposition 2. For a Weisfeiler-Lehman Kernel NN with L
n
iterations and random walk kernel KW
as base kernel, the
P (l)
final output state hG =
l hG belongs to the RKHS of
(L)
kernel KW L (·, ·).

Deriving Neural Architectures from Sequence and Graph Kernels

4. Adaptive Decay with Neural Gates
The sequence and graph kernel (and their neural components) discussed so far use a constant decay value regardless of the current input. However, this is often not the
case since the importance of the input can vary across the
context or the applications. One extension is to make use of
neural gates that adaptively control the decay factor. Here
we give two illustrative examples:
Gated String Kernel NN By replacing constant decay
with a sigmoid gate, we modify our single-layer sequence
module as:
t

= (U[xt , ht

c1 [t] =

t

c1 [t

cj [t] =

t

cj [t

1]

+ b)
⇣
⌘
1] + W(1) xt
⇣
1] + cj 1 [t 1]

W(j) xt

1<jn

h[t] = (cn [t])

⌘

As compared with the original string kernel, now the decay
factor x,i,j is no longer |x| i 1 , but rather an adaptive
value based on current context.
Gated Random Walk Kernel NN Similarly, we could introduce gates so that different walks have different weights:
u,v

=

c0 [v]

=

cj [v]

=

(U[fu , fv ] + b)
W(0) fv
X

u,v

cj

1 [u]

W(j) fv

u2N (v)

hG

=

(

X

cn [v])

v

1<jn

The underlying kernel of the above gated network becomes
n
KW
(G, G0 ) =

X

X

n
Y

x2Pn (G) y2Pn (G0 ) i=1

xi ,yi

hfxi , fyi i

where each path is weighted by different decay weights,
determined by network itself.

5. Related Work
Sequence Networks Considerable effort has gone into designing effective networks for sequence processing. This
includes recurrent modules with the ability to carry persistent memories such as LSTM (Hochreiter & Schmidhuber, 1997) and GRU (Chung et al., 2014), as well as
non-consecutive convolutional modules (RCNNs, Lei et al.
(2015)), and others. More recently, Zoph & Le (2016) exemplified a reinforcement learning-based search algorithm
to further optimize the design of such recurrent architectures. Our proposed neural networks offer similar state

evolution and feature aggregation functionalities but derive the motivation for the operations involved from wellestablished kernel computations over sequences.
Recursive neural networks are alternative architectures to
model hierarchical structures such as syntax trees and logic
forms. For instance, Socher et al. (2013) employs recursive networks for sentence classification, where each node
in the dependency tree of the sentence is transformed into
a vector representation. Tai et al. (2015) further proposed
tree-LSTM, which incorporates LSTM-style architectures
as the transformation unit. Dyer et al. (2015; 2016) recently introduced a recursive neural model for transitionbased language modeling and parsing. While not specifically discussed in the paper, our ideas do extend to similar
neural components for hierarchical objects (e.g. trees).
Graph Networks Most of the current graph neural architectures perform either convolutional or recurrent operations on graphs. Duvenaud et al. (2015) developed Neural
Fingerprint for chemical compounds, where each convolution operation is a sum of neighbor node features, followed by a linear transformation. Our model differs from
theirs in that our generalized kernels and networks can aggregate neighboring features in a non-linear way. Other approaches, e.g., Bruna et al. (2013) and Henaff et al. (2015),
rely on graph Laplacian or Fourier transform.
For recurrent architectures, Li et al. (2015) proposed gated
graph neural networks, where neighbor features are aggregated by GRU function. Dai et al. (2016) considers a
different architecture where a graph is viewed as a latent
variable graphical model. Their recurrent model is derived
from Belief Propagation-like algorithms. Our approach is
most closely related to Dai et al. (2016), in terms of neighbor feature aggregation and resulting recurrent architecture. Nonetheless, the focus of this paper is on providing
a framework for how such recurrent networks could be derived from deep graph kernels.
Kernels and Neural Nets Our work follows recent work
demonstrating the connection between neural networks and
kernels (Cho & Saul, 2009; Hazan & Jaakkola, 2015).
For example, Zhang et al. (2016) showed that standard
feedforward neural nets belong to a larger space of recursively constructed kernels (given certain activation functions). Similar results have been made for convolutional
neural nets (Anselmi et al., 2015), and general computational graphs (Daniely et al., 2016). We extend prior work
to kernels and neural architectures over structured inputs,
in particular, sequences and graphs. Another difference is
how we train the model. While some prior work appeals
to convex optimization through improper learning (Zhang
et al., 2016; Heinemann et al., 2016) (since kernel space is
larger), we use the proposed networks as building blocks in
typical non-convex but flexible neural network training.

Deriving Neural Architectures from Sequence and Graph Kernels

6. Experiments
The left-over question is whether the proposed class of operations, despite its formal characteristics, leads to more
effective architecture exploration and hence improved performance. In this section, we apply the proposed sequence
and graph modules to various tasks and empirically evaluate their performance against other neural network models.
These tasks include language modeling, sentiment classification and molecule regression.
6.1. Language Modeling on PTB
Dataset and Setup We use the Penn Tree Bank (PTB) corpus as the benchmark. The dataset contains about 1 million
tokens in total. We use the standard train/development/test
split of this dataset with vocabulary of size 10,000.
Model Configuration Following standard practice, we use
SGD with an initial learning rate of 1.0 and decrease the
learning rate by a constant factor after a certain epoch. We
back-propagate the gradient with an unroll size of 35 and
use dropout (Hinton et al., 2012) as the regularization. Unless otherwise specified, we train 3-layer networks with
n = 1 and normalized adaptive decay.6 Following (Zilly
et al., 2016), we add highway connections (Srivastava et al.,
2015) within each layer:
c(l) [t] =
(l)

t

h [t] = ft

c(l) [t
(l)

1] + (1

c [t] + (1

ft )

t)

h

(W(l) h(l

(l 1)

1)

[t])

[t]

where h [t] = xt , t is the gated decay factor and ft is
the transformation gate of highway connections.
(0)

Results Table 1 compares our model with various state-ofthe-art models. Our small model with 5 million parameters
achieves a test perplexity of 73.6, already outperforming
many results achieved using much larger network. By increasing the network size to 20 million, we obtain a test
perplexity of 69.2, with standard dropout. Adding variational dropout (Gal & Ghahramani, 2016) within the recurrent cells further improves the perplexity to 65.5. Finally, the model achieves 63.8 perplexity when the recurrence depth is increased to 4, being state-of-the-art and on
par with the results reported in (Zilly et al., 2016; Zoph &
Le, 2016). Note that Zilly et al. (2016) uses 10 neural layers and Zoph & Le (2016) adopts a complex recurrent cell
found by reinforcement learning based search. Our network is architecturally much simpler.
Figure 3 analyzes several variants of our model. Wordlevel CNNs are degraded cases ( = 0) that ignore noncontiguous n-gram patterns. Clearly, this variant performs
worse compared to other recurrent variants with > 0.
6
See the supplementary sections for a discussion of network
variants: https://arxiv.org/abs/1705.09037

Table 1: Comparison with state-of-the-art results on PTB.
|✓| denotes the number of parameters. Following recent
work (Press & Wolf, 2016), we share the input and output word embedding matrix. We report the test perplexity
(PPL) of each model. Lower number is better.
Model
LSTM (large) (Zaremba et al., 2014)
Character CNN (Kim et al., 2015)
Variational LSTM (Gal & Ghahramani)
Variational LSTM (Gal & Ghahramani)
Pointer Sentinel-LSTM (Merity et al.)
Variational RHN (Zilly et al., 2016)
Neural Net Search (Zoph & Le, 2016)
Kernel NN ( = 0.8)
Kernel NN ( learned as parameter)
Kernel NN (gated )
Kernel NN (gated )
+ variational dropout
+ variational dropout, 4 RNN layers

CNNs

PPL
78.4
78.9
78.6
73.4
70.9
65.4
64.0
84.3
76.8
73.6
69.2
65.5
63.8

99.0

constants (0.8)
constants (trained)

|✓|
66m
19m
20m
66m
21m
23m
25m
5m
5m
5m
20m
20m
20m

84.3
76.8

adaptive (x)

74.2

adaptive (x and h)

73.6

Figure 3. Comparison between kernel NN variants on PTB. |✓| =
5m for all models. Hyper-parameter search is performed for each
variant.

Moreover, the test perplexity improves from 84.3 to 76.8
when we train the constant decay vector as part of the
model parameters. Finally, the last two variants utilize neural gates (depending on input xt only or on both input xt
and previous state h[t 1]), improving the performance 2-3
points.
6.2. Sentiment Classification
Dataset and Setup We evaluate our model on the sentence
classification task. We use the Stanford Sentiment Treebank benchmark (Socher et al., 2013). The dataset consists of 11855 parsed English sentences annotated at both
the root (i.e. sentence) level and the phrase level using 5class fine-grained labels. We use the standard split for training, development and testing. Following previous work, we
also evaluate our model on the binary classification variant
of this benchmark, ignoring all neutral sentences.

Deriving Neural Architectures from Sequence and Graph Kernels

Table 2: Classification accuracy on Stanford Sentiment
Treebank. Block I: recursive networks; Block II: convolutional or recurrent networks; Block III: other baseline
methods. Higher number is better.
Model
RNN (Socher et al. (2011))
RNTN (Socher et al. (2013))
DRNN (Irsoy & Cardie (2014))
RLSTM (Tai et al. (2015))
DCNN (Kalchbrenner et al. (2014))
CNN-MC (Kim (2014))
Bi-LSTM (Tai et al. (2015))
LSTMN (Cheng et al. (2016))
PVEC (Le & Mikolov (2014))
DAN (Iyyer et al. (2014))
DMN (Kumar et al. (2016))
Kernel NN, = 0.5
Kernel NN, gated

Fine
43.2
45.7
49.8
51.0
48.5
47.4
49.1
47.9
48.7
48.2
52.1
51.2
53.2

Binary
82.4
85.4
86.8
88.0
86.9
88.1
87.5
87.0
87.8
86.8
88.6
88.6
89.9

Table 3: Experiments on Harvard Clean Energy Project.
We report Root Mean Square Error(RMSE) on test set. The
first block lists the results reported in Dai et al. (2016) for
reference. For fair comparison, we reimplemented their
best model so that all models are trained under the same
setup. Results under our setup is reported in second block.
Model (Dai et al., 2016)
Mean Predicator
Weisfeiler-lehman Kernel, degree=3
Weisfeiler-lehman Kernel, degree=6
Embedded Mean Field
Embedded Loopy BP
Under Our Setup
Neural Fingerprint
Embedded Loopy BP
Weisfeiler Kernel NN
Weisfeiler Kernel NN, gated

|✓|
1
1.6m
1378m
0.1m
0.1m

RMSE
2.4062
0.2040
0.1367
0.1250
0.1174

0.26m
0.26m
0.26m
0.26m

0.1409
0.1065
0.1058
0.1043

emphasis on molecules with higher PCE values, since the
data is distributed unevenly.
Following the recent work of DAN (Iyyer et al., 2015) and
RLSTM (Tai et al., 2015), we use the publicly available
300-dimensional GloVe word vectors (Pennington et al.,
2014). Unlike prior work which fine tunes the word vectors, we normalize the vectors (i.e. kwk22 = 1) and fixed
them for simplicity.

We use the same feature set as in Duvenaud et al. (2015) for
atoms and bonds. Initial atom features include the atoms
element, its degree, the number of attached hydrogens, its
implicit valence, and an aromaticity indicator. The bond
feature is a concatenation of bond type indicator, whether
the bond is conjugated, and whether the bond is in a ring.

Model Configuration Our best model is a 3-layer network
with n = 2 and hidden dimension d = 200. We average
the hidden states h[t] across t, and concatenate the averaged
vectors from the 3 layers as the input of the final softmax
layer. The model is optimized with Adam (Kingma & Ba,
2015), and dropout probability of 0.35.

Model Configuration Our model is a Weisfeiler-Lehman
NN, with 4 recurrent iterations and n = 2. All models
(including baseline) are optimized with Adam (Kingma &
Ba, 2015), with learning rate decay factor 0.9.

Results Table 2 presents the performance of our model
and other networks. We report the best results achieved
across 5 independent runs. Our best model obtains 53.2%
and 89.9% test accuracies on fine-grained and binary tasks
respectively. Our model with only a constant decay factor
also obtains quite high accuracy, outperforming other baseline methods shown in the table.
6.3. Molecular Graph Regression
Dataset and Setup We further evaluate our graph NN
models on the Harvard Clean Energy Project benchmark,
which has been used in Dai et al. (2016); Duvenaud et al.
(2015) as their evaluation dataset. This dataset contains 2.3
million candidate molecules, with each molecule labeled
with its power conversion efficiency (PCE) value.
We follow exactly the same train-test split as Dai et al.
(2016), and the same re-sampling procedure on the training
data (but not the test data) to make the algorithm put more

Results In Table 3, we report the performance of our
model against other baseline methods. Neural Fingerprint (Duvenaud et al., 2015) is a 4-layer convolutional neural network. Convolution is applied to each atom, which
sums over its neighbors’ hidden state, followed by a linear transformation and non-linear activation. Embedded
Loopy BP (Dai et al., 2016) is a recurrent architecture, with
4 recurrent iterations. It maintains message vectors for each
atom and bond, and propagates those vectors in a message
passing fashion. Table 3 shows our model achieves stateof-the-art against various baselines.

7. Conclusion
We proposed a class of deep recurrent neural architectures
and formally characterized its underlying computation using kernels. By linking kernel and neural operations, we
have a “template” for deriving new families of neural architectures for sequences and graphs. We hope the theoretical
view of kernel neural networks can be helpful for future
model exploration.

Deriving Neural Architectures from Sequence and Graph Kernels

Acknowledgement
We thank Prof. Le Song for sharing Harvard Clean Energy Project dataset. We also thank Yu Zhang, Vikas Garg,
David Alvarez, Tianxiao Shen, Karthik Narasimhan and
the reviewers for their helpful comments. This work was
supported by the DARPA Make-It program under contract
ARO W911NF-16-2-0023.

References
Anselmi, Fabio, Rosasco, Lorenzo, Tan, Cheston, and Poggio, Tomaso. Deep convolutional networks are hierarchical kernel machines. preprint arXiv:1508.01084, 2015.
Bruna, Joan, Zaremba, Wojciech, Szlam, Arthur, and LeCun, Yann. Spectral networks and locally connected networks on graphs. arXiv preprint arXiv:1312.6203, 2013.

Dyer, Chris, Kuncoro, Adhiguna, Ballesteros, Miguel, and
Smith, Noah A. Recurrent neural network grammars. In
Proceedings of the 2016 Conference of the North American Chapter of the Association for Computational Linguistics, San Diego, California, June 2016.
Gal, Yarin and Ghahramani, Zoubin. A theoretically
grounded application of dropout in recurrent neural networks. In Advances in Neural Information Processing
Systems 29 (NIPS), 2016.
Gärtner, Thomas, Flach, Peter, and Wrobel, Stefan. On
graph kernels: Hardness results and efficient alternatives. In Learning Theory and Kernel Machines, pp.
129–143. Springer, 2003.
Hazan, Tamir and Jaakkola, Tommi. Steps toward deep
kernel methods from infinite neural networks. arXiv
preprint arXiv:1508.05133, 2015.

Cheng, Jianpeng, Dong, Li, and Lapata, Mirella. Long
short-term memory networks for machine reading. Proceedings of the Conference on Empirical Methods in
Natural Language Processing, pp. 551–562, 2016.

Heinemann, Uri, Livni, Roi, Eban, Elad, Elidan, Gal, and
Globerson, Amir. Improper deep kernels. In Proceedings of the 19th International Conference on Artificial
Intelligence and Statistics, pp. 1159–1167, 2016.

Cho, Youngmin and Saul, Lawrence K. Kernel methods for
deep learning. In Bengio, Y., Schuurmans, D., Lafferty,
J. D., Williams, C. K. I., and Culotta, A. (eds.), Advances
in Neural Information Processing Systems 22, pp. 342–
350. 2009.

Henaff, Mikael, Bruna, Joan, and LeCun, Yann. Deep
convolutional networks on graph-structured data. arXiv
preprint arXiv:1506.05163, 2015.

Chung, Junyoung, Gulcehre, Caglar, Cho, KyungHyun,
and Bengio, Yoshua. Empirical evaluation of gated recurrent neural networks on sequence modeling. arXiv
preprint arXiv:1412.3555, 2014.
Dai, Hanjun, Dai, Bo, and Song, Le. Discriminative embeddings of latent variable models for structured data.
arXiv preprint arXiv:1603.05629, 2016.
Daniely, Amit, Frostig, Roy, and Singer, Yoram. Toward
deeper understanding of neural networks: The power of
initialization and a dual view on expressivity. CoRR,
abs/1602.05897, 2016.
Duvenaud, David K, Maclaurin, Dougal, Iparraguirre,
Jorge, Bombarell, Rafael, Hirzel, Timothy, AspuruGuzik, Alán, and Adams, Ryan P. Convolutional networks on graphs for learning molecular fingerprints. In
Advances in neural information processing systems, pp.
2224–2232, 2015.
Dyer, Chris, Ballesteros, Miguel, Ling, Wang, Matthews,
Austin, and Smith, Noah A. Transition-based dependency parsing with stack long short-term memory. In
Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), Beijing, China, July 2015.

Hinton, Geoffrey E, Srivastava, Nitish, Krizhevsky, Alex,
Sutskever, Ilya, and Salakhutdinov, Ruslan R. Improving
neural networks by preventing co-adaptation of feature
detectors. arXiv preprint arXiv:1207.0580, 2012.
Hochreiter, Sepp and Schmidhuber, Jürgen. Long shortterm memory. Neural computation, 9(8):1735–1780,
1997.
Irsoy, Ozan and Cardie, Claire. Deep recursive neural networks for compositionality in language. In Advances in
Neural Information Processing Systems, 2014.
Iyyer, Mohit, Boyd-Graber, Jordan, Claudino, Leonardo,
Socher, Richard, and Daumé III, Hal. A neural network for factoid question answering over paragraphs. In
Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP), pp. 633–
644, Doha, Qatar, October 2014.
Iyyer, Mohit, Manjunatha, Varun, Boyd-Graber, Jordan,
and Daumé III, Hal. Deep unordered composition rivals
syntactic methods for text classification. In Proceedings
of the 53rd Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), 2015.
Kalchbrenner, Nal, Grefenstette, Edward, and Blunsom,
Phil. A convolutional neural network for modelling sentences. In Proceedings of the 52th Annual Meeting of the
Association for Computational Linguistics, 2014.

Deriving Neural Architectures from Sequence and Graph Kernels

Kim, Yoon. Convolutional neural networks for sentence
classification. In Proceedings of the Empiricial Methods
in Natural Language Processing (EMNLP 2014), 2014.
Kim, Yoon, Jernite, Yacine, Sontag, David, and Rush,
Alexander M. Character-aware neural language models. Twenty-Ninth AAAI Conference on Artificial Intelligence, 2015.
Kingma, Diederik P and Ba, Jimmy Lei. Adam: A method
for stochastic optimization. In International Conference
on Learning Representation, 2015.
Kumar, Ankit, Irsoy, Ozan, Ondruska, Peter, Iyyer, Mohit, James Bradbury, Ishaan Gulrajani, Zhong, Victor,
Paulus, Romain, and Socher, Richard. Ask me anything: Dynamic memory networks for natural language
processing. 2016.
Le, Quoc and Mikolov, Tomas. Distributed representations
of sentences and documents. In Proceedings of the 31st
International Conference on Machine Learning (ICML14), pp. 1188–1196, 2014.
Lei, Tao, Joshi, Hrishikesh, Barzilay, Regina, Jaakkola,
Tommi, Tymoshenko, Katerina, Moschitti, Alessandro, and Marquez, Lluis.
Semi-supervised question retrieval with gated convolutions. arXiv preprint
arXiv:1512.05726, 2015.
Li, Yujia, Tarlow, Daniel, Brockschmidt, Marc, and Zemel,
Richard. Gated graph sequence neural networks. arXiv
preprint arXiv:1511.05493, 2015.
Lodhi, Huma, Saunders, Craig, Shawe-Taylor, John, Cristianini, Nello, and Watkins, Chris. Text classification
using string kernels. Journal of Machine Learning Research, 2(Feb):419–444, 2002.
Merity, Stephen, Xiong, Caiming, Bradbury, James, and
Socher, Richard. Pointer sentinel mixture models. arXiv
preprint arXiv:1609.07843, 2016.
Pennington, Jeffrey, Socher, Richard, and Manning,
Christopher D. Glove: Global vectors for word representation. volume 12, 2014.
Press, Ofir and Wolf, Lior. Using the output embedding to improve language models. arXiv preprint
arXiv:1608.05859, 2016.
Ramon, Jan and Gärtner, Thomas. Expressivity versus efficiency of graph kernels. In First international workshop
on mining graphs, trees and sequences, pp. 65–74. Citeseer, 2003.
Shalev-Shwartz, Shai, Shamir, Ohad, and Sridharan,
Karthik. Learning kernel-based halfspaces with the 01 loss. SIAM Journal on Computing, 40(6):1623–1646,
2011.

Shervashidze, Nino, Schweitzer, Pascal, Leeuwen, Erik
Jan van, Mehlhorn, Kurt, and Borgwardt, Karsten M.
Weisfeiler-lehman graph kernels. Journal of Machine
Learning Research, 12(Sep):2539–2561, 2011.
Socher, Richard, Pennington, Jeffrey, Huang, Eric H,
Ng, Andrew Y, and Manning, Christopher D. Semisupervised recursive autoencoders for predicting sentiment distributions. In Proceedings of the Conference on
Empirical Methods in Natural Language Processing, pp.
151–161, 2011.
Socher, Richard, Perelygin, Alex, Wu, Jean, Chuang, Jason, Manning, Christopher D., Ng, Andrew Y., and Potts,
Christopher. Recursive deep models for semantic compositionality over a sentiment treebank. In Proceedings
of the 2013 Conference on Empirical Methods in Natural
Language Processing, pp. 1631–1642, October 2013.
Srivastava, Rupesh K, Greff, Klaus, and Schmidhuber,
Jürgen. Training very deep networks. In Advances in
neural information processing systems, pp. 2377–2385,
2015.
Tai, Kai Sheng, Socher, Richard, and Manning, Christopher D. Improved semantic representations from treestructured long short-term memory networks. In Proceedings of the 53th Annual Meeting of the Association
for Computational Linguistics, 2015.
Tamar, Aviv, Levine, Sergey, Abbeel, Pieter, Wu, Yi, and
Thomas, Garrett. Value iteration networks. In Advances
in Neural Information Processing Systems, pp. 2146–
2154, 2016.
Vishwanathan, S Vichy N, Schraudolph, Nicol N, Kondor,
Risi, and Borgwardt, Karsten M. Graph kernels. Journal of Machine Learning Research, 11(Apr):1201–1242,
2010.
Zaremba, Wojciech, Sutskever, Ilya, and Vinyals, Oriol.
Recurrent neural network regularization. arXiv preprint
arXiv:1409.2329, 2014.
Zhang, Yuchen, Lee, Jason D., and Jordan, Michael I. `1 regularized neural networks are improperly learnable in
polynomial time. In Proceedings of the 33nd International Conference on Machine Learning, 2016.
Zilly, Julian Georg, Srivastava, Rupesh Kumar, Koutnı́k,
Jan, and Schmidhuber, Jürgen. Recurrent Highway Networks. arXiv preprint arXiv:1607.03474, 2016.
Zoph, Barret and Le, Quoc V.
Neural architecture
search with reinforcement learning. arXiv preprint
arXiv:1611.01578, 2016.

