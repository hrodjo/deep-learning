Learning Infinite Layer Networks Without the Kernel Trick

Roi Livni 1 Daniel Carmon 2 Amir Globerson 2

Abstract
Infinite Layer Networks (ILN) have been proposed as an architecture that mimics neural networks while enjoying some of the advantages
of kernel methods. ILN are networks that integrate over infinitely many nodes within a single hidden layer. It has been demonstrated by
several authors that the problem of learning ILN
can be reduced to the kernel trick, implying that
whenever a certain integral can be computed analytically they are efficiently learnable. In this
work we give an online algorithm for ILN, which
avoids the kernel trick assumption. More generally and of independent interest, we show that
kernel methods in general can be exploited even
when the kernel cannot be efficiently computed
but can only be estimated via sampling. We provide a regret analysis for our algorithm, showing
that it matches the sample complexity of methods
which have access to kernel values. Thus, our
method is the first to demonstrate that the kernel
trick is not necessary, as such, and random features suffice to obtain comparable performance.

1. Introduction
With the increasing success of highly non-convex and complex learning architectures such as neural networks, there
is an increasing effort to further understand and explain the
limits of training such hierarchical structures.
Recently there have been attempts to draw mathematical
insight from kernel methods in order to better understand
deep learning, as well as come up with new computationally learnable architectures. One such line of work consists
of learning classifiers that are linear functions of a very
large or infinite collection of non-linear functions (Bach,
1

University of Princeton, Princeton, New Jersey,
USA 2 Tel-Aviv University, Tel-Aviv, Israel.
Correspondence to: Roi Livni <rlivni@cs.princeton.edu>, Daniel
Carmon <carmonda@mail.tau.ac.il>,
Amir Globerson
<gamir@mail.tau.ac.il>.
Proceedings of the 34 th International Conference on Machine
Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017
by the author(s).

2014; Daniely et al., 2016; Cho & Saul, 2009; Heinemann
et al., 2016; Williams, 1997). Such models can be interpreted as a neural network with infinitely many nodes in a
hidden layer, and we thus refer to them as “Infinite Layer
Networks” (ILN). They are of course also related to kernel
based classifiers, as will be discussed later.
A target function in an ILN class will be of the form:
Z
x → ψ(x; w)f (w)dµ(w),

(1)

Here ψ is some function of the input x and parameters w,
and dµ(w) is a prior over the parameter space. For example, ψ(x; w) can be a single sigmoidal neuron or a complete convolutional network. The integral can be thought
of as an infinite sum over all such possible networks, and
f (w) can be thought of as an infinite output weight vector
to be trained.
A Standard 1–hidden layer network with a finite set of units
can be obtained from the above formalism as follows. First,
choose ψ(x; w) = σ(x · w) where σ is an activation function (e.g., sigmoid or relu). Next, set dµ(w) to be a discrete
measure over a finite set w1 , . . . , wd .1 In this case, the integral results in a network with d hidden units, and the function f is the linear weights of the output layer. Namely:
d

x→

1X
f (wi ) · σ(x · wi ).
d i=1

The main challenge when training 1–hidden layer networks
is of course to find the w1 , . . . , wd on which we wish to
support our distribution. It is known (Livni et al., 2014),
that due to hardness of learning intersection of halfspaces
(Klivans & Sherstov, 2006; Daniely et al., 2014), 1–hidden
layer neural networks are computationally hard for a wide
class of activation functions. Therefore, as the last example illustrates, the choice of µ is indeed crucial for performance.
For a fixed prior µ, the class of ILN functions is highly
expressive, since f can be chosen to approximate any 1hidden layer architecture to arbitrary precision (by setting
f to delta functions around the weights of the network, as
1

In δ function notation dµ(w) =

1
d

Pd

i=1

δ(w − wi )dw

Learning Infinite Layer Networks Without the Kernel Trick

we did above for µ). However, this expressiveness comes
at a cost. As argued in Heinemann et al. (2016), ILN will
generalize well when there is a large probability mass of w
parameters that attain a small loss.
The key observation that makes certain ILN tractable to
learn is that Eq. 1 is a linear functional in f . In that sense it
is a linear classifier and enjoys the rich theory and algorithmic toolbox for such classifiers. In particular, one can use
the fact that linear classifiers can be learned via the kernel
trick in a batch (Cortes & Vapnik, 1995) as well as online
settings (Kivinen et al., 2004). In other words, we can reduce learning ILN to the problem of computing the kernel
function between two examples. Specifically the problem
reduces to computing integrals of the following form:
Z
k(x1 , x2 ) =
ψ(x1 ; w) · ψ(x2 ; w)dµ(w) (2)
=

E [ψ(x1 ; w̄) · ψ(x2 ; w̄)] .

w̄∼µ

(3)

In this work we extend this result to the case where no
closed form kernel is available, and thus the kernel trick
is not directly applicable. We thus turn our attention to the
setting where features (i.e., w vectors) can be randomly
sampled. In this setting, our main result shows that for
the squared loss, we can efficiently learn the above class.
Moreover, we can surprisingly do this with a computational
cost comparable to that of methods that have access to the
closed form kernel k(x1 , x2 ).
The observation we begin with is that sampling random
features (i.e., w above), leads to an unbiased estimate of
the kernel in Eq. 2. Thus, if for example, we ignore complexity issues and can sample infinitely many w’s, it is not
surprising that we can avoid the need for exact computation of the kernel. However, our results provide a much
stronger and practical result. Given T training√samples,
the lower bound on achievable accuracy is O(1/ T ) (see
Shamir, 2015). We show that we can in fact achieve this
rate, using Õ(T 2 ) calls2 to the random feature generator.
For comparison, note that O(T 2 ) is the size of the kernel
matrix, and is thus likely to be the cost of any algorithm
that uses an explicit kernel matrix, where one is available.
As we discuss later, our approach improves on previous
random features based learning (Dai et al., 2014; Rahimi &
Recht, 2009) in terms of sample/computational complexity,
and expressiveness.

2. Problem Setup
We consider algorithms that learn a mapping from input
instances x ∈ X to labels y ∈ Y. We focus on the regression case where Y is the interval [−1, 1]. Our starting
point is a class of feature functions ψ(w; x) : Ω × X → R,
2

We use Õ notation to suppress logarithmic factors

parametrized by vectors w ∈ Ω. The functions ψ(w; x)
may contain highly complex non linearities, such as multilayer networks consisting of convolution and pooling layers. Our only assumption on ψ(w; x) is that for all w ∈ Ω
and x ∈ X it holds that |ψ(w; x)| < 1.
Given a distribution µ on Ω, we denote by L2 (Ω, µ) the
class of square integrable functions over Ω.
 Z

2
L2 (Ω, µ) = f : f (w)dµ(w) < ∞ .
We will use functions f ∈ L2 (Ω, µ) as mixture weights
over the class Ω, where each f naturally defines a new regression function from x to R as follows:
Z
x → ψ(w; x)f (w)dµ(w).
(4)
Our key algorithmic assumption is that the learner can efficiently sample random w according to the distribution µ.
Denote the time to generate one such sample by ρ.
In what follows it will be simpler to express the integrals
as scalar products. Define the following scalar product on
functions f ∈ L2 (Ω, µ).
Z
hf, gi = f (w)g(w)dµ(w)
(5)
p
We denote the corresponding `2 norm by kf k = hf, f i.
Also, given features x denote by Φ(x) the function in
L2 (Ω, µ) given by Φ(x)[w] = ψ(w; x). The regression functions we are considering are then of the form
x → hf, Φ(x)i.
A subclass of norm bounded elements in L2 (Ω, µ) induces
a natural subclass of regression functions. Namely, we consider the following class:
HµB = {x → hf, Φ(x)i : kf k < B} .
Our ultimate goal is to output a predictor f ∈ L2 (Ω, µ) that
is competitive, in terms of prediction, with the best target
function in the class HµB .
We will consider an online setting, and use it to derive generalization bounds via standard online to batch conversion.
In our setting, at each round a learner chooses a target function ft ∈ L2 (Ω, µ) and an adversary then reveals a sample
xt and label yt . The learner then incurs a loss of
`t (ft ) =

1
2
(hft , Φ(xt )i − yt ) .
2

(6)

The use of squared loss might seem restrictive if one is interested in classification. However, L2 loss is common by
now in classification with support vector machines and kernel methods since (Suykens & Vandewalle, 1999; Suykens

Learning Infinite Layer Networks Without the Kernel Trick

et al., 2002). More recently Zhang et al. (2016) showed that
when using a large number of features regression achieves
performance comparable to the corresponding linear classifiers (see Section 5 therein).
The objective of the learner is to minimize her T round
regret w.r.t norm bounded elements in L2 (Ω, µ). Namely:
T
X

`t (ft ) − min

t=1

f ∗ ∈HB
µ

T
X

`t (f ∗ ).

(7)

t=1

In the statistical setting we assume that the sequence S =
{(xi , yi )}Ti=1 is generated IID according to some unknown
distribution P. We then define the expected loss of a predictor as


1
2
(hf, Φ(x)i − y) .
(8)
L(f ) = E
(x,y)∼P 2

3. Main Results
Theorem 1 states our result for the online model. The corresponding result for the statistical setting is given in Corollary 1. We will elaborate on the structure of the Algorithm
later, but first provide the main result.
Algorithm 1: The SHRINKING GRADIENT algorithm.
Data: T, B > 1, η, m
Result: Weights α(1) , . . . , α(T +1) ∈ RT . Functions
ft ∈ L2 (Ω, µ) defined as
Pt
(t)
ft = i=1 αi Φ(xi );
Initialize α(1) = 0̄ ∈ RT ;
for t = 1, . . . , T do
Observe xt , yt ;
Set Et =
EST SCALAR PROD(α(t) , x1:t−1 , xt , m);
if |Et | < 16B then
α(t+1) = α(t) ;
(t+1)

αt
= −η(yt − Et );
else
α(t+1) = 14 α(t) ;

Algorithm 2: EST SCALAR PROD
Data: α, x1:t−1 , x, m
Result: Estimated scalar product E
if α = 0̄ then
Set E = 0
else
for k=1.. . . ,m do
Sample i from the distribution q(i) =
;
Sample parameter w̄ from µ. Set
E (k) = sgn(αi )ψ(xi ; w̄)ψ(x; w̄);
Pm
1
(k)
Set E = kαk
k=1 E
m

|αi |
P
|αi |


2. The run-time of the algorithm is Õ ρB 4 T 2 .3
3. For each t = 1 . . . T and a new test example x, we can
with probability ≥ 1 − δ estimate hft , Φ(x)i within
accuracy 0 by running Algorithm 2 with parameters
4
α(t) , {xi }ti=1 , , x and m = O( B2T log 1/δ). The re0
sulting running time for a test point is then O(ρm).
We next turn to the statistical setting, where we provide
bounds on the expected performance. Following standard
online to batch conversion and Theorem 1 we can obtain
the following Corollary (e.g., see Shalev-Shwartz, 2011):
Corollary 1 (Statistical Setting). The following holds for
any  > 0. Run Algorithm 1 as in Theorem 1, with T =
2
O( B2 ). Let S = {(xt , yt )}Tt=1 , be an IID sample drawn
P
from some unknown distribution P. Let fS = T1
ft .
Then the expected loss satisfies:
E [L(fS )] <

S∼P

inf L(f ∗ ) + .

f ∗ ∈HB
µ

The runtime of the algorithm, as well as estimation time on
a test example are as defined in Theorem 1.
Proofs of the results are provided in Section 5.1 and the
appendix.

4. Related Work
Theorem 1. Run Algorithm 1 with parameters
T , B ≥ 1,

η = √BT and m = O B 4 T log (BT ) . Then:
1. For every sequence of squared losses `1 , . . . , `T observed by the algorithm we have for f1 , . . . , fT :
" T
#
T
X
X
√
∗
`t (ft ) − min
`t (f ) = O(B T )
E
t=1

f ∗ ∈HB
µ

t=1

Learning with random features can be traced to the early
days of learning (Minsky & Papert, 1988), and infinite
networks have also been introduced more than 20 years
ago (Williams, 1997; Hornik, 1993). More recent works
have considered learning neural nets (also multi-layer) with
infinite hidden units using the kernel trick (Cho & Saul,
2009; Deng et al., 2012; Hazan & Jaakkola, 2015; Heinemann et al., 2016). These works take a similar approach
3

Ignoring logarithmic factors in B and T .

Learning Infinite Layer Networks Without the Kernel Trick

to ours but focus on computing the kernel for certain feature classes in order to invoke the kernel trick. Our work
in contrast avoids using the kernel trick and applies to any
feature class that can be randomly generated. All the above
works are part of a broader effort of trying to circumvent
hardness in deep learning by mimicking deep nets through
kernels (Mairal et al., 2014; Bouvrie et al., 2009; Bo et al.,
2011; 2010), and developing general duality between neural networks and kernels (Daniely et al., 2016).
From a different perspective the relation between random
features and kernels has been noted by Rahimi & Recht
(2007) who show how to represent translation invariant kernels in terms of random features. This idea has been further
studied (Bach, 2015; Kar & Karnick, 2012) for other kernels as well. The focus of these works is mainly to allow
scaling down of the feature space and representation of the
final output classifier.
Dai et al. (2014) focus on tractability of large scale kernel
methods, and their proposed doubly stochastic algorithm
can also be used for learning with random features as we
have here. In Dai et al. (2014) the objective considered is
of the regularized form: γ2 kf k2 + R(f ), with a corresponding sample complexity of O(1/(γ 2 2 )) samples needed to
achieve  approximation with respect to the risk of the optimum of the regularized objective.
To relate the above results to ours, we begin by emphasizing that the bound in (Dai et al., 2014) holds for fixed γ, and
refers to optimization of the regularized objective. Our objective is to minimize the risk R(f ) which is the expected
squared loss, for which we need to choose γ = O( B2 ) in
order to attain accuracy  (Sridharan et al., 2009). Plugging
this γ into the generalization bound in Dai et al. (2014) we
4
obtain that the algorithm in Dai et al. (2014) needs O( B4 )
samples to compete with the optimal target function in the
2
B-ball. Our algorithm needs O( B2 ) examples which is
considerably better. We note that their method does extend to a larger class of losses, whereas our is restricted to
the quadratic loss.
In Rahimi & Recht (2009), the authors consider embedding the domain into the feature space x →
[ψ(w1 ; x), . . . , ψ(wm ; x)], where wi are IID random variables sampled according to some prior µ(w). They
2
1/δ
show that with O( B log
) random features estimated on
2
O( B

2

log 1/δ
)
2

HµB max =



samples they can compete with the class:

Z
x → ψ(w; x)f (w)dµ(w) : |f (w)| ≤ B

Our algorithm relates to the mean square error cost function which does not meet the condition in Rahimi & Recht
(2009), and is hence formally incomparable. Yet we can
invoke our algorithm to compete against a larger class

of target functions. Our main result shows that Algo8
2
rithm 1, using Õ( B4 ) estimated features and using O( B2 )
samples will, in expectation, output a predictor that is 
close to the best in HµB . Note that |f (w)| < B implies
Ew∼µ (f 2 (w)) < B 2 . Hence HµB max ⊆ HµB . Note however, that the number of estimated features (as a function of
B) is worse in our case.
Our approach to the problem is to consider learning with
a noisy estimate of the kernel. A related setting was studied in Cesa-Bianchi et al. (2011b), where the authors considered learning with kernels when the data is corrupted.
Noise in the data and noise in the scalar product estimation are not equivalent when there is non-linearity in the
kernel space embedding. There is also extensive research
on linear regression with actively chosen attributes (CesaBianchi et al., 2011a; Hazan & Koren, 2012). The convergence rates and complexity of the algorithms are dimension
dependent. It would be interesting to see if their method
can be extended from finite set of attributes to a continuum
set of attributes.

5. Algorithm
We next turn to present Algorithm 1, from which our main
result is derived. The algorithm is similar in spirit to Online
Gradient Descent (OGD) (Zinkevich, 2003), but with some
important modifications that are necessary for our analysis.
We first introduce the problem in the terminology of online
convex optimization, as in Zinkevich (2003). At iteration t
our algorithm outputs a hypothesis ft . It then receives as
feedback (xt , yt ), and suffers a loss `t (ft ) as in Eq. 6. The
objective of the algorithm is to minimize the regret against
a benchmark of B-bounded functions, as in Eq. 7.
A classic approach to the problem is to exploit the OGD
algorithm. Its simplest version would be to update ft+1 →
ft − η∇t where η is a step size, and ∇t is the gradient of
the loss w.r.t. f at ft . In our case, ∇t is given by:
∇t = (hft , Φ(xt )i − yt ) Φ(xt )

(9)

Applying this update would also result in a function ft =
P
t
i=1 αi Φ(xt ) as we have in Algorithm 1 (but with different αi from ours). However, in our setting this update is
not applicable since the scalar product hft , Φ(xt )i is not
available. One alternative is to use a stochastic unbiased
¯ t . This inestimate of the gradient that we denote by ∇
¯
duces an update step ft+1 → ft − η ∇t . One can show that
OGD with such an estimated gradient
enjoys the following
P
upper bound on the regret E [ `t (ft ) − `t (f ∗ )] for every
kf ∗ k ≤ B (e.g., see Shalev-Shwartz, 2011):
T
T
X
X


 
B2
¯t ,
+η
E k∇t k2 + η
V ∇
η
i=1
i=1

(10)

Learning Infinite Layer Networks Without the Kernel Trick

 


¯ t = E k∇
¯ t − ∇t k2 . We can bound the
where V ∇
first two terms using standard techniques applicable for the
squared loss (e.g., see Zhang, 2004; Srebro et al., 2010).
The third term depends on our choice of gradient estimate.
There are various choices for such an estimate, and we use
a version which facilitates our analysis, as explained below.
Assume that at iteration t, our function ft is given by ft =
Pt
(t)
i=1 αi Φ(xt ). We now want to use sampling to obtain
an unbiased estimate of hft , Φ(xt )i. This will be done via
a two step sampling procedure, as described in Algorithm
2. First, sample an index i ∈ [1, . . . , t] by sampling ac(t)
cording to the distribution q(i) ∝ |αi |. Next, for the chosen i, sample w̄ according to µ, and use ψ(x; w̄)ψ(xi ; w̄)
to construct an estimate of hΦ(xi ), Φ(xt )i. The resulting
unbiased estimate of hΦ(xi ), Φ(xt )i is denoted by Et and
given by:
m
kα(t) k1 X
(t)
sgn(αi )ψ(xi ; w̄)ψ(xt ; w̄)
Et =
m i=1

(11)

The corresponding unbiased gradient estimate is:
¯ t = (Et − yt ) xt
∇

(12)

¯ affects the convergence rate and depends
The variance of ∇
on both kαk1 and the number of estimations m. We wish to
maintain
√ m = O(T ) estimations per round, while achieving O( T ) regret.
To effectively regularize kαk1 , we modify the OGD algorithm so that whenever Et is larger then 16B, we do not
perform the usual update. Instead, we perform a shrinking
step that divides α(t) (and hence ft ) by 4. Treating B as
constant, this guarantees that kαk1 = O(ηT ), and in turn
√
¯ t ) = O( η2 T 2 ). Setting η = O(1/ T ), we have that
Var(∇
m
m = O(T ) estimations are sufficient.
The rationale for the shrinkage is that whenever Et is large,
it indicates that ft is “far away” from the B-ball, and a
shrinkage step, similar to projection, brings ft closer to the
optimal element in the B-ball. However, due to stochasticity, the shrinkage step does add a further term to the regret
bound that we would need to take care of.
5.1. Analysis
In what follows we analyze the regret for Algorithm 1, and
provide a high level proof of Theorem 1. The appendix
provides the necessary lemmas and a more detailed proof.
We begin by modifying the regret bound for OGD in Eq. 10
to accommodate for steps that differ from the standard gradient update, such as shrinkage. We use the following notation for the regret at iteration t:
" T
#
X
∗
∗
Rt (f ) = E
`t (ft ) − `t (f )
(13)
t=1

Lemma 1. Let `1 , . . . , `T be an arbitrary sequence of convex loss functions, and let f1 , . . . , fT be random vectors,
produced by an online algorithm. Assume kfi k ≤ BT for
¯ t be an unbiased estimator of
all i ≤ T . For each t let ∇
ˆ
¯ t−1 and let
∇`t (ft ). Denote ft = ft−1 − η ∇
h
i
Pt (f ∗ ) = P kft − f ∗ k > kfˆt − f ∗ k .
(14)
For every kf ∗ k ≤ B it holds that :
Rt (f ∗ ) ≤

T
T
X
X


 
B2
¯t +
+η
E k∇t k2 + η
V ∇
η
t=1
t=1
T
X
(BT + B)2
E [Pt (f ∗ )]
η
t=1

(15)

See Appendix B.1 for proof of the lemma. As discussed
earlier, the first three terms on the RHS are the standard
bound for OGD from Eq. 10. Note that in the standard
OGD it holds that ft = fˆt , and therefore Pt (f ∗ ) = 0 and
the last term disappears.
The third term will be bounded by controlling kαk1 . The
last term Pt (f ∗ ) is a penalty that results from updates that
stir ft away from the standard update step fˆt . This will
indeed happen for the shrinkage step. The next lemma
bounds this term. See Appendix B.2 for proof.
Lemma 2. Run Algorithm 1 with parameters T , B ≥ 1
¯ t be the unbiased estimator of ∇`t (ft )
and η < 1/8. Let ∇
¯ t = (Et − yt )Φ(xt ). Denote fˆt = ft − η ∇
¯t
of the form ∇
and define Pt (f ∗ ) as in Eq. 14. Then:


m
Pt (f ∗ ) ≤ 2 exp −
(3ηt)2
The following lemma (see Appendix B.3 for proof) bounds
the second and third terms of Eq. 15.
Lemma 3. Consider the setting as in Lemma 2. Then
  ((16B+1)ηt)2


¯t ≤
V ∇
and E k∇t k2 ≤ 2E [`t (ft )].
m
Proof of Theorem 1 Combining Lemmas 1, 2 and 3 and
rearranging we get:
(1 − 2η)E [Rt (f ∗ )] ≤

η

T
X
B2
+ 2η
`t (f ∗ ) + (16)
η
t=1

T
((16B + 1)ηT )2 T
(BT + B)2 X
+
Pt (f ∗ )
m
η
t=1

To bound the second term in Eq. 16 we note that:
min
∗

kf k<B

T
X
t=1

`t (f ∗ ) ≤

T
X
t=1

`t (0) ≤ T.

(17)

Learning Infinite Layer Networks Without the Kernel Trick

We next set η and m as in the statement of the theorem.
B
Namely: η = 2√
, and m = ((16B+1)B)2 T log γ, where
T


+B)2 )
,
e
. This choice of m implies
γ = max ((16B+1)ηT
η2
that m > ((16B + 1)ηT )2 , and hence the third term in
Eq. 16 is upper bounded by T .
Next we have that m > (3ηt)2 log γ for every t, and by the
2
T)
bound on BT we have that γ > (B+B
. Taken together
η2
with Lemma 2 we have that:
T
(BT + B)2 X
Pt (f ∗ ) ≤ ηT.
η
t=1

(18)

The above bounds imply that:
(1 − 2η)E [Rt (f ∗ )] ≤

B2
+ 2ηT + ηT + ηT
η

sampled from a standard Gaussian. We furthermore clip
negative values to zero, in order to make the data sparser
and more challenging for feature sampling. Next a weight
vector a ∈ RD is chosen as a random sparse linear combination of the training points. This is done in order for the
true function to be in the corresponding RKHS. Finally, the
training set is labeled using yi = a · xi .
During training we do not assume that the algorithms have
access to x. Rather they can uniformly sample coordinates from it, which mimics our setting of random features.
For the experiment we take D = 550, 600, . . . , 800 and
T = 200. All algorithms perform one pass over the data,
to emulate the online regret setting. The results shown in
Figure 1 show that our method indeed achieves a lower loss
while working with the same feature budget.
240

220

Finally by choice of η, and dividing both sides by (1 − 2η)
we obtain the desired result.

200

Fixed-Random
Doubly-Stoch
Shrink-Grad

180

In this section we provide a toy experiment to compare
our Shrinking Gradient algorithm to other random feature based methods. In particular, we consider the following three algorithms: Fixed-Random: Sample a set of
r features w1 , . . . , wr and evaluate these on all the train
and test points. Namely, all x points will be evaluated
on the same features. This is the standard random features approach proposed in Rahimi & Recht (2007; 2009).
Doubly Stochastic Gradient Descent (Dai et al., 2014):
Here each training point x samples k features w1 , . . . , wk .
These features will from that point on be used for evaluating dot products with x. Thus, different x points will use
different features. Shrinking Gradient: This is the approach proposed here in Section 3. Namely, each training
point x samples m features in order to calculate the dot
product with the current regression function.
In comparing the algorithms we choose r, k, m so that the
same overall number of features is calculated. For all methods we explored different initial step sizes and schedules
for changing the step size.
The key question in comparing the three algorithms is how
well they use a given budget of random features. To explore this we perform an experiments to simulate the high
dimensional feature case. We consider vectors x ∈ RD ,
where a random feature w corresponds to a uniform choice
of coordinate w in x. We work in the regime where D is
large in the sense that D > T , where T is the size of the
training data. Thus random sampling of T features will
not reveal all coordinates of x. The training set is generated as follows. First, a training set x1 , . . . , xT ∈ RD is

160

loss

6. Experiments

140

120

100

80

60
550

600

650

700

750

800

input dimension

Figure 1. Comparison of three random feature methods. See Section 6 for details.

7. Discussion
We presented a new online algorithm that employs kernels
implicitly but avoids the kernel trick assumption. Namely,
the algorithm can be invoked even when one has access to
only estimations of the scalar product. The problem was
motivated by kernels resulting from neural nets, but it can
of course be applied to any scalar product of the form we
described. As an example of an interesting extension, consider a setting where a learner can observe an unbiased estimate of a coordinate in a kernel matrix, or alternatively the
scalar product between any two observations. Our results
imply that in this setting the above rates are applicable, and
at least for the square loss, having no access to the true
values in the kernel matrix is not necessarily prohibitive
during training.
The results show that with sample size T we can achieve
error of O( √BT ). As demonstrated in Shamir (2015) these

Learning Infinite Layer Networks Without the Kernel Trick

rates are optimal, even when the scalar product is computable. To achieve this rate our algorithm needs to perform Õ(B 4 T 2 ) scalar product estimations. When the
scalar product can be computed, existing kernelized algorithms need to observe a fixed proportion of the kernel matrix, hence they observe order of Ω(T 2 ) scalar products.
In Cesa-Bianchi et al. (2015) it was shown that when the
scalar product can be computed exactly, one would need
access to at least Ω(T ) entries to the kernel matrix. It is
still an open problem whether one has to access Ω(T 2 ) entries when the kernel can be computed exactly. However,
as we show here, for fixed B even if the kernel can only be
estimated Õ(T 2 ) estimations are enough. It would be interesting to further investigate and improve the performance
of our algorithm in terms of the norm bound B.
To summarize, we have shown that the kernel trick is not
strictly necessary in terms of sample complexity. Instead,
simply sampling random features via our proposed algorithm results in a similar sample complexity. Recent empirical results by Zhang et al. (2016) show that using a large
number of random features and regression comes close to
the performance of the first successful multilayer CNNs
(Krizhevsky et al., 2012) on CIFAR-10. Although deep
learning architectures still substantially outperform random
features, it is conceivable that with the right choice of
random features, and scalable learning algorithms like we
present here, considerable improvement in performance is
possible.

A. Estimation Concentration Bounds
In this section we provide concentration bounds for the estimation procedure in Algorithm 2.
T
Lemma 4. Run
P Algorithm 2 with α and, {xi }i=1 , x, and
m. Let f =
αi Φ(xi ). Assume that |ψ(x; w)| < 1 for
all w and x. Let E be the output of Algorithm 2. Then E
is an unbiased estimator for hf, Φ(x)i and:


m2
(19)
P [|E − hf, Φ(x)i| > ] ≤ exp −
kαk21
Proof. Consider the random variables kαk1 E (k) (where
E (k) is as defined in Algorithm 2)  and note that
(k)
they
=
P are IID. One can show that E kαk1 E
αi E [ψ(xi ; w)ψ(x;w)] = hf, Φ(x)i. By the bound on
ψ(x; w) we have that kαk1 E (k)  < kαk1 with probability
P (k)
1
1. Since E = m
E the result follows directly from
Hoeffding’s inequality.
Next, we bound the α(t) coeffcients and obtain a concentration bound for the estimated dot product Et .
Lemma 5. The α(t) obtained in Algorithm 1 satisfies:
kα(t) k1 ≤ (16B + 1)ηt.

As a corollary of this and Lemma 4 we have that the function ft satisfies:


2 m
P [|Et − hft , Φ(xt )i| > ] ≤ exp −
((16B + 1)ηt)2
(20)
Proof. We prove the statement by induction. We separate
into two cases, depending on whether the shrinkage step
was performed or not.
If |Et | ≥ 16B the algorithm sets α(t+1) = 14 α(t) , and:
kα(t+1) k1 =

1 (t)
kα k1 ≤ (16B + 1)η(t + 1)
4

If |Et | < 16B the gradient update is performed. Since
|yt | ≤ 1 we have that |Et − yt | < 16B + 1 and:
kα(t+1) k1 ≤ kα(t) k1 + η|Et − yi | ≤ (16B + 1)η(t + 1).

B. Proofs of Lemmas
B.1. Proof of Lemma 1
First, by convexity we have that
2(`t (ft ) − `t (f ∗ )) ≤ 2 h∇t , ft − f ∗ i .

(21)

Next we upper bound h∇t , ft − f ∗ i. Denote by E the event
kft+1 − f ∗ k > kfˆt+1 − f ∗ k. Note that:
h
i


E kft+1 − f ∗ k2 ≤ E kfˆt+1 − f ∗ k2 +
 

E kft+1 − f ∗ k2 E · Pt+1 (f ∗ )
h
i
≤ E kfˆt+1 − f ∗ k2 + (B + BT )2 Pt+1 (f ∗ )
¯ t , summing over t and using
Plugging in fˆt+1
 = 2ft − η ∇


 
¯
Eq. 21 and E k∇t k = E k∇t k2 + V ∇¯t , we obtain
the desired result.
B.2. Proof for Lemma 2
To prove the bound in the lemma, we first bound the event
Pt (f ∗ ) w.r.t to two possible events:
Lemma 6. Consider the setting as in Lemma 2. Run Algorithm 1 and for each t consider the following two events:
• E1t : |Et | > 16B and |Et | >

1
4η kft k.

• E2t : |Et | > 16B and kft k < 8B.
For every kf ∗ k < B we have that Pt (f ∗ ) < P [E1t ∪ E2t ].

Learning Infinite Layer Networks Without the Kernel Trick

Proof. Denote the event |Et | > 16B by E0t . Note that if E0t
does not happen, then ft = fˆt . Hence trivially
i
h
Pt (f ∗ ) = P kft − f ∗ k > kfˆt − f ∗ k ∧ E0t
We will assume
(3) kft k > 8B.

1
that: (1) |Et | > 16B., (2) |Et | < 4η
kft k.,
∗
ˆ
We then show kft+1 −f k ≤ kft+1 −f ∗ k.

In other words, we will show that if E0t happens and kft+1 −
f ∗ k > kfˆt+1 − f ∗ k, then either E2t or E1t happened. This
will conclude the proof.
Fix t, note that since |ψ(x; w)| < 1 we have that kΦ(x)k <
1. We then have:
kfˆt+1 k

kft − η(Et − y)Φ(xt )k
(22)
3
≥ kft k − η|Et | − η ≥ kft k − η
4
=

where the last inequality is due to assumption (2) above.
We therefore have the following for every kf ∗ k < B:
kfˆt+1 − f ∗ k ≥

3
kft k − η − B
4

On the other hand, if ft+1 6= fˆt+1 then by construction of
the algorithm ft+1 = 41 ft :
kft+1 − f ∗ k ≤ kft+1 k + kf ∗ k ≤

kft k
+ B.
4

Next note that η < 2B and assumption (3) states kft k >
8B. Therefore: 12 kft k > 4B > η + 2B, and:
kfˆt+1 − f ∗ k

≥
=
≥

3
kft k − η − B
4


1
1
kft k +
kft k − η − 2B + B
4
2
1
kft k + B ≥ kft+1 − f ∗ k
4

Next we upper bound P [E1t ∪ E2t ]. In what follows the superscript t is dropped.
A bound for P [E1 ∩ E2c ]: Assume that
|Et − hft , Φ(xt )i| < (

1
− 1)8B.
4η

We assume T is sufficiently large and η < 18 . We have
1
4η − 1 > 1. Since we assume E2 did not happen we must
1
have kft k > 8B and |Et − hft , Φ(xt )i| < ( 4η
− 1)kf k,
and therefore:
Et − kf k < |Et − hft , Φ(xt )i| < (

1
− 1)kf k.
4η

1
Which implies Et < 4η
kf k, and we get that E1 did not
happen. We conclude that if E1 and not E2 then:

|Et − hft , Φ(xt )i| ≥ (

1
− 1)8B.
4η

1
Since 4η
− 1 > 1 we have that: |Et − hft , Φ(xt )i| ≥ 8B,
leading to:

P [E1 ∩ E2c ] ≤ P [|Et − hft , Φ(xt )i| ≥ 8B] .

(23)

A bound for P [E2 ]: If |Et | > 16B and kft k < 8B then
by normalization of Φ(xt ) we have that hft , Φ(xt )i < 8B
and trivially we have that |Et − hft , Φ(xt )i| ≥ 8B, and
therefore:
P [E2 ] ≤ P [|Et − hft , Φ(xt )i| ≥ 8B] .

(24)

Taking Eq. 23 and Eq. 24 we have that
P [E2 ∪ E1 ] ≤ 2P [|Et − hft , Φ(xt )i| ≥ 8B] .

(25)

By Lemma 5 we have that:
P (|Et − hft , Φ(xt )i|) > 8B) <


m
m(8B)2
)
<
exp
−
exp(−
((16B + 1)ηt)2
(3ηt)2
Taking the above upper bounds together with Lemma 6 we
can prove Lemma 2.
B.3. Proof of Lemma 3
Begin by noting that since kΦ(x)k
  < 1,it follows from
 the
¯ that V ∇
¯ t = E k∇
¯ t − ∇t k2 and
definitions of ∇, ∇
therefore
h
i
 
¯ t ≤ E (Et − hft , Φ(xt )i)2 = V [Et ]
V ∇
By construction (see Algorithm 2) we have that:
i
1 h
V [Et ] = V kα(t) k21 ψ(xi ; w)ψ(xt ; w)
m
where the index i is sampled as in Algorithm 2, and
ψ(xi ; w)ψ(xt ; w) is bounded by 1. By Lemma 5 we have
that
((16B + 1)ηt)2
V [Et ] ≤
.
m
 
¯ t . Additionally,
This provides the required bound on V ∇
we have that
k∇t k2 = (hft , Φ(xt )i − yt )2 kΦ(xt )k2 ≤ 2`t (ft )
and the result follows by taking expectation.
Acknowledgements The authors would like to thank
Tomer Koren for helpful discussions. Roi Livni was supported by funding from Eric and Wendy Schmidt Fund
for Strategic Innovation. This work was supported by
the Blavatnik Computer Science Research Fund, the Intel
Collaborative Research Institute for Computational Intelligence (ICRI-CI), and an ISF Centers of Excellence grant.

Learning Infinite Layer Networks Without the Kernel Trick

References
Bach, Francis. Breaking the curse of dimensionality with convex
neural networks. arXiv preprint arXiv:1412.8690, 2014.
Bach, Francis. On the equivalence between kernel quadrature rules and random feature expansions. arXiv preprint
arXiv:1502.06800, 2015.
Bo, Liefeng, Ren, Xiaofeng, and Fox, Dieter. Kernel descriptors
for visual recognition. In Advances in neural information processing systems, pp. 244–252, 2010.
Bo, Liefeng, Lai, Kevin, Ren, Xiaofeng, and Fox, Dieter. Object
recognition with hierarchical kernel descriptors. In Computer
Vision and Pattern Recognition (CVPR), 2011 IEEE Conference on, pp. 1729–1736. IEEE, 2011.
Bouvrie, Jake, Rosasco, Lorenzo, and Poggio, Tomaso. On invariance in hierarchical models. In Advances in Neural Information Processing Systems, pp. 162–170, 2009.
Cesa-Bianchi, Nicolo, Shalev-Shwartz, Shai, and Shamir, Ohad.
Efficient learning with partially observed attributes. The Journal of Machine Learning Research, 12:2857–2878, 2011a.
Cesa-Bianchi, Nicolo, Shalev-Shwartz, Shai, and Shamir, Ohad.
Online learning of noisy data. Information Theory, IEEE
Transactions on, 57(12):7907–7931, 2011b.
Cesa-Bianchi, Nicolò, Mansour, Yishay, and Shamir, Ohad. On
the complexity of learning with kernels. In Proceedings of The
28th Conference on Learning Theory, pp. 297–325, 2015.
Cho, Youngmin and Saul, Lawrence K. Kernel methods for deep
learning. In Advances in neural information processing systems, pp. 342–350, 2009.
Cortes, Corinna and Vapnik, Vladimir. Support-vector networks.
Machine learning, 20(3):273–297, 1995.
Dai, Bo, Xie, Bo, He, Niao, Liang, Yingyu, Raj, Anant, Balcan,
Maria-Florina F, and Song, Le. Scalable kernel methods via
doubly stochastic gradients. In Advances in Neural Information Processing Systems, pp. 3041–3049, 2014.
Daniely, Amit, Linial, Nati, and Shalev-Shwartz, Shai. From average case complexity to improper learning complexity. In Proceedings of the 46th Annual ACM Symposium on Theory of
Computing, pp. 441–448. ACM, 2014.
Daniely, Amit, Frostig, Roy, and Singer, Yoram. Toward deeper
understanding of neural networks: The power of initialization
and a dual view on expressivity. In Lee, D. D., Sugiyama, M.,
Luxburg, U. V., Guyon, I., and Garnett, R. (eds.), Advances
in Neural Information Processing Systems 29, pp. 2253–2261.
Curran Associates, Inc., 2016.
Deng, Li, Tur, Gokhan, He, Xiaodong, and Hakkani-Tur, Dilek.
Use of kernel deep convex networks and end-to-end learning
for spoken language understanding. In Spoken Language Technology Workshop (SLT), 2012 IEEE, pp. 210–215. IEEE, 2012.
Hazan, Elad and Koren, Tomer. Linear regression with limited observation. In Proceedings of the 29th International Conference
on Machine Learning (ICML-12), pp. 807–814, 2012.

Hazan, Tamir and Jaakkola, Tommi. Steps toward deep kernel methods from infinite neural networks. arXiv preprint
arXiv:1508.05133, 2015.
Heinemann, Uri, Livni, Roi, Eban, Elad, Elidan, Gal, and Globerson, Amir. Improper deep kernels. In Proceedings of the 19th
International Conference on Artificial Intelligence and Statistics, pp. 1159–1167, 2016.
Hornik, Kurt. Some new results on neural network approximation. Neural Networks, 6(8):1069–1072, 1993.
Kar, Purushottam and Karnick, Harish. Random feature maps for
dot product kernels. In International Conference on Artificial
Intelligence and Statistics, pp. 583–591, 2012.
Kivinen, Jyrki, Smola, Alexander J, and Williamson, Robert C.
Online learning with kernels. IEEE transactions on signal processing, 52(8):2165–2176, 2004.
Klivans, Adam R and Sherstov, Alexander A. Cryptographic
hardness for learning intersections of halfspaces. In Foundations of Computer Science, 2006. FOCS’06. 47th Annual IEEE
Symposium on, pp. 553–562. IEEE, 2006.
Krizhevsky, Alex, Sutskever, Ilya, and Hinton, Geoffrey E. Imagenet classification with deep convolutional neural networks.
In Advances in neural information processing systems, pp.
1097–1105, 2012.
Livni, Roi, Shalev-Shwartz, Shai, and Shamir, Ohad. On the computational efficiency of training neural networks. In Advances
in Neural Information Processing Systems, pp. 855–863, 2014.
Mairal, Julien, Koniusz, Piotr, Harchaoui, Zaid, and Schmid,
Cordelia. Convolutional kernel networks. In Advances in Neural Information Processing Systems, pp. 2627–2635, 2014.
Minsky, Marvin and Papert, Seymour. Perceptrons: an introduction to computational geometry (expanded edition), 1988.
Rahimi, Ali and Recht, Benjamin. Random features for largescale kernel machines. In Advances in neural information processing systems, pp. 1177–1184, 2007.
Rahimi, Ali and Recht, Benjamin. Weighted sums of random
kitchen sinks: Replacing minimization with randomization in
learning. In Advances in neural information processing systems, pp. 1313–1320, 2009.
Shalev-Shwartz, Shai. Online learning and online convex optimization. Foundations and Trends in Machine Learning, 4(2):
107–194, 2011.
Shamir, Ohad. The sample complexity of learning linear predictors with the squared loss. Journal of Machine Learning Research, 16(Dec):3475–3486, 2015.
Srebro, Nathan, Sridharan, Karthik, and Tewari, Ambuj. Smoothness, low noise and fast rates. In Advances in neural information processing systems, pp. 2199–2207, 2010.
Sridharan, Karthik, Shalev-Shwartz, Shai, and Srebro, Nathan.
Fast rates for regularized objectives. In Advances in Neural
Information Processing Systems, pp. 1545–1552, 2009.
Suykens, Johan AK and Vandewalle, Joos. Least squares support vector machine classifiers. Neural processing letters, 9
(3):293–300, 1999.

Learning Infinite Layer Networks Without the Kernel Trick
Suykens, Johan AK, Van Gestel, Tony, and De Brabanter, Jos.
Least squares support vector machines. World Scientific, 2002.
Williams, Christopher. Computing with infinite networks. Advances in neural information processing systems, pp. 295–301,
1997.
Zhang, Chiyuan, Bengio, Samy, Hardt, Moritz, Recht, Benjamin,
and Vinyals, Oriol. Understanding deep learning requires
rethinking generalization. arXiv preprint arXiv:1611.03530,
2016.
Zhang, Tong. Solving large scale linear prediction problems using
stochastic gradient descent algorithms. In Proceedings of the
twenty-first international conference on Machine learning, pp.
116. ACM, 2004.
Zinkevich, Martin. Online convex programming and generalized
infinitesimal gradient ascent. In Machine Learning, Proceedings of the Twentieth International Conference, pp. 928–936,
2003.

