Stochastic Variance Reduction Methods for Policy Evaluation
Simon S. Du 1 Jianshu Chen 2 Lihong Li 2 Lin Xiao 2 Dengyong Zhou 2

Abstract
Policy evaluation is concerned with estimating
the value function that predicts long-term values of states under a given policy. It is a crucial step in many reinforcement-learning algorithms. In this paper, we focus on policy evaluation with linear function approximation over
a fixed dataset. We first transform the empirical policy evaluation problem into a (quadratic)
convex-concave saddle-point problem, and then
present a primal-dual batch gradient method, as
well as two stochastic variance reduction methods for solving the problem. These algorithms
scale linearly in both sample size and feature dimension. Moreover, they achieve linear convergence even when the saddle-point problem has
only strong concavity in the dual variables but no
strong convexity in the primal variables. Numerical experiments on benchmark problems demonstrate the effectiveness of our methods.

1 Introduction
Reinforcement learning (RL) is a powerful learning
paradigm for sequential decision making (see, e.g., Bertsekas & Tsitsiklis, 1995; Sutton & Barto, 1998). An RL
agent interacts with the environment by repeatedly observing the current state, taking an action according to a certain
policy, receiving a reward signal and transitioning to a next
state. A policy specifies which action to take given the current state. Policy evaluation estimates a value function that
predicts expected cumulative reward the agent would receive by following a fixed policy starting at a certain state.
In addition to quantifying long-term values of states, which
can be of interest on its own, value functions also provide
1

Machine Learning Department, Carnegie Mellon University, Pittsburgh, Pennsylvania 15213, USA. 2 Microsoft Research, Redmond, Washington 98052, USA.. Correspondence
to: Simon S. Du <ssdu@cs.cmu.edu>, Jianshu Chen <jianshuc@microsoft.com>, Lihong Li <lihongli@microsoft.com>,
Lin Xiao <lin.xiao@microsoft.com>, Dengyong Zhou <denzho@microsoft.com>.
Proceedings of the 34 th International Conference on Machine
Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017
by the author(s).

important information for the agent to optimize its policy.
For example, policy-iteration algorithms iterate between
policy-evaluation steps and policy-improvement steps, until a (near-)optimal policy is found (Bertsekas & Tsitsiklis,
1995; Lagoudakis & Parr, 2003). Therefore, estimating the
value function efficiently and accurately is essential in RL.
There has been substantial work on policy evaluation, with
temporal-difference (TD) methods being perhaps the most
popular. These methods use the Bellman equation to bootstrap the estimation process. Different cost functions are
formulated to exploit this idea, leading to different policy
evaluation algorithms; see Dann et al. (2014) for a comprehensive survey. In this paper, we study policy evaluation
by minimizing the mean squared projected Bellman error
(MSPBE) with linear approximation of the value function.
We focus on the batch setting where a fixed, finite dataset
is given. This fixed-data setting is not only important in itself (Lange et al., 2011), but also an important component
in other RL methods such as experience replay (Lin, 1992).
The finite-data regime makes it possible to solve policy
evaluation more efficiently with recently developed fast optimization methods based on stochastic variance reduction,
such as SVRG (Johnson & Zhang, 2013) and SAGA (Defazio et al., 2014). For minimizing strongly convex functions with a finite-sum structure, such methods enjoy the
same low computational cost per iteration as the classical stochastic gradient method, but also achieve fast, linear
convergence rates (i.e., exponential decay of the optimality
gap in the objective). However, they cannot be applied directly to minimize the MSPBE, whose objective does not
have the finite-sum structure. In this paper, we overcome
this obstacle by transforming the empirical MSPBE problem to an equivalent convex-concave saddle-point problem
that possesses the desired finite-sum structure.
In the saddle-point problem, we consider the model parameters as the primal variables, which are coupled with the
dual variables through a bilinear term. Moreover, without
an `2 -regularization on the model parameters, the objective
is only strongly concave in the dual variables, but not in the
primal variables. We propose a primal-dual batch gradient
method, as well as two stochastic variance-reduction methods based on SVRG and SAGA, respectively. Surprisingly,
we show that when the coupling matrix is full rank, these
algorithms achieve linear convergence in both the primal

Stochastic Variance Reduction Methods for Policy Evaluation

and dual spaces, despite the lack of strong convexity of the
objective in the primal variables. Our results also extend to
off-policy learning and TD with eligibility traces (Sutton &
Barto, 1998; Precup et al., 2001).
We note that Balamurugan & Bach (2016) have extended
both SVRG and SAGA to solve convex-concave saddlepoint problems with linear-convergence guarantees. The
main difference between our results and theirs are
• Linear convergence in Balamurugan & Bach (2016)
relies on the assumption that the objective is strongly
convex in the primal variables and strongly concave
in the dual. Our results show, somewhat surprisingly,
that only one of them is necessary if the primal-dual
coupling is bilinear and the coupling matrix is full
rank. In fact, we are not aware of similar previous results even for the primal-dual batch gradient method,
which we show in this paper.
• Even if a strongly convex regularization on the primal
variables is introduced to the MSPBE objective, the
algorithms in Balamurugan & Bach (2016) cannot be
applied efficiently. Their algorithms require that the
proximal mappings of the strongly convex and concave regularization functions be computed efficiently.
In our saddle-point formulation, the strong concavity
of the dual variables comes from a quadratic function defined by the feature covariance matrix, which
cannot be inverted efficiently and makes the proximal
mapping costly to compute. Instead, our algorithms
only use its (stochastic) gradients and hence are much
more efficient.
We compare various gradient based algorithms on a Random MDP and Mountain Car data sets. The experiments
demonstrate the effectiveness of our proposed methods.

2 Preliminaries
We consider a Markov Decision Process (MDP) (Puterman,
a
2005) described by (S, A, Pss
0 , R, ), where S is the set of
a
states, A the set of actions, Pss
0 the transition probability
0
from state s to state s after taking action a, R (s, a) the reward received after taking action a in state s, and 2 [0, 1)
a discount factor. The goal of an agent is to find an actionselection policy ⇡, so that the long-term reward under this
policy is maximized. For ease of exposition, we assume S
is finite, but none of our results relies on this assumption.
A key step in many algorithms in RL is to estimate the
value
of a given policy ⇡, defined as V ⇡ (s) ,
P1function
t
E[ t=0 R(st , at )|s0 = s, ⇡]. Let V ⇡ denote a vector
constructed by stacking the values of V ⇡ (1), . . . , V ⇡ (|S|)
on top of each other. Then V ⇡ is the unique fixed point of
the Bellman operator T ⇡ :

where R⇡ is the expected reward vector under policy ⇡,
defined elementwise as R⇡ (s) = E⇡(a|s) R(s, a); and P ⇡
is the transition matrix induced by the policy applying ⇡,
a
defined entrywise as P ⇡ (s, s0 ) = E⇡(a|s) Pss
0.
2.1

Mean squared projected Bellman error (MSPBE)

One approach to scale up when the state space size |S| is
large or infinite is to use a linear approximation for V ⇡ .
Formally, we use a feature map
: S ! Rd and ap⇡
b
proximate the value function by V (s) = (s)T ✓, where
✓ 2 Rd is the model parameter to be estimated. Here, we
want to find ✓ that minimizes the mean squared projected
Bellman error, or MSPBE:
MSPBE (✓) ,

V

⇡

=T V

⇡

,R + P V ,
⇡

⇡

⇡

(1)

⇧T ⇡ Vb ⇡ k2⌅ ,

(2)

where ⌅ is a diagonal matrix with diagonal elements being the stationary distribution over S induced by the policy ⇡, and ⇧ is the weighted projection matrix onto the
linear space spanned by (1), . . . , (|S|), that is,
⇧=

(

T

⌅ )

1

T

(3)

⌅

where , [ T (1), . . . , T (|S|)] is the matrix obtained by
stacking the feature vectors row by row. Substituting (3)
and (1) into (2), we obtain (see, e.g., Dann et al., 2014)
MSPBE(✓) =

1
k
2

T

⌅(Vb ⇡

T ⇡ Vb ⇡ )k2(

T⌅

)

1

.

We can further rewrite the above expression for MSPBE as
a standard weighted least-squares problem:
MSPBE(✓) =

1
kA✓
2

bk2C

1

,

with properly defined A, b and C, described as follows.
Suppose the MDP under policy ⇡ settles at its stationary
distribution and generates an infinite transition sequence
1
{(st , at , rt , st+1 )}t=1 , where st is the current state, at is
the action, rt is the reward, and st+1 is the next state. Then
with the definitions t , (st ) and 0t , (st+1 ), we have
A = E[ t (

t

0 T
t ) ],

b = E[ t rt ], C = E[

T
t t ],

(4)

where E[·] are with respect to the stationary distribution.
Many TD solutions converge to a minimizer of MSPBE in
the limit (Tsitsiklis & Van Roy, 1997; Dann et al., 2014).
2.2

Empirical MSPBE

In practice, quantities in (4) are often unknown, and we
only have access to a finite dataset with n transitions D =
n
{(st , at , rt , st+1 )}t=1 . By replacing the unknown statistics
with their finite-sample estimates, we obtain the Empirical
MSPBE, or EM-MSPBE. Specifically, let
n

⇡

1 b⇡
kV
2

X
b, 1
A
At ,
n t=1

n

X
bb , 1
bt ,
n t=1

n

X
b, 1
C
Ct ,
n t=1

(5)

Stochastic Variance Reduction Methods for Policy Evaluation

where for t = 1, . . . , n,
At ,

t( t

bt , rt t ,

0 T
t) ,

Ct ,

T
t t .

(6)

EM-MSPBE with an optional `2 -regularization is given by:
EM-MSPBE (✓) =
where ⇢

1 b
kA✓
2

bbk2
b
C

1

⇢
+ k✓k2 ,
2

(7)

0 is a regularization factor.

Observe that (7) is a (regularized) weighted least squares
b is invertible, its optimal solution is
problem. Assuming C
b> C
b
✓ ? = (A

1

b + ⇢I)
A

1

b> C
b
A

1b

b.

(8)

Computing ✓? directly requires O(nd2 ) operations to form
b bb and C,
b and then O(d3 ) operations to
the matrices A,
complete the calculation. This method, known as leastsquares temporal difference or LSTD (Bradtke & Barto,
1996; Boyan, 2002), can be very expensive when n and
d are large. One can also skip forming the matrices explicitly and compute ✓? using n recusive rank-one updates
(Nedić & Bertsekas, 2003). Since each rank-one update
costs O(d2 ), the total cost is O(nd2 ).
In the sequel, we develop efficient algorithms to minimize
EM-MSPBE by using stochastic variance reduction methods, which samples one ( t , 0t ) per update without preb bb and C.
b These algorithms not only maintain
computing A,
a low O(d) per-iteration computation cost, but also attain
fast linear convergence rates with a log(1/✏) dependence
on the desired accuracy ✏.

3 Saddle-Point Formulation of EM-MSPBE
Our algorithms (in Section 5) are based on the stochastic
variance reduction techniques developed for minimizing a
finite sum of convex functions, more specifically, SVRG
(Johnson & Zhang, 2013) and SAGA (Defazio et al., 2014).
They deal with problems of the form
min

x2Rd

⇢

n

f (x) ,

1X
fi (x) ,
n i=1

(9)

where each fi is convex. We immediately notice that the
EM-MSPBE in (7) cannot be put into such a form, even
b bb and C
b have the finite-sum structhough the matrices A,
ture given in (5). Thus, extending variance reduction techniques to EM-MSPBE minimization is not straightforward.
Nevertheless, we will show that the minimizing the EMMSPBE is equivalent to solving a convex-concave saddlepoint problem which actually possesses the desired finitesum structure. To proceed, we resort to the machinery of
conjugate functions (e.g. Rockafellar, 1970, Section 12).
For a function f : Rd ! R, its conjugate function f ? :

Rd ! R is defined as f ? (y) , supx (y T x f (x)). Note
that the conjugate function of 12 kxk2Cb is 12 kyk2Cb 1 , i.e.,
1
kyk2Cb
2

1

⇣
= max y T x
x

⌘
1
kxk2Cb .
2

With this relation, we can rewrite EM-MSPBE in (7) as
⇣
⌘ ⇢
1
b
max wT (bb A✓)
kwk2Cb + k✓k2 ,
w
2
2

so that minimizing EM-MSPBE is equivalent to solving
⇢
n
1X
min max L(✓, w) =
Lt (✓, w) ,
(10)
n t=1
✓2Rd w2Rd
where the Lagrangian, defined as
⇣1
⇢
b
L(✓, w) , k✓k2 wT A✓
kwk2Cb
2
2

may be decomposed using (5), with
⇣1
⇢
Lt (✓, w) , k✓k2 wT At ✓
kwk2Ct
2
2

⌘
wT bb , (11)
⌘
w T bt .

Therefore, minimizing the EM-MSPBE is equivalent to
solving the saddle-point problem (10), which is convex in
the primal variable ✓ and concave in the dual variable w.
Moreover, it has a finite-sum structure similar to (9).
Liu et al. (2015) and Valcarcel Macua et al. (2015) independently showed that the GTD2 algorithm (Sutton et al.,
2009b) is indeed a stochastic gradient method for solving
the saddle-point problem (10), although they obtained the
saddle-point formulation with different derivations. More
recently, Dai et al. (2016) used the conjugate function approach to obtain saddle-point formulations for a more general class of problems and derived primal-dual stochastic
gradient algorithms for solving them. However, these algorithms have sublinear convergence rates, which leaves
much room to improve when applied to problems with finite datasets. Recently, Lian et al. (2017) developed SVRG
methods for a general finite-sum composition optimization
that achieve linear convergence rate. Different from our
methods, their stochastic gradients are biased and they have
worse dependency on the condition numbers (3 and 4 ).
The fast linear convergence of our algorithms presented in
Sections 4 and 5 requires the following assumption:
b has full rank, C
b is strictly positive defiAssumption 1. A
nite, and the feature vector t is uniformly bounded.

Under mild regularity conditions (e.g., Wasserman, 2013,
b and C
b converge in probability to A
Chapter 5), we have A
and C defined in (4), respectively. Thus, if the true statistics
A is non-singular and C is positive definite, and we have
enough training samples, these assumptions are usually satisfied. They have been widely used in previous works on
gradient-based algorithms (e.g., Sutton et al., 2009a;b).

Stochastic Variance Reduction Methods for Policy Evaluation

A direct consequence of Assumption 1 is that ✓? in (8) is
the unique minimizer of the EM-MSPBE in (7), even without any strongly convex regularization on ✓ (i.e., even if
⇢ = 0). However, if ⇢ = 0, then the Lagrangian L(✓, w) is
only strongly concave in w, but not strongly convex in ✓. In
this case, we will show that non-singularity of the coupling
b can “pass” an implicit strong convexity on ✓,
matrix A
which is exploited by our algorithms to obtain linear convergence in both the primal and dual spaces.

4 A Primal-Dual Batch Gradient Method
Before diving into the stochastic variance reduction algorithms, we first present Algorithm 1, which is a primal-dual
batch gradient (PDBG) algorithm for solving the saddlepoint problem (10). In Step 2, the vector B(✓, w) is obtained by stacking the primal and negative dual gradients:
"
#

bT w
⇢✓ A
r✓ L(✓, w)
B (✓, w) ,
= b
. (12)
b
rw L(✓, w)
A✓ bb + Cw
Some notation is needed in order to characterize the convergence rate of Algorithm 1. For any symmetric and positive definite matrix S, let max (S) and min (S) denote its
maximum and minimum eigenvalues respectively, and define its condition number to be (S) , max (S)/ min (S).
We also define L⇢ and µ⇢ for any ⇢ 0:
bT C
b 1 A),
b
+A
bT C
b 1 A).
b
µ⇢ , min (⇢I + A

L⇢ ,

max (⇢I

(13)
(14)

By Assumption 1, we have L⇢
µ⇢ > 0. The following
theorem is proved in Appendix B.
Theorem 1. Suppose Assumption 1 holds and let (✓? , w? )
be the (unique) solution of (10). If the step sizes are chosen
8
as ✓ = 9L 1(C)
b and w = 9
b , then the number
(C)
⇢

max

of iterations of Algorithm 1 to achieve k✓ ✓? k2 + kw
w? k2  ✏2 is upper bounded by
✓ ⇣
⌘
⇣ 1 ⌘◆
T b 1 b
b
b
O  ⇢I + A C A · (C) · log
.
(15)
✏

We assigned specific values to the step sizes ✓ and w
for clarity. In general, we can use similar step sizes while
8L⇢
keeping their ratio roughly constant as w✓ ⇡
b ; see
min (C)
Appendices A and B for more details. In practice, one can
use a parameter search on a small subset of data to find
reasonable step sizes. It is an interesting open problem how
to automatically select and adjust step sizes.
Note that the linear rate is determined by two parts: (i)
the strongly convex regularization parameter ⇢, and (ii) the
bT C
b 1 A.
b The second part could
positive definiteness of A
be interpreted as transferring strong concavity in dual varib For
ables via the full-rank bi-linear coupling matrix A.

Algorithm 1 PDBG for Policy Evaluation
Inputs: initial point (✓, w), step sizes ✓ and w , and
number of epochs M .
1: for i = 1 to M do



✓
✓
0
✓
2:
B(✓, w)
w
w
0
w
where B(✓, w) is computed according to (12).
3: end for
this reason, even if the saddle-point problem (10) has only
strong concavity in dual variables (when ⇢ = 0), the algorithm still enjoys a linear convergence rate.
Moreover, even if ⇢ > 0, it will be inefficient to solve problem (10) using primal-dual algorithms based on proximal
mappings of the strongly convex and concave terms (e.g.,
Chambolle & Pock, 2011; Balamurugan & Bach, 2016).
The reason is that, in (10), the strong concavity of the Lagrangian with respect to the dual lies in the quadratic function (1/2)kwkCb , whose proximal mapping cannot be computed efficiently. In contrast, the PDBG algorithm only
needs its gradients.
b bb and C,
b which costs
If we pre-compute and store A,
O(nd2 ) operations, then computing the gradient operator
B(✓, w) in (12) during each iteration of PDBG costs O(d2 )
operations. Alternatively, if we do not want to store these
d ⇥ d matrices (especially if d is large), then we can compute B(✓, w) P
as finite sums on the fly. More specifically,
n
B(✓, w) = n1 t=1 Bt (✓, w), where for each t = 1, . . . , n,

⇢✓ At w
Bt (✓, w) =
.
(16)
At ✓ b t + C t w
Since At , bt and Ct are all rank-one matrices, as given
in (6), computing each Bt (✓, w) only requires O(d) operations. Therefore, computing B(✓, w) costs O(nd) operations as it averages Bt (✓, w) over n samples.

5

Stochastic Variance Reduction Methods

If we replace B(✓, w) in Algorithm 1 (line 2) by the
stochastic gradient Bt (✓, w) in (16), then we recover the
GTD2 algorithm of Sutton et al. (2009b), applied to a fixed
dataset, possibly with multiple passes. It has a low periteration cost but a slow, sublinear convergence rate. In
this section, we provide two stochastic variance reduction
methods and show they achieve fast linear convergence.
5.1

SVRG for policy evaluation

Algorithm 2 is adapted from the stochastic variance reduction gradient (SVRG) method (Johnson & Zhang, 2013).
It uses two layers of loops and maintains two sets of pa˜ w̃) and (✓, w). In the outer loop, the algorithm
rameters (✓,
˜ w̃) using (✓,
˜ w̃), which takes
computes a full gradient B(✓,

Stochastic Variance Reduction Methods for Policy Evaluation

Algorithm 2 SVRG for Policy Evaluation
Inputs: initial point (✓, w), step sizes { ✓ , w }, number of
outer iterations M , and number of inner iterations N .
1: for m = 1 to M do
˜ w̃) = (✓, w) and compute B(✓,
˜ w̃).
2:
Initialize (✓,
3:
for j = 1 to N do
4:
Sample an index tj from {1, · · · , n} and do
˜ w̃).
5:
Compute Btj (✓, w) and Btj (✓,



✓
✓
0
✓
˜ w̃)
6:
Btj (✓, w, ✓,
w
w
0
w
˜ w̃) is given in (17).
where Btj (✓, w, ✓,
7:
end for
8: end for
Algorithm 3 SAGA for Policy Evaluation
Inputs: initial point (✓, w), step sizes ✓ and w , and
number of iterations M .
1: Compute each gt = Bt (✓, w)P
for t = 1, . . . , n.
n
2: Compute B = B(✓, w) = n1
t=1 gt .
3: for m = 1 to M do
4:
Sample an index tm from {1, · · · , n}.
5:
Compute htm = Btm (✓, w).



✓
✓
0
✓
6:
(B + htm gtm ).
w
w
0
w
7:
B
B + n1 (htm
8:
g tm
ht m .
9: end for

g tm )

As Algorithm 3 proceeds, different vectors gt are computed
using different values of ✓ and w (depending on when the
index t was sampled). So in general we need to store all
vectors gt , for t = 1, . . . , n, to facilitate individual updates,
which will cost additional O(nd) storage. However, by exploiting the rank-one structure in (6), we only need to store
0 T
0 T
three scalars ( t
) ✓, ( t
) w, and Tt w, and
form gtm on the fly using O(d) computation. Overall, each
iteration of SAGA costs O(d) operations.
5.3

Theoretical analyses of SVRG and SAGA

In order to study the convergence properties of SVRG and
SAGA for policy evaluation, we introduce a smoothness
parameter LG based on the stochastic gradients Bt (✓, w).
Let = w / ✓ be the ratio between the primal and dual
step-sizes, and define a pair of weighted Euclidean norms
⌦(✓, w) , (k✓k2 +

1

kwk2 )1/2 ,

⌦⇤ (✓, w) , (k✓k2 + kwk2 )1/2 .

O(nd) operations. Afterwards, the algorithm executes the
inner loop, which randomly samples an index tj and updates (✓, w) using variance-reduced stochastic gradient:
˜ w̃) = Bt (✓, w) + B(✓,
˜ w̃)
Btj(✓, w, ✓,
j

computing each component gradients gt = Bt (✓,Pw) at
n
the initial point, and also form their average B = t gt .
At each iteration, the algorithm randomly picks an index
tm 2 {1, . . . , n} and computes the stochastic gradient
htm = Btm (✓, w). Then, it updates (✓, w) using a variance reduced stochastic gradient: B + htm gtm , where
gtm is the previously computed stochastic gradient using
the tm -th sample (associated with certain past values of ✓
and w). Afterwards, it updates the batch gradient estimate
B as B + n1 (htm gtm ) and replaces gtm with htm .

˜ w̃). (17)
Btj(✓,

Here, Btj (✓, w) contains the stochastic gradients at (✓, w)
computed using the random sample with index tj , and
˜ w̃) Bt (✓,
˜ w̃) is a term used to reduce the variance
B(✓,
j
˜ w̃) an unbiased esin Btj (✓, w) while keeping Btj(✓, w, ✓,
timate of B(✓, w).
˜ w̃) is computed once during each iteration of
Since B(✓,
the outer loop with cost O(nd) (as explained at the end of
Section 4), and each of the N iterations of the inner loop
cost O(d) operations, the total computational cost of for
each outer loop is O(nd + N d). We will present the overall
complexity analysis of Algorithm 2 in Section 5.3.
5.2 SAGA for policy evaluation
The second stochastic variance reduction method for policy
evaluation is adapted from SAGA (Defazio et al., 2014);
see Algorithm 3. It uses a single loop, and maintains a single set of parameters (✓, w). Algorithm 3 starts by first

Note that ⌦(·, ·) upper bounds the error in optimizing ✓:
⌦(✓ ✓? , w w? ) k✓ ✓? k. Therefore, any bound on
⌦(✓ ✓? , w w? ) applies automatically to k✓ ✓? k.
Next, we define the parameter LG through its square:
Pn
1
⇤
Bt (✓2 , w2 )
t=1 ⌦ Bt (✓1 , w1 )
2
n
LG ,
sup
⌦(✓1 ✓2 , w1 w2 )2
✓1 ,w1 ,✓2 ,w2

2

.

This definition is similar to the smoothness constant L̄ used
in Balamurugan & Bach (2016) except that we used the
step-size ratio rather than the strong convexity and concavity parameters of the Lagrangian to define ⌦ and ⌦⇤ .1
Substituting the definition of Bt (✓, w) in (16), we have

p T
n
1X T
⇢I
At
L2G =
Gt Gt , where Gt , p
.
At
Ct
n t=1
(18)
With the above definitions, we characterize the convergence of ⌦(✓m ✓? , wm w? ), where (✓? , w? ) is the solution of (10), and (✓m , wm ) is the output of the algorithms
1

Since our saddle-point problem is not necessarily strongly
convex in ✓ (when ⇢ = 0), we could not define ⌦ and ⌦⇤ in the
same way as Balamurugan & Bach (2016).

Stochastic Variance Reduction Methods for Policy Evaluation

after the m-th iteration. For SVRG, it is the m-th outer
iteration in Algorithm 2. The following two theorems are
proved in Appendices C and D, respectively.
Theorem 2 (Convergence rate of SVRG). Suppose Asµ⇢
sumption 1 holds. If we choose ✓ = 48(C)L
b 2 , w =
b 2
512(C)L
G
,
µ2⇢

8L⇢
b ✓,
min (C)

N =
in (13) and (14), then
⇥
E ⌦(✓m

✓? , wm

G

where L⇢ and µ⇢ are defined

⇤ ⇣ 4 ⌘m
w? )2 
⌦(✓0
5

✓? , w0

w? )2 .

⇥

Theorem 3 (Convergence rate of SAGA). Suppose Asµ⇢
sumption 1 holds. If we choose ✓ = 3 82 (C)L
b 2 +nµ2 )
(
⇢
G
8L⇢
and w =
in
Algorithm
3,
then
b ✓
(C)
min

⇤
E ⌦(✓m ✓? , wm w? )2  2(1 ⇢)m ⌦(✓0 ✓? , w0 w? )2 ,
where ⇢
⇥
E ⌦(✓m

µ2⇢

b 2 +nµ2 )
9(82 (C)L
⇢
G

✓? , wm

⇤

Algorithm

SVRG / SAGA
GTD2

The overall computational
cost for reaching E ⌦(✓m
⇤
✓? , wm w? )  ✏ is upper bounded by
✓✓
◆
⇣ 1 ⌘◆
b 2
(C)L
G
O
n+
d log
. (19)
2 (⇢I + A
bT C
b 1 A)
b
✏
min

⇥

Table 1. Complexity of different policy evaluation algorithms. In
the table, d is feature dimension, n is dataset size,  , (⇢I +
bT C
b 1 A);
b G , LG / min (⇢I + A
bT C
b 1 A);
b and 0 is a conA
dition number related to GTD2.

. The total cost to achieve

w? )  ✏ has the same bound in (19).

Similar to our PDBG results in (15), both the SVRG and
SAGA algorithms for policy evaluation enjoy linear convergence even if there is no strong convexity in the saddlepoint problem (10) (i.e., when ⇢ = 0). This is mainly due to
bT C
b 1A
b when C
b is positivethe positive definiteness of A
b is full-rank. In contrast, the linear converdefinite and A
gence of SVRG and SAGA in Balamurugan & Bach (2016)
requires the Lagrangian to be both strongly convex in ✓ and
strongly concave in w.
Moreover, in the policy evaluation problem, the strong concavity with respect to the dual variable w comes from a
weighted quadratic norm (1/2)kwkCb , which does not admit an efficient proximal mapping as required by the proximal versions of SVRG and SAGA in Balamurugan &
Bach (2016). Our algorithms only require computing the
stochastic gradients of this function, which is easy to do
due to its finite sum structure.
Balamurugan & Bach (2016) also proposed accelerated
variants of SVRG and SAGA using the “catalyst” framework of Lin et al. (2015). Such extensions can be done
similarly for the three algorithms presented in this paper,
and we omit the details due to space limit.

6 Comparison of Different Algorithms
This section compares the computation complexities of
several representative policy-evaluation algorithms that
minimize EM-MSPBE, as summarized in Table 1.

PDBG-(I)
PDBG-(II)
LSTD

Total Complexity
⇣
⇣
⌘
⌘
b 2
(C)
G
O nd · 1 +
· log 1/✏
n
O (d · 0 /✏)
⇣
⌘
b · log(1/✏)
O nd · (C)
⇣
⌘
b · log(1/✏)
O nd2 + d2 (C)
O nd2 or O nd2 + d3

The upper part of the table lists algorithms whose complexity is linear in feature dimension d, including the two new
algorithms presented in the previous section. We can also
apply GTD2 to a finite dataset with samples drawn uniformly at random with replacement. It costs O(d) per iteration, but has a sublinear convergence rate regarding ✏. In
practice, people may choose ✏ = ⌦(1/n) for generalization reasons (see, e.g., Lazaric et al. (2010)), leading to an
O(0 nd) overall complexity for GTD2, where 0 is a condition number related to the algorithm. However, as verified
by our experiments, the bounds in the table show that our
SVRG/SAGA-based algorithms are much faster as their effective condition numbers vanish when n becomes large.
TDC has a similar complexity to GTD2.
In the table, we list two different implementations of
PDBG. PDBG-(I) computes the gradients by averaging the
stochastic gradients over the entire dataset at each iteration,
which costs O(nd) operations; see discussions at the end of
b bb
Section 4. PDBG-(II) first pre-computes the matrices A,
2
b
and C using O(nd ) operations, then computes the batch
gradient at each iteration with O(d2 ) operations. If d is
very large (e.g., when d
n), then PDBG-(I) would have
an advantage over PDBG-(II). The lower part of the table
also includes LSTD, which has O(nd2 ) complexity if rankone updates are used.
SVRG and SAGA are more efficient than the other algorithms, when either d or n is very large. In particular, they have a lower
⇣ ⌘ complexity than LSTD when d >
b 2
(C)

G
(1 +
) log 1✏ , This condition is easy to satisfy,
n
when n is very large. On the other hand, SVRG and SAGA
algorithms are more efficient than PDBG-(I) if n is large,
b 2 (C)
b
say n > (C)
1 , where  and G are deG
scribed in the caption of Table 1.

There are other algorithms whose complexity scales
linearly with n and d, including iLSTD (Geramifard
et al., 2007), and TDC (Sutton et al., 2009b), fLSTDSA (Prashanth et al., 2014), and the more recent algorithms
of Wang et al. (2016) and Dai et al. (2016). However, their

Stochastic Variance Reduction Methods for Policy Evaluation

convergence is slow: the number of iterations required to
reach a desired accuracy ✏ grows as 1/✏ or worse. The
CTD algorithm (Korda & Prashanth, 2015) uses a similar
idea as SVRG to reduce variance in TD updates. This algorithm is shown to have a similar linear convergence rate
in an online setting where the data stream is generated by a
Markov process with finite states and exponential mixing.
The method solves for a fixed-point solution by stochastic approximation. As a result, they can be non-convergent
in off-policy learning, while our algorithms remain stable
(c.f., Section 7.1).

7 Extensions
It is possible to extend our approach to accelerate optimization of other objectives such as MSBE and NEU (Dann
et al., 2014). In this section, we briefly describe two extensions of the algorithms developed earlier.
7.1 Off-policy learning
In some cases, we may want to estimate the value function
of a policy ⇡ from a set of data D generated by a different “behavior” policy ⇡b . This is called off-policy learning (Sutton & Barto, 1998, Chapter 8).
In the off-policy case, samples are generated from the distribution induced by the behavior policy ⇡b , not the the
target policy ⇡. While such a mismatch often causes
stochastic-approximation-based methods to diverge (Tsitsiklis & Van Roy, 1997), our gradient-based algorithms remain convergent with the same (fast) convergence rate.
Consider the RL framework outlined in Section 2. For each
state-action pair (st , at ) such that ⇡b (at |st ) > 0, we define
the importance ratio, ⇢t , ⇡(at |st )/⇡b (at |st ). The EMMSPBE for off-policy learning has the same expression as
in (7) except that At , bt and Ct are modified by the weight
factor ⇢t , as listed in Table 2; see also Liu et al. (2015,
Eqn 6) for a related discussion.) Algorithms 1–3 remain the
same for the off-policy case after At , bt and Ct are modified
correspondingly.
7.2 Learning with eligibility traces
Eligibility traces are a useful technique to trade off bias and
variance in TD learning (Singh & Sutton, 1996; Kearns &
Singh, 2000). When they are used, we can pre-compute zt
in Table 2 before running our new algorithms. Note that
EM-MSPBE with eligibility traces has the same form of
(7), with At , bt and Ct defined differently according to the
last row of Table 2. At the m-th step of the learning process, the algorithm randomly samples ztm , tm , 0tm and
rtm from the fixed dataset and computes the corresponding
stochastic gradients, where the index tm is uniformly distributed over {1, . . . , n} and are independent for different
values of m. Algorithms 1–3 immediately work for this
case, enjoying a similar linear convergence rate and a com-

Table 2. Expressions of At , bt and Ct for different cases of policy
Here, ⇢t , ⇡(at |st )/⇡b (at |st ); and zt ,
Pt evaluation.
)t i i , where
0 is a given parameter.
i=1 (
At

On-policy
Off-policy
Eligibility trace

t( t

⇢t t ( t
zt ( t

0 >
t)
0 >
t)
0 >
t)

bt
rt t
⇢t r t t
r t zt

Ct
t
t
t

>
t
>
t
>
t

putation complexity linear in n and d. We need additional
O(nd) operations to pre-compute zt recursively and an additional O(nd) storage for zt . However, it does not change
the order of the total complexity for SVRG/SAGA.

8

Experiments

In this section, we compare the following algorithms on
two benchmark problems: (i) PDBG (Algorithm 1); (ii)
GTD2 with samples drawn randomly with replacement
from a dataset; (iii) TD: the fLSTD-SA algorithm of
Prashanth et al. (2014); (iv) SVRG (Algorithm 2); and
(v) SAGA (Algorithm 3). Note that when ⇢ > 0, the
TD solution and EM-MSPBE minimizer differ, so we do
not include TD. For step size tuning, ✓ is chosen from
1
10 1 , 10 2 , . . . , 10 6 L (
b and w is chosen from
C)
⇢

1
1, 10 1 , 10 2
b . We only report the results of
max (C)
each algorithm which correspond to the best-tuned step
sizes; for SVRG we choose N = 2n.

In the first task, we consider a randomly generated MDP
with 400 states and 10 actions (Dann et al., 2014). The transition probabilities are defined as P (s0 |a, s) / pass0 +10 5 ,
where pass0 ⇠ U [0, 1]. The data-generating policy and start
distribution were generated in a similar way. Each state
is represented by a 201-dimensional feature vector, where
200 of the features were sampled from a uniform distribution, and the last feature was constant one. We chose
= 0.95. Fig. 1 shows the performance of various algorithms for n = 20000. First, notice that the stochastic
variance methods converge much faster than others. In fact,
our proposed methods achieve linear convergence. Second,
as we increase ⇢, the performances of PDBG, SVRG and
SAGA improve significantly due to better conditioning, as
predicted by our theoretical results.
Next, we test these algorithms on Mountain Car (Sutton &
Barto, 1998, Chapter 8). To collect the dataset, we first ran
Sarsa with d = 300 CMAC features to obtain a good policy.
Then, we ran this policy to collect trajectories that comprise the dataset. Figs. 2 and 3 show our proposed stochastic variance reduction methods dominate other first-order
methods. Moreover, with better conditioning (through a
larger ⇢), PDBG, SVRG and SAGA achieve faster convergence rate. Finally, as we increase sample size n, SVRG
and SAGA converge faster. This simulation verifies our

0

0

−2

−2

−4
−6
PDBG
GTD2
TD
SVRG
SAGA

−8
−10
−12
0

1000

2000
Epochs

3000

−4
−6
−8

−12
0

4000

(a) ⇢ = 0

PDBG
GTD2
SVRG
SAGA

−10

1000

(b) ⇢ =

q

2000
Epochs

3000

b> C
b

max (A

log10(Objective Value)

0
−2

log10(Objective Value)

log10(Objective Value)

Stochastic Variance Reduction Methods for Policy Evaluation

−4
−6
−8
PDBG
GTD2
SVRG
SAGA

−10
−12
0

4000

1000

(c) ⇢ =

1 A)
b

0

0

−2

−2

−2

−4
−6
PDBG
GTD2
TD
SVRG
SAGA

−8
−10
−12
0

500

1000

1500

−4
−6
−8
−10
−12
0

2000

PDBG
GTD2
SVRG
SAGA
500

Epochs

1000

1500

log10(Objective Value)

0

log10(Objective Value)

log10(Objective Value)

Figure 1. Random MDP with s = 400, d = 200, and n = 20000.

(b) ⇢ = 0.01

PDBG
GTD2
SVRG
SAGA

−10

500

b> C
b

max (A

1

b
A)

(c) ⇢ =

−2

−2

−2

PDBG
GTD2
TD
SVRG
SAGA

−10
−12
0

500

1000

1500

2000

−4
−6
−8
PDBG
GTD2
SVRG
SAGA

−10
−12
0

500

Epochs

(a) ⇢ = 0

1000

1500

2000

log10(Objective Value)

0

log10(Objective Value)

log10(Objective Value)

0

−8

9 Conclusions
In this paper, we reformulated the EM-MSPBE minimization problem in policy evaluation into an empirical saddlepoint problem, and developed and analyzed a batch gradient method and two first-order stochastic variance reduction methods to solve the problem. An important result we
obtained is that even when the reformulated saddle-point
problem lacks strong convexity in primal variables and has
only strong concavity in dual variables, the proposed algorithms are still able to achieve a linear convergence rate.
We are not aware of any similar results for primal-dual

2000

b> C
b

max (A

1

b
A)

b> C
b

max (A

1

b
A)

−6
−8
PDBG
GTD2
SVRG
SAGA

−10
−12
0

500

(c) ⇢ =

Figure 3. Mountain Car Data Set with d = 300 and n = 20000.

theoretical finding in Table 1 that SVRG/SAGA need fewer
epochs for large n.

1500

−4

Epochs

(b) ⇢ = 0.01

1000

Epochs

0

−6

4000

⌘
b> C
b 1A
b
A

−8

Figure 2. Mountain Car Data Set with d = 300 and n = 5000.

−4

3000

−6

Epochs

(a) ⇢ = 0

max

⇣

−4

−12
0

2000

2000
Epochs

1000
Epochs

b> C
b

max (A

1500

1

2000

b
A)

batch gradient methods or stochastic variance reduction
methods. Furthermore, we showed that when both the feature dimension d and the number of samples n are large, the
developed stochastic variance reduction methods are more
efficient than any other gradient-based methods which are
convergent in off-policy settings.
This work leads to several interesting directions for research. First, we believe it is important to extend the
stochastic variance reduction methods to nonlinear approximation paradigms (Bhatnagar et al., 2009), especially with
deep neural networks. Moreover, it remains an important
open problem how to apply stochastic variance reduction
techniques to policy optimization.

Stochastic Variance Reduction Methods for Policy Evaluation

References
Balamurugan, P and Bach, Francis. Stochastic variance reduction methods for saddle-point problems. In Advances
in Neural Information Processing Systems 29, pp. 1416–
1424, 2016.
Bertsekas, Dimitri P and Tsitsiklis, John N. Neurodynamic programming: An overview. In Decision and
Control, 1995., Proceedings of the 34th IEEE Conference on, volume 1, pp. 560–564. IEEE, 1995.
Bhatnagar, Shalabh, Precup, Doina, Silver, David, Sutton, Richard S, Maei, Hamid R, and Szepesvári, Csaba.
Convergent temporal-difference learning with arbitrary
smooth function approximation. In Advances in Neural
Information Processing Systems, pp. 1204–1212, 2009.
Boyan, Justin A. Technical update: Least-squares temporal difference learning. Machine Learning, 49:233–246,
2002.
Bradtke, Steven J and Barto, Andrew G. Linear leastsquares algorithms for temporal difference learning. Machine Learning, 22:33–57, 1996.
Chambolle, Antonin and Pock, Thomas. A first-order
primal-dual algorithm for convex problems with applications to imaging. Journal of Mathematical Imaging
and Vision, 40(1):120–145, 2011.
Dai, Bo, He, Niao, Pan, Yunpeng, Boots, Byron, and Song,
Le. Learning from conditional distributions via dual embeddings. arXiv:1607.04579, 2016.
Dann, Christoph, Neumann, Gerhard, and Peters, Jan. Policy evaluation with temporal differences: a survey and
comparison. Journal of Machine Learning Research, 15
(1):809–883, 2014.
Defazio, Aaron, Bach, Francis, and Lacoste-Julien, Simon.
SAGA: A fast incremental gradient method with support
for non-strongly convex composite objectives. In Advances in Neural Information Processing Systems, pp.
1646–1654, 2014.
Geramifard, Alborz, Bowling, Michael H., Zinkevich,
Martin, and Sutton, Richard S. iLSTD: Eligibility traces
and convergence analysis. In Advances in Neural Information Processing Systems 19, pp. 441–448, 2007.
Gohberg, Israel, Lancaster, Peter, and Rodman, Leiba. Indefinite linear algebra and applications. Springer Science & Business Media, 2006.
Johnson, Rie and Zhang, Tong. Accelerating stochastic
gradient descent using predictive variance reduction. In
Advances in Neural Information Processing Systems, pp.
315–323, 2013.

Kearns, Michael J. and Singh, Satinder P. “Bias-variance”
error bounds for temporal difference updates. In Proceedings of the Thirteenth Annual Conference on Computational Learning Theory (COLT-00), pp. 142–147,
2000.
Korda, Nathaniel and Prashanth, L.A. On TD(0) with function approximation: Concentration bounds and a centered variant with exponential convergence. In Proceedings of the Thirty-Second International Conference on
Machine Learning (ICML-15), pp. 626–634, 2015.
Lagoudakis, Michail G and Parr, Ronald. Least-squares
policy iteration. Journal of Machine Learning Research,
4(Dec):1107–1149, 2003.
Lange, Sascha, Gabel, Thomas, and Riedmiller, Martin.
Batch reinforcement learning. In Wiering, Marco and
van Otterlo, Martijn (eds.), Reinforcement Learning:
State of the Art, pp. 45–73. Springer Verlag, 2011.
Lazaric, Alessandro, Ghavamzadeh, Mohammad, and
Munos, Rémi. Finite-sample analysis of LSTD. In
Proceedings of the Twenty-Seventh International Conference on Machine Learning, pp. 615–622, 2010.
Lian, Xiangru, Wang, Mengdi, and Liu, Ji. Finite-sum
composition optimization via variance reduced gradient
descent. In Proceedings of Artificial Intelligence and
Statistics Conference (AISTATS), pp. 1159–1167, 2017.
Liesen, Jörg and Parlett, Beresford N. On nonsymmetric
saddle point matrices that allow conjugate gradient iterations. Numerische Mathematik, 108(4):605–624, 2008.
Lin, Hongzhou, Mairal, Julien, and Harchaoui, Zaid.
A universal catalyst for first-order optimization. In
Advances in Neural Information Processing Systems
(NIPS) 28, pp. 3384–3392, 2015.
Lin, Long-Ji. Self-improving reactive agents based on reinforcement learning, planning and teaching. Machine
Learning, 8(3–4):293–321, 1992.
Liu, Bo, Liu, Ji, Ghavamzadeh, Mohammad, Mahadevan,
Sridhar, and Petrik, Marek. Finite-sample analysis of
proximal gradient TD algorithms. In Proc. The 31st
Conf. Uncertainty in Artificial Intelligence, Amsterdam,
Netherlands, 2015.
Nedić, A. and Bertsekas, Dimitri P. Least squares policy evaluation algorithms with linear function approximation. Discrete Event Dynamics Systems: Theory and
Applications, 13(1):79–110, 2003.
Prashanth, LA, Korda, Nathaniel, and Munos, Rémi. Fast
LSTD using stochastic approximation: Finite time analysis and application to traffic control. In Joint European

Stochastic Variance Reduction Methods for Policy Evaluation

Conference on Machine Learning and Knowledge Discovery in Databases, pp. 66–81. Springer, 2014.
Precup, Doina, Sutton, Richard S., and Dasgupta, Sanjoy.
Off-policy temporal-difference learning with funtion approximation. In Proceedings of the Eighteenth Conference on Machine Learning (ICML-01), pp. 417–424,
2001.
Puterman, Martin L. Markov Decision Processes: Discrete
Stochastic Dynamic Programming. John Wiley & Sons,
2005.
Rockafellar, R. Tyrrell. Convex Analysis. Princeton University Press, 1970.
Shen, Shu-Qian, Huang, Ting-Zhu, and Cheng, GuangHui. A condition for the nonsymmetric saddle point
matrix being diagonalizable and having real and positive eigenvalues. Journal of Computational and Applied
Mathematics, 220(1):8–12, 2008.
Singh, Satinder P. and Sutton, Richard S. Reinforcement learning with replacing eligibility traces. Machine
Learning, 22(1–3):123–158, 1996.
Sutton, Richard S and Barto, Andrew G. Reinforcement
Learning: An Introduction. MIT Press, Cambridge, MA,
1998.
Sutton, Richard S, Maei, Hamid R, and Szepesvári, Csaba.
A convergent o(n) temporal-difference algorithm for
off-policy learning with linear function approximation.
In Advances in neural information processing systems,
pp. 1609–1616, 2009a.
Sutton, Richard S, Maei, Hamid Reza, Precup, Doina,
Bhatnagar, Shalabh, Silver, David, Szepesvári, Csaba,
and Wiewiora, Eric. Fast gradient-descent methods
for temporal-difference learning with linear function approximation. In Proceedings of the 26th Annual International Conference on Machine Learning, pp. 993–1000.
ACM, 2009b.
Tsitsiklis, John N. and Van Roy, Benjamin. An analysis
of temporal-difference learning with function approximation. IEEE Transactions on Automatic Control, 42:
674–690, 1997.
Valcarcel Macua, Sergio, Chen, Jianshu, Zazo, Santiago,
and Sayed, Ali H. Distributed policy evaluation under
multiple behavior strategies. Automatic Control, IEEE
Transactions on, 60(5):1260–1274, 2015.
Wang, Mengdi, Liu, Ji, and Fang, Ethan. Accelerating
stochastic composition optimization. In Advances in
Neural Information Processing Systems (NIPS) 29, pp.
1714–1722, 2016.

Wasserman, Larry. All of Statistics: A Concise Course in
Statistical Inference. Springer Science & Business Media, 2013.

